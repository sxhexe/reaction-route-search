<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head><meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>matrix3x3 Class Reference</title>
<link href="/site.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="search/search.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!--#include file="header.html" -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceOpenBabel.shtml">OpenBabel</a></li><li class="navelem"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classOpenBabel_1_1matrix3x3-members.shtml">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">matrix3x3 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="matrix3x3_8h_source.shtml">openbabel/math/matrix3x3.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for matrix3x3:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOpenBabel_1_1matrix3x3.png" usemap="#matrix3x3_map" alt=""/>
  <map id="matrix3x3_map" name="matrix3x3_map">
<area href="classOpenBabel_1_1transform3d.shtml" title="Handle 3D transformations, such as space group definitions. " alt="transform3d" shape="rect" coords="0,56,79,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02fbfa24687cc574a29a8d1c0ff0a2db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a02fbfa24687cc574a29a8d1c0ff0a2db">matrix3x3</a> (void)</td></tr>
<tr class="separator:a02fbfa24687cc574a29a8d1c0ff0a2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0461afe3f76b83a10fe99fac330f702"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#ac0461afe3f76b83a10fe99fac330f702">matrix3x3</a> (double s)</td></tr>
<tr class="separator:ac0461afe3f76b83a10fe99fac330f702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4736c0c51dc08725c39e02a84c2390ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a4736c0c51dc08725c39e02a84c2390ec">matrix3x3</a> (<a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> row1, <a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> row2, <a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> row3)</td></tr>
<tr class="separator:a4736c0c51dc08725c39e02a84c2390ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0be9b2cd186a15d56efdaaefa9a994"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a0a0be9b2cd186a15d56efdaaefa9a994">matrix3x3</a> (double d[3][3])</td></tr>
<tr class="separator:a0a0be9b2cd186a15d56efdaaefa9a994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3758cd834f7dd0f5c0816231349cb9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a6d3758cd834f7dd0f5c0816231349cb9">~matrix3x3</a> ()</td></tr>
<tr class="separator:a6d3758cd834f7dd0f5c0816231349cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f648014bbd17f8090159d2d93cbe30c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a3f648014bbd17f8090159d2d93cbe30c">GetArray</a> (double *m)</td></tr>
<tr class="separator:a3f648014bbd17f8090159d2d93cbe30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0db01a8386bdbdff8e3fb8fa62a313c"><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#ab0db01a8386bdbdff8e3fb8fa62a313c">operator()</a> (int row, int column) const</td></tr>
<tr class="separator:ab0db01a8386bdbdff8e3fb8fa62a313c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c4092616c1d0ffc2c3e022350ee02d"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a59c4092616c1d0ffc2c3e022350ee02d">operator()</a> (int row, int column)</td></tr>
<tr class="separator:a59c4092616c1d0ffc2c3e022350ee02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d250995fdd1e9782350ffe79d9abab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a00d250995fdd1e9782350ffe79d9abab">inverse</a> (void) const</td></tr>
<tr class="separator:a00d250995fdd1e9782350ffe79d9abab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa198c38170ceca2dfa52508dd3ce2f15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#aa198c38170ceca2dfa52508dd3ce2f15">transpose</a> (void) const</td></tr>
<tr class="separator:aa198c38170ceca2dfa52508dd3ce2f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff25b8b63c0aec5f2c83d0cb70ae55cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#aff25b8b63c0aec5f2c83d0cb70ae55cb">randomRotation</a> (<a class="el" href="classOpenBabel_1_1OBRandom.shtml">OBRandom</a> &amp;rnd)</td></tr>
<tr class="separator:aff25b8b63c0aec5f2c83d0cb70ae55cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567226bdd8fe4db0026d42aae75540ec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a567226bdd8fe4db0026d42aae75540ec">determinant</a> () const</td></tr>
<tr class="separator:a567226bdd8fe4db0026d42aae75540ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f567b85d822b28a4578e974758b2ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#ac7f567b85d822b28a4578e974758b2ce">isSymmetric</a> (void) const</td></tr>
<tr class="separator:ac7f567b85d822b28a4578e974758b2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc6490cdda5b1a70b3b0a9361264838"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a4dc6490cdda5b1a70b3b0a9361264838">isOrthogonal</a> (void) const</td></tr>
<tr class="separator:a4dc6490cdda5b1a70b3b0a9361264838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7738d934d2d55c2cd52e21a8f695e4cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a7738d934d2d55c2cd52e21a8f695e4cf">isDiagonal</a> (void) const</td></tr>
<tr class="separator:a7738d934d2d55c2cd52e21a8f695e4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd6a101107d0d44f6a53dcb4479f43f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#afdd6a101107d0d44f6a53dcb4479f43f">isUnitMatrix</a> (void) const</td></tr>
<tr class="separator:afdd6a101107d0d44f6a53dcb4479f43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecc5be8dfe990b9e9a751f789429f4f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#aeecc5be8dfe990b9e9a751f789429f4f">Get</a> (int row, int column) const</td></tr>
<tr class="separator:aeecc5be8dfe990b9e9a751f789429f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7e56afba0365c34add2d93288995ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#aae7e56afba0365c34add2d93288995ca">Set</a> (int row, int column, double v)</td></tr>
<tr class="separator:aae7e56afba0365c34add2d93288995ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39efd7a5999c653b840ac4445b9f86c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a39efd7a5999c653b840ac4445b9f86c2">SetColumn</a> (int column, const <a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> &amp;v)</td></tr>
<tr class="separator:a39efd7a5999c653b840ac4445b9f86c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20b033e3e502ab19ae92f55a9ef2fe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#ab20b033e3e502ab19ae92f55a9ef2fe2">SetRow</a> (int row, const <a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> &amp;v)</td></tr>
<tr class="separator:ab20b033e3e502ab19ae92f55a9ef2fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adfe5f674bfd8ab7648ec8b2db787b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a9adfe5f674bfd8ab7648ec8b2db787b9">GetColumn</a> (unsigned int col) const</td></tr>
<tr class="separator:a9adfe5f674bfd8ab7648ec8b2db787b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecfe73c4c97ace728d878dc3566e6fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#abecfe73c4c97ace728d878dc3566e6fa">GetRow</a> (unsigned int row) const</td></tr>
<tr class="separator:abecfe73c4c97ace728d878dc3566e6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4623ee2f3c5b2b7cc4c2efb081273f62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a4623ee2f3c5b2b7cc4c2efb081273f62">operator*=</a> (const double &amp;c)</td></tr>
<tr class="separator:a4623ee2f3c5b2b7cc4c2efb081273f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c27ea39208380495f812df6b865289"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a56c27ea39208380495f812df6b865289">operator/=</a> (const double &amp;c)</td></tr>
<tr class="separator:a56c27ea39208380495f812df6b865289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b052f9d6eaea593f20a032679bcc55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a99b052f9d6eaea593f20a032679bcc55">SetupRotMat</a> (double x, double y, double z)</td></tr>
<tr class="separator:a99b052f9d6eaea593f20a032679bcc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031b9641f48f7639949cad29a6a99109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a031b9641f48f7639949cad29a6a99109">PlaneReflection</a> (const <a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> &amp;norm)</td></tr>
<tr class="separator:a031b9641f48f7639949cad29a6a99109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b83cb7b73473405cd57594c88f541c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#ae2b83cb7b73473405cd57594c88f541c">RotAboutAxisByAngle</a> (const <a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> &amp;axis, const double angle)</td></tr>
<tr class="separator:ae2b83cb7b73473405cd57594c88f541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae6ec0ae0d036137c03275be0010878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#aeae6ec0ae0d036137c03275be0010878">FillOrth</a> (double alpha, double beta, double gamma, double a, double b, double c)</td></tr>
<tr class="separator:aeae6ec0ae0d036137c03275be0010878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07e6961b44f8ce4512b2b30caf45abf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#ad07e6961b44f8ce4512b2b30caf45abf">findEigenvectorsIfSymmetric</a> (<a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> &amp;eigenvals) const</td></tr>
<tr class="separator:ad07e6961b44f8ce4512b2b30caf45abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aeb205a916fa467164e6bdebc62d22e7a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#aeb205a916fa467164e6bdebc62d22e7a">jacobi</a> (unsigned int n, double *a, double *d, double *v)</td></tr>
<tr class="separator:aeb205a916fa467164e6bdebc62d22e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afa46ab021c49dc30bac7116157793dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#afa46ab021c49dc30bac7116157793dff">operator*</a> (const <a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> &amp;, const <a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> &amp;)</td></tr>
<tr class="separator:afa46ab021c49dc30bac7116157793dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fd56b260acc82508c9bf7e9a710125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a35fd56b260acc82508c9bf7e9a710125">operator*</a> (const <a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> &amp;, const <a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> &amp;)</td></tr>
<tr class="separator:a35fd56b260acc82508c9bf7e9a710125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3e65b4976b2ac7ce2a02b778e5cc71"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a0f3e65b4976b2ac7ce2a02b778e5cc71">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> &amp;)</td></tr>
<tr class="separator:a0f3e65b4976b2ac7ce2a02b778e5cc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a real 3x3 matrix. </p>
<p>Rotating points in space can be performed by a vector-matrix multiplication. The <a class="el" href="classOpenBabel_1_1matrix3x3.shtml" title="Represents a real 3x3 matrix. ">matrix3x3</a> class is designed as a helper to the <a class="el" href="classOpenBabel_1_1vector3.shtml" title="Represents a vector in 3-dimensional real space. ">vector3</a> class for rotating points in space. The rotation matrix may be initialised by passing in the array of floating point values, by passing euler angles, or a rotation vector and angle of rotation about that vector. Once set, the <a class="el" href="classOpenBabel_1_1matrix3x3.shtml" title="Represents a real 3x3 matrix. ">matrix3x3</a> class can be used to rotate vectors by the overloaded multiplication operator. The following demonstrates the usage of the <a class="el" href="classOpenBabel_1_1matrix3x3.shtml" title="Represents a real 3x3 matrix. ">matrix3x3</a> class:</p>
<div class="fragment"><div class="line"><a class="code" href="classOpenBabel_1_1matrix3x3.shtml#a02fbfa24687cc574a29a8d1c0ff0a2db">matrix3x3</a> mat;</div><div class="line">mat.SetupRotMat(0.0,180.0,0.0); <span class="comment">//rotate theta by 180 degrees</span></div><div class="line">vector3 v = <a class="code" href="namespaceOpenBabel.shtml#a6ca3b632d31093a7110635452bccc7bd">VX</a>;</div><div class="line">v *= mat; <span class="comment">//apply the rotation</span></div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a02fbfa24687cc574a29a8d1c0ff0a2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fbfa24687cc574a29a8d1c0ff0a2db">&sect;&nbsp;</a></span>matrix3x3() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the zero-matrix. </p>

</div>
</div>
<a id="ac0461afe3f76b83a10fe99fac330f702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0461afe3f76b83a10fe99fac330f702">&sect;&nbsp;</a></span>matrix3x3() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs s times the unit matrix. </p>

</div>
</div>
<a id="a4736c0c51dc08725c39e02a84c2390ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4736c0c51dc08725c39e02a84c2390ec">&sect;&nbsp;</a></span>matrix3x3() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a>&#160;</td>
          <td class="paramname"><em>row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a>&#160;</td>
          <td class="paramname"><em>row2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a>&#160;</td>
          <td class="paramname"><em>row3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a matrix from row vectors. </p>

</div>
</div>
<a id="a0a0be9b2cd186a15d56efdaaefa9a994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0be9b2cd186a15d56efdaaefa9a994">&sect;&nbsp;</a></span>matrix3x3() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>[3][3]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a matrix from a 3x3-array of doubles. </p>
<p>The first index represents the row, the second index the column </p>

</div>
</div>
<a id="a6d3758cd834f7dd0f5c0816231349cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3758cd834f7dd0f5c0816231349cb9">&sect;&nbsp;</a></span>~matrix3x3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3f648014bbd17f8090159d2d93cbe30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f648014bbd17f8090159d2d93cbe30c">&sect;&nbsp;</a></span>GetArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetArray </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access function. </p>
<p>Writes the matrix into the 1-dimensional array m, row by row. The array must be able to hold 9 doubles, otherwise your program will segfault. </p>

</div>
</div>
<a id="ab0db01a8386bdbdff8e3fb8fa62a313c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0db01a8386bdbdff8e3fb8fa62a313c">&sect;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double&amp; operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a constant reference to an element of the matrix. row and column must be between 0 and 2. No check is done. </dd></dl>

</div>
</div>
<a id="a59c4092616c1d0ffc2c3e022350ee02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c4092616c1d0ffc2c3e022350ee02d">&sect;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double&amp; operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-constant reference to an element of the matrix. row and column must be between 0 and 2. No check is done. </dd></dl>

</div>
</div>
<a id="a00d250995fdd1e9782350ffe79d9abab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d250995fdd1e9782350ffe79d9abab">&sect;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> inverse </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the inverse of a matrix. </p>
<p>This method checks if the absolute value of the determinant is smaller than 1e-6. If so, nothing is done and an exception is thrown. Otherwise, the inverse matrix is calculated and returned. *this is not changed.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the determinant is close to zero, but not == 0.0, this method may behave in unexpected ways and return almost random results; details may depend on your particular floating point implementation. The use of this method is therefore highly discouraged, unless you are certain that the determinant is in a reasonable range, away from 0.0 (Stefan Kebekus) </dd></dl>

<p>Referenced by <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#aa319e3756b542e64ae4bb96147c8b453">OBUnitCell::CartesianToFractional()</a>, <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#a4c67fccaf0b03a9e6eed368d2744d7cf">OBUnitCell::GetFractionalMatrix()</a>, and <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#aa087a37fcd1c8b08d5d58277caefbc9a">OBUnitCell::SetData()</a>.</p>

</div>
</div>
<a id="aa198c38170ceca2dfa52508dd3ce2f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa198c38170ceca2dfa52508dd3ce2f15">&sect;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> transpose </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the transpose of a matrix. </p>

<p>Referenced by <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#a00b3c406e65edf13852a3d453d002b06">OBUnitCell::GetCellMatrix()</a>, and <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#aa087a37fcd1c8b08d5d58277caefbc9a">OBUnitCell::SetData()</a>.</p>

</div>
</div>
<a id="aff25b8b63c0aec5f2c83d0cb70ae55cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff25b8b63c0aec5f2c83d0cb70ae55cb">&sect;&nbsp;</a></span>randomRotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void randomRotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenBabel_1_1OBRandom.shtml">OBRandom</a> &amp;&#160;</td>
          <td class="paramname"><em>rnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a matrix for a random rotation. </p>
<p>The axis of the rotation will be uniformly distributed on the unit sphere and the angle will be uniformly distributed in the interval 0..360 degrees. </p>

</div>
</div>
<a id="a567226bdd8fe4db0026d42aae75540ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567226bdd8fe4db0026d42aae75540ec">&sect;&nbsp;</a></span>determinant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double determinant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The determinant of the matrix </dd></dl>

<p>Referenced by <a class="el" href="namespaceOpenBabel.shtml#a07c3e3dff340f78121cc2c15da53cdb2">OpenBabel::signed_volume()</a>.</p>

</div>
</div>
<a id="ac7f567b85d822b28a4578e974758b2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f567b85d822b28a4578e974758b2ce">&sect;&nbsp;</a></span>isSymmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSymmetric </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a matrix is symmetric. </p>
<dl class="section return"><dt>Returns</dt><dd>False if there are indices i,j such that fabs(*this[i][j]-*this[j][i]) &gt; 1e-6. Otherwise, it returns true. </dd></dl>

</div>
</div>
<a id="a4dc6490cdda5b1a70b3b0a9361264838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc6490cdda5b1a70b3b0a9361264838">&sect;&nbsp;</a></span>isOrthogonal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isOrthogonal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a matrix is orthogonal. </p>
<p>This method checks if a matrix is orthogonal, i.e. if all column vectors are normalized and are mutually orthogonal. A matrix is orthogonal if, and only if the transformation it describes is orthonormal. An orthonormal transformation is a transformation that preserves length and angle.</p>
<p>The check is performed using the method <a class="el" href="classOpenBabel_1_1matrix3x3.shtml#afdd6a101107d0d44f6a53dcb4479f43f">isUnitMatrix()</a> to check if </p><div class="fragment"><div class="line">*<span class="keyword">this</span> * <a class="code" href="classOpenBabel_1_1matrix3x3.shtml#aa198c38170ceca2dfa52508dd3ce2f15">transpose</a>()</div></div><!-- fragment --><p> is a unit matrix. The criterion is therefore numerically quite tight. </p>

</div>
</div>
<a id="a7738d934d2d55c2cd52e21a8f695e4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7738d934d2d55c2cd52e21a8f695e4cf">&sect;&nbsp;</a></span>isDiagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isDiagonal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if a matrix is diagonal</dd></dl>
<p>This method returns true if and only if the matrix is (approximately) a diagonal matrix. The precision used by this function is 1e-6. </p>

</div>
</div>
<a id="afdd6a101107d0d44f6a53dcb4479f43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd6a101107d0d44f6a53dcb4479f43f">&sect;&nbsp;</a></span>isUnitMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isUnitMatrix </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if a matrix is the unit matrix</dd></dl>
<p>This method returns true if and only if the matrix is (approximately) equal to the identity matrix. The precision used by this function is 1e-6. </p>

</div>
</div>
<a id="aeecc5be8dfe990b9e9a751f789429f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecc5be8dfe990b9e9a751f789429f4f">&sect;&nbsp;</a></span>Get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access function. </p>
<dl class="section warning"><dt>Warning</dt><dd>row or column are not in the range 0..2, zero is returned !</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.shtml#_deprecated000080">Deprecated:</a></b></dt><dd>use the constant operator() instead </dd></dl>

<p>Referenced by <a class="el" href="classOpenBabel_1_1vector3.shtml#ab879d8d94111c53fd9b9013fb9345734">vector3::operator*=()</a>.</p>

</div>
</div>
<a id="aae7e56afba0365c34add2d93288995ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7e56afba0365c34add2d93288995ca">&sect;&nbsp;</a></span>Set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access function. </p>
<dl class="section warning"><dt>Warning</dt><dd>if row or column are not in the range 0..2, nothing will happen !</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.shtml#_deprecated000081">Deprecated:</a></b></dt><dd>use the non-constant operator() instead </dd></dl>

</div>
</div>
<a id="a39efd7a5999c653b840ac4445b9f86c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39efd7a5999c653b840ac4445b9f86c2">&sect;&nbsp;</a></span>SetColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetColumn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access function. </p>
<dl class="section warning"><dt>Warning</dt><dd>If column is not in the range 0..2, the vector remains unchanged and an exception is thrown. </dd></dl>

</div>
</div>
<a id="ab20b033e3e502ab19ae92f55a9ef2fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20b033e3e502ab19ae92f55a9ef2fe2">&sect;&nbsp;</a></span>SetRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetRow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access function. </p>
<dl class="section warning"><dt>Warning</dt><dd>If column is not in the range 0..2, the vector remains unchanged and an exception is thrown. </dd></dl>

</div>
</div>
<a id="a9adfe5f674bfd8ab7648ec8b2db787b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adfe5f674bfd8ab7648ec8b2db787b9">&sect;&nbsp;</a></span>GetColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> GetColumn </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access function. </p>
<dl class="section warning"><dt>Warning</dt><dd>If col is not in the range 0..2, an exception is thrown. </dd></dl>

<p>Referenced by <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#a71ca46e3ddb9b15db1b5971aa7c4a332">OBUnitCell::GetA()</a>, <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#aaeabaff376398e216c49714233a8a2e3">OBUnitCell::GetAlpha()</a>, <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#a1d1ca648c4d55ad3275e0737e3ca6ecc">OBUnitCell::GetB()</a>, <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#a3d0e243a601d66ba5c1c95762eea45d0">OBUnitCell::GetBeta()</a>, <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#a29fff830d7b77eb427ef8fc733d15e17">OBUnitCell::GetC()</a>, and <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#a16ebee183db5b1e08f722602c07b7a44">OBUnitCell::GetGamma()</a>.</p>

</div>
</div>
<a id="abecfe73c4c97ace728d878dc3566e6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecfe73c4c97ace728d878dc3566e6fa">&sect;&nbsp;</a></span>GetRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> GetRow </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access function. </p>
<dl class="section warning"><dt>Warning</dt><dd>If row is not in the range 0..2, an exception is thrown. </dd></dl>

<p>Referenced by <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#ad9876418d08424706cc37d6f8d23116d">OBUnitCell::GetCellVectors()</a>, and <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#a305d661a815053b610cb220fdfc3922c">OBUnitCell::SetData()</a>.</p>

</div>
</div>
<a id="a4623ee2f3c5b2b7cc4c2efb081273f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4623ee2f3c5b2b7cc4c2efb081273f62">&sect;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a>&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies all entries of the matrix by a scalar c. </p>

</div>
</div>
<a id="a56c27ea39208380495f812df6b865289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c27ea39208380495f812df6b865289">&sect;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a>&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides all entries of the matrix by a scalar c. </p>

</div>
</div>
<a id="a99b052f9d6eaea593f20a032679bcc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b052f9d6eaea593f20a032679bcc55">&sect;&nbsp;</a></span>SetupRotMat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetupRotMat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a rotation matrix for rotation about the x, y, and z axes by the angles specified (in degrees) </p>

<p>Referenced by <a class="el" href="classOpenBabel_1_1OBBuilder.shtml#abe40cdbb1abc8939273d9cde6b7b638a">OBBuilder::Connect()</a>.</p>

</div>
</div>
<a id="a031b9641f48f7639949cad29a6a99109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031b9641f48f7639949cad29a6a99109">&sect;&nbsp;</a></span>PlaneReflection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PlaneReflection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a matrix that represents reflection on a plane. </p>
<p>Replaces *this with a matrix that represents reflection on the plane through 0 which is given by the normal vector norm.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the vector norm has length zero, this method will generate the 0-matrix. If the length of the axis is close to zero, but not == 0.0, this method may behave in unexpected ways and return almost random results; details may depend on your particular floating point implementation. The use of this method is therefore highly discouraged, unless you are certain that the length is in a reasonable range, away from 0.0 (Stefan Kebekus)</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.shtml#_deprecated000096">Deprecated:</a></b></dt><dd>This method will probably replaced by a safer algorithm in the future.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.shtml#_todo000018">Todo:</a></b></dt><dd>Replace this method with a more fool-proof version.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>specifies the normal to the plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2b83cb7b73473405cd57594c88f541c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b83cb7b73473405cd57594c88f541c">&sect;&nbsp;</a></span>RotAboutAxisByAngle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RotAboutAxisByAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a rotation matrix, rotating around the specified axis by the specified angle (in degrees) </p>
<p>Replaces *this with a matrix that represents rotation about the axis by a an angle.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the vector axis has length zero, this method will generate the 0-matrix. If the length of the axis is close to zero, but not == 0.0, this method may behave in unexpected ways and return almost random results; details may depend on your particular floating point implementation. The use of this method is therefore highly discouraged, unless you are certain that the length is in a reasonable range, away from 0.0 (Stefan Kebekus)</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.shtml#_deprecated000097">Deprecated:</a></b></dt><dd>This method will probably replaced by a safer algorithm in the future.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.shtml#_todo000019">Todo:</a></b></dt><dd>Replace this method with a more fool-proof version.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>specifies the axis of the rotation </td></tr>
    <tr><td class="paramname">angle</td><td>angle in degrees (0..360) </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classOpenBabel_1_1OBMol.shtml#a228de88f48ee3ca6a11554b74d82dedd">OBMol::Align()</a>, <a class="el" href="classOpenBabel_1_1OBBuilder.shtml#ac543a42f2765cba8535d145519372bc5">OBBuilder::Build()</a>, <a class="el" href="classOpenBabel_1_1OBBuilder.shtml#ad0cefa50ad126c06c03bad33175ce2b4">OBBuilder::GetNewBondVector()</a>, <a class="el" href="classOpenBabel_1_1OBBuilder.shtml#a7baa4d72adf170defdf09a225b3edf57">OBBuilder::IsSpiroAtom()</a>, and <a class="el" href="classOpenBabel_1_1OBAtom.shtml#af7a144a4ef755d5cc31e0d2e47a2e84a">OBAtom::SetHybAndGeom()</a>.</p>

</div>
</div>
<a id="aeae6ec0ae0d036137c03275be0010878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae6ec0ae0d036137c03275be0010878">&sect;&nbsp;</a></span>FillOrth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FillOrth </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate an orthogonalisation matrix for a unit cell specified by the parameters alpha, beta, gamma, a, b, c where alpha, beta, and gamma are the cell angles (in degrees) and a, b, and c are the cell vector lengths Used by <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml" title="Used for storing information about periodic boundary conditions with conversion to/from translation v...">OBUnitCell</a> </p>

<p>Referenced by <a class="el" href="classOpenBabel_1_1OBUnitCell.shtml#acca66a4b8a38d190c178b6ed85f9b8ed">OBUnitCell::SetData()</a>.</p>

</div>
</div>
<a id="ad07e6961b44f8ce4512b2b30caf45abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07e6961b44f8ce4512b2b30caf45abf">&sect;&nbsp;</a></span>findEigenvectorsIfSymmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> findEigenvectorsIfSymmetric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>eigenvals</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the eigenvalues and -vectors of a symmetric matrix. </p>
<p>This method employs the static method <a class="el" href="classOpenBabel_1_1matrix3x3.shtml#aeb205a916fa467164e6bdebc62d22e7a" title="Eigenvalue calculation. ">matrix3x3::jacobi</a>(...) to find the eigenvalues and eigenvectors of a symmetric matrix. On entry it is checked if the matrix really is symmetric: if <a class="el" href="classOpenBabel_1_1matrix3x3.shtml#ac7f567b85d822b28a4578e974758b2ce" title="Checks if a matrix is symmetric. ">isSymmetric()</a> returns 'false', an <a class="el" href="classOpenBabel_1_1OBError.shtml" title="Customizable error handling and logging – store a message, including the method yielding the error...">OBError</a> is thrown.</p>
<dl class="section note"><dt>Note</dt><dd>The jacobi algorithm is should work great for all symmetric 3x3 matrices. If you need to find the eigenvectors of a non-symmetric matrix, you might want to resort to the sophisticated routines of LAPACK.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eigenvals</td><td>a reference to a <a class="el" href="classOpenBabel_1_1vector3.shtml" title="Represents a vector in 3-dimensional real space. ">vector3</a> where the eigenvalues will be stored. The eigenvalues are ordered so that eigenvals[0] &lt;= eigenvals[1] &lt;= eigenvals[2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an orthogonal matrix whose ith column is an eigenvector for the eigenvalue eigenvals[i]. Here 'orthogonal' means that all eigenvectors have length one and are mutually orthogonal. The ith eigenvector can thus be conveniently accessed by the <a class="el" href="classOpenBabel_1_1matrix3x3.shtml#a9adfe5f674bfd8ab7648ec8b2db787b9" title="Access function. ">GetColumn()</a> method, as in the following example. <div class="fragment"><div class="line"><span class="comment">// Calculate eigenvectors and -values</span></div><div class="line">vector3 eigenvals;</div><div class="line"><a class="code" href="classOpenBabel_1_1matrix3x3.shtml#a02fbfa24687cc574a29a8d1c0ff0a2db">matrix3x3</a> eigenmatrix = somematrix.findEigenvectorsIfSymmetric(eigenvals);</div><div class="line"></div><div class="line"><span class="comment">// Print the 2nd eigenvector</span></div><div class="line">cout &lt;&lt; eigenmatrix.GetColumn(1) &lt;&lt; endl;</div></div><!-- fragment --> With these conventions, a matrix is diagonalized in the following way: <div class="fragment"><div class="line"><span class="comment">// Diagonalize the matrix</span></div><div class="line"><a class="code" href="classOpenBabel_1_1matrix3x3.shtml#a02fbfa24687cc574a29a8d1c0ff0a2db">matrix3x3</a> diagonalMatrix = eigenmatrix.inverse() * somematrix * eigenmatrix;</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aeb205a916fa467164e6bdebc62d22e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb205a916fa467164e6bdebc62d22e7a">&sect;&nbsp;</a></span>jacobi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jacobi </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eigenvalue calculation. </p>
<p>This static function computes the eigenvalues and eigenvectors of a SYMMETRIC nxn matrix. This method is used internally by <a class="el" href="namespaceOpenBabel.shtml" title="Global namespace for all Open Babel code. ">OpenBabel</a>, but may be useful as a general eigenvalue finder.</p>
<p>The algorithm uses Jacobi transformations. It is described e.g. in Wilkinson, Reinsch "Handbook for automatic computation,
Volume II: Linear Algebra", part II, contribution II/1. The implementation is also similar to the implementation in this book. This method is adequate to solve the eigenproblem for small matrices, of size perhaps up to 10x10. For bigger problems, you might want to resort to the sophisticated routines of LAPACK.</p>
<dl class="section note"><dt>Note</dt><dd>If you plan to find the eigenvalues of a symmetric 3x3 matrix, you will probably prefer to use the more convenient method <a class="el" href="classOpenBabel_1_1matrix3x3.shtml#ad07e6961b44f8ce4512b2b30caf45abf" title="Find the eigenvalues and -vectors of a symmetric matrix. ">findEigenvectorsIfSymmetric()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the size of the matrix that should be diagonalized</td></tr>
    <tr><td class="paramname">a</td><td>array of size n^2 which holds the symmetric matrix whose eigenvectors are to be computed. The convention is that the entry in row r and column c is addressed as a[n*r+c] where, of course, 0 &lt;= r &lt; n and 0 &lt;= c &lt; n. There is no check that the matrix is actually symmetric. If it is not, the behaviour of this function is undefined. On return, the matrix is overwritten with junk.</td></tr>
    <tr><td class="paramname">d</td><td>pointer to a field of at least n doubles which will be overwritten. On return of this function, the entries d[0]..d[n-1] will contain the eigenvalues of the matrix.</td></tr>
    <tr><td class="paramname">v</td><td>an array of size n^2 where the eigenvectors will be stored. On return, the columns of this matrix will contain the eigenvectors. The eigenvectors are normalized and mutually orthogonal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="afa46ab021c49dc30bac7116157793dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa46ab021c49dc30bac7116157793dff">&sect;&nbsp;</a></span>operator* <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1vector3.shtml">vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix-vector multiplication. </p>
<p>Calculates the product m*v of the matrix m and the column vector represented by v </p>

</div>
</div>
<a id="a35fd56b260acc82508c9bf7e9a710125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fd56b260acc82508c9bf7e9a710125">&sect;&nbsp;</a></span>operator* <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix-matrix multiplication. </p>

</div>
</div>
<a id="a0f3e65b4976b2ac7ce2a02b778e5cc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3e65b4976b2ac7ce2a02b778e5cc71">&sect;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>co</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1matrix3x3.shtml">matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output a text representation of a matrix. </p>
<p>Print a text representation of the matrix in the standardized form: [ a, b, c ] <br />
 [ d, e, f ] <br />
 [ g, h, i ] <br />
 where the letters represent the appropriate entries in the matrix. Uses the standard output format for the individual entries, separated by ", " for each column, and [ ] indicating each row. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="matrix3x3_8h_source.shtml">matrix3x3.h</a></li>
<li><a class="el" href="matrix3x3_8cpp.shtml">matrix3x3.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- end content -->
<!--#include file="footer.html" -->
<div id="footer">
<hr size="1">
<img src="http://openbabel.org/babel256.png" width="136" height="127" alt="" style="float: left;" />
<p>This file is part of the documentation for <a href="http://openbabel.org/wiki/">Open Babel</a>, version 2.4.1.</p>
<div class="bottom">
Documentation copyright &copy; 1998-2007, the <a href="http://openbabel.org/wiki/THANKS">Open Babel Developers</a>.<br>
Open Babel is hosted by: <a href="http://sourceforge.net">
<img src="http://sourceforge.net/sflogo.php?group_id=40728" 
width="88" height="31" border="0" alt="SourceForge Logo"></a><br>
Generated on Mon Oct 10 2016 12:39:30 by&nbsp;<a href="http://www.doxygen.org/"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.12.
</div>
</body>
</html>
