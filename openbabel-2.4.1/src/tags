!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AE_ACYCLIC	parsmart.cpp	106;"	d	file:
AE_ALIPHATIC	parsmart.cpp	104;"	d	file:
AE_ALIPHELEM	parsmart.cpp	110;"	d	file:
AE_ANDHI	parsmart.cpp	96;"	d	file:
AE_ANDLO	parsmart.cpp	97;"	d	file:
AE_AROMATIC	parsmart.cpp	103;"	d	file:
AE_AROMELEM	parsmart.cpp	109;"	d	file:
AE_CHARGE	parsmart.cpp	112;"	d	file:
AE_CHIRAL	parsmart.cpp	119;"	d	file:
AE_CONNECT	parsmart.cpp	113;"	d	file:
AE_CYCLIC	parsmart.cpp	105;"	d	file:
AE_DEGREE	parsmart.cpp	114;"	d	file:
AE_ELEM	parsmart.cpp	108;"	d	file:
AE_FALSE	parsmart.cpp	102;"	d	file:
AE_HCOUNT	parsmart.cpp	111;"	d	file:
AE_HYB	parsmart.cpp	120;"	d	file:
AE_IMPLICIT	parsmart.cpp	115;"	d	file:
AE_MASS	parsmart.cpp	107;"	d	file:
AE_NOT	parsmart.cpp	100;"	d	file:
AE_OR	parsmart.cpp	98;"	d	file:
AE_RECUR	parsmart.cpp	99;"	d	file:
AE_RINGCONNECT	parsmart.cpp	121;"	d	file:
AE_RINGS	parsmart.cpp	116;"	d	file:
AE_SIZE	parsmart.cpp	117;"	d	file:
AE_TRUE	parsmart.cpp	101;"	d	file:
AE_VALENCE	parsmart.cpp	118;"	d	file:
AI_C	chains.cpp	72;"	d	file:
AI_C1	chains.cpp	87;"	d	file:
AI_C2	chains.cpp	85;"	d	file:
AI_C3	chains.cpp	83;"	d	file:
AI_C4	chains.cpp	81;"	d	file:
AI_C5	chains.cpp	80;"	d	file:
AI_CA	chains.cpp	71;"	d	file:
AI_N	chains.cpp	70;"	d	file:
AI_O	chains.cpp	73;"	d	file:
AI_O1P	chains.cpp	77;"	d	file:
AI_O2	chains.cpp	86;"	d	file:
AI_O2P	chains.cpp	78;"	d	file:
AI_O3	chains.cpp	84;"	d	file:
AI_O4	chains.cpp	82;"	d	file:
AI_O5	chains.cpp	79;"	d	file:
AI_OXT	chains.cpp	74;"	d	file:
AI_P	chains.cpp	76;"	d	file:
AL_ANTICLOCKWISE	parsmart.cpp	124;"	d	file:
AL_CLOCKWISE	parsmart.cpp	123;"	d	file:
AL_UNSPECIFIED	parsmart.cpp	125;"	d	file:
AMINOMAX	chains.cpp	64;"	d	file:
ANY_ATOM	mcdlutil.cpp	150;"	d	file:
ANY_BOND	mcdlutil.cpp	152;"	d	file:
AROMATIC_MASK	mcdlutil.cpp	/^    static int const AROMATIC_MASK=NOOTHER_MASK << 1;$/;"	m	class:OpenBabel::TEditedMolecule	file:
ATOMMAX	chains.cpp	206;"	d	file:
ATOMMINAMINO	chains.cpp	57;"	d	file:
ATOMMINNUCLEIC	chains.cpp	58;"	d	file:
ATOMPOOL	parsmart.cpp	93;"	d	file:
Acceptor	tautomer.cpp	/^      Acceptor,$/;"	e	enum:OpenBabel::TautomerImpl::Type	file:
Add	fingerprint.cpp	/^  bool FastSearchIndexer::Add(OBBase* pOb, std::streampos seekpos)$/;"	f	class:OpenBabel::FastSearchIndexer
AddAliases	alias.cpp	/^bool AliasData::AddAliases(OBMol* pmol)$/;"	f	class:OpenBabel::AliasData
AddAngleConstraint	forcefield.cpp	/^  void OBFFConstraints::AddAngleConstraint(int a, int b, int c, double angle)$/;"	f	class:OpenBabel::OBFFConstraints
AddAtom	mol.cpp	/^  bool OBMol::AddAtom(OBAtom &atom, bool forceNewId)$/;"	f	class:OpenBabel::OBMol
AddAtom	residue.cpp	/^  void OBResidue::AddAtom(OBAtom *atom)$/;"	f	class:OpenBabel::OBResidue
AddAtomConstraint	forcefield.cpp	/^  void OBFFConstraints::AddAtomConstraint(int a)$/;"	f	class:OpenBabel::OBFFConstraints
AddAtomRef	generic.cpp	/^  int OBChiralData::AddAtomRef(unsigned int atomref, atomreftype t)$/;"	f	class:OpenBabel::OBChiralData
AddAtomXConstraint	forcefield.cpp	/^  void OBFFConstraints::AddAtomXConstraint(int a)$/;"	f	class:OpenBabel::OBFFConstraints
AddAtomYConstraint	forcefield.cpp	/^  void OBFFConstraints::AddAtomYConstraint(int a)$/;"	f	class:OpenBabel::OBFFConstraints
AddAtomZConstraint	forcefield.cpp	/^  void OBFFConstraints::AddAtomZConstraint(int a)$/;"	f	class:OpenBabel::OBFFConstraints
AddBond	mol.cpp	/^  bool OBMol::AddBond(OBBond &bond)$/;"	f	class:OpenBabel::OBMol
AddBond	mol.cpp	/^  bool OBMol::AddBond(int first,int second,int order,int flags,int insertpos)$/;"	f	class:OpenBabel::OBMol
AddChemObject	obconversion.cpp	/^  int OBConversion::AddChemObject(OBBase* pOb)$/;"	f	class:OpenBabel::OBConversion
AddConformer	distgeom.cpp	/^  void OBDistanceGeometry::AddConformer()$/;"	f	class:OpenBabel::OBDistanceGeometry
AddDistanceConstraint	forcefield.cpp	/^  void OBFFConstraints::AddDistanceConstraint(int a, int b, double length)$/;"	f	class:OpenBabel::OBFFConstraints
AddExpandedAtom	alias.cpp	/^void AliasData::AddExpandedAtom(int id) { _expandedatoms.push_back(id); };$/;"	f	class:OpenBabel::AliasData
AddHydrogens	mol.cpp	/^  bool OBMol::AddHydrogens(OBAtom *atom)$/;"	f	class:OpenBabel::OBMol
AddHydrogens	mol.cpp	/^  bool OBMol::AddHydrogens(bool polaronly, bool correctForPH, double pH)$/;"	f	class:OpenBabel::OBMol
AddIgnore	forcefield.cpp	/^  void OBFFConstraints::AddIgnore(int a)$/;"	f	class:OpenBabel::OBFFConstraints
AddInterGroup	forcefield.cpp	/^  void OBForceField::AddInterGroup(OBBitVec &group)$/;"	f	class:OpenBabel::OBForceField
AddInterGroups	forcefield.cpp	/^  void OBForceField::AddInterGroups(OBBitVec &group1, OBBitVec &group2)$/;"	f	class:OpenBabel::OBForceField
AddIntraGroup	forcefield.cpp	/^  void OBForceField::AddIntraGroup(OBBitVec &group)$/;"	f	class:OpenBabel::OBForceField
AddNbrs	builder.cpp	/^  void OBBuilder::AddNbrs(OBBitVec &fragment, OBAtom *atom)$/;"	f	class:OpenBabel::OBBuilder
AddNewHydrogens	mol.cpp	/^  bool OBMol::AddNewHydrogens(HydrogenType whichHydrogen, bool correctForPH, double pH)$/;"	f	class:OpenBabel::OBMol
AddNonPolarHydrogens	mol.cpp	/^  bool OBMol::AddNonPolarHydrogens()$/;"	f	class:OpenBabel::OBMol
AddOption	obconversion.cpp	/^  void OBConversion::AddOption(const char* opt, Option_type opttyp, const char* txt)$/;"	f	class:OpenBabel::OBConversion
AddPolarHydrogens	mol.cpp	/^  bool OBMol::AddPolarHydrogens()$/;"	f	class:OpenBabel::OBMol
AddPose	confsearch.cpp	/^  bool OBDiversePoses::AddPose(double* coords, double energy) {$/;"	f	class:OpenBabel::OBDiversePoses
AddPose	confsearch.cpp	/^  bool OBDiversePoses::AddPose(vector<vector3> vcoords, double energy) {$/;"	f	class:OpenBabel::OBDiversePoses
AddProperties	descriptor.cpp	/^void OBDescriptor::AddProperties(OBBase* pOb, const string& DescrList)$/;"	f	class:OpenBabel::OBDescriptor
AddResidue	mol.cpp	/^  bool OBMol::AddResidue(OBResidue &residue)$/;"	f	class:OpenBabel::OBMol
AddRingFromClosure	ring.cpp	/^  void OBRingSearch::AddRingFromClosure(OBMol &mol,OBBond *cbond)$/;"	f	class:OpenBabel::OBRingSearch
AddRingNbrs	builder.cpp	/^  void OBBuilder::AddRingNbrs(OBBitVec &fragment, OBAtom *atom, OBMol &mol)$/;"	f	class:OpenBabel::OBBuilder
AddRotamer	rotamer.cpp	/^  void OBRotamerList::AddRotamer(double *c)$/;"	f	class:OpenBabel::OBRotamerList
AddRotamer	rotamer.cpp	/^  void OBRotamerList::AddRotamer(int *arr)$/;"	f	class:OpenBabel::OBRotamerList
AddRotamer	rotamer.cpp	/^  void OBRotamerList::AddRotamer(std::vector<int> arr)$/;"	f	class:OpenBabel::OBRotamerList
AddRotamer	rotamer.cpp	/^  void OBRotamerList::AddRotamer(unsigned char *arr)$/;"	f	class:OpenBabel::OBRotamerList
AddRotamers	rotamer.cpp	/^  void OBRotamerList::AddRotamers(unsigned char *arr,int nrotamers)$/;"	f	class:OpenBabel::OBRotamerList
AddTorsion	generic.cpp	/^  bool OBTorsion::AddTorsion(OBAtom *a,OBAtom *b, OBAtom *c,OBAtom *d)$/;"	f	class:OpenBabel::OBTorsion
AddTorsion	generic.cpp	/^  bool OBTorsion::AddTorsion(quad<OBAtom*,OBAtom*,OBAtom*,OBAtom*> &atoms)$/;"	f	class:OpenBabel::OBTorsion
AddTorsionConstraint	forcefield.cpp	/^  void OBFFConstraints::AddTorsionConstraint(int a, int b, int c, int d, double torsion)$/;"	f	class:OpenBabel::OBFFConstraints
Align	mol.cpp	/^  void OBMol::Align(OBAtom *a1,OBAtom *a2,vector3 &p1,vector3 &p2)$/;"	f	class:OpenBabel::OBMol
AllPluginsLoaded	plugin.cpp	/^int OBPlugin::AllPluginsLoaded = 0;$/;"	m	class:OpenBabel::OBPlugin	file:
AllocPattern	parsmart.cpp	/^  static Pattern *AllocPattern( void )$/;"	f	namespace:OpenBabel
AllocateByteCode	chains.cpp	/^  static ByteCode *AllocateByteCode(int type)$/;"	f	namespace:OpenBabel
AminoAcids	chains.cpp	/^  static ResidType AminoAcids[AMINOMAX] = {$/;"	m	namespace:OpenBabel	file:
Apply	phmodel.cpp	/^  bool OBChemTsfm::Apply(OBMol &mol)$/;"	f	class:OpenBabel::OBChemTsfm
ApplyRotMatToBond	atom.cpp	/^  static void ApplyRotMatToBond(OBMol &mol,matrix3x3 &m,OBAtom *a1,OBAtom *a2)$/;"	f	namespace:OpenBabel
ApproxZero	obutil.cpp	767;"	d	file:
AreInSameRing	distgeom.cpp	/^  int OBDistanceGeometry::AreInSameRing(OBAtom *a, OBAtom *b)$/;"	f	class:OpenBabel::OBDistanceGeometry
AreInSameRing	mol.cpp	/^  int OBMol::AreInSameRing(OBAtom *a, OBAtom *b)$/;"	f	class:OpenBabel::OBMol
AssignAromaticFlags	typer.cpp	/^  void OBAromaticTyper::AssignAromaticFlags(OBMol &mol)$/;"	f	class:OpenBabel::OBAromaticTyper
AssignAtomTypes	tautomer.cpp	/^    void AssignAtomTypes(OBMol *mol, std::vector<Type> &types)$/;"	f	struct:OpenBabel::TautomerImpl
AssignBondTypes	tautomer.cpp	/^    void AssignBondTypes(OBMol *mol, const std::vector<Type> &atomTypes, std::vector<Type> &bondTypes)$/;"	f	struct:OpenBabel::TautomerImpl
AssignBonds	data.cpp	/^  bool OBResidueData::AssignBonds(OBMol &mol,OBBitVec &bv)$/;"	f	class:OpenBabel::OBResidueData
AssignFunctionalGroupBonds	bondtyper.cpp	/^  void OBBondTyper::AssignFunctionalGroupBonds(OBMol &mol)$/;"	f	class:OpenBabel::OBBondTyper
AssignHyb	typer.cpp	/^  void OBAtomTyper::AssignHyb(OBMol &mol)$/;"	f	class:OpenBabel::OBAtomTyper
AssignImplicitValence	typer.cpp	/^  void OBAtomTyper::AssignImplicitValence(OBMol &mol, bool CanBeLessThanActual)$/;"	f	class:OpenBabel::OBAtomTyper
AssignPartialCharges	molchrg.cpp	/^  bool OBGastChrg::AssignPartialCharges(OBMol &mol)$/;"	f	class:OpenBabel::OBGastChrg
AssignResidue	chains.cpp	/^  void OBChainsParser::AssignResidue(OBMol &mol, int r, int c, int i)$/;"	f	class:OpenBabel::OBChainsParser
AssignSeedPartialCharge	phmodel.cpp	/^  void OBPhModel::AssignSeedPartialCharge(OBMol &mol)$/;"	f	class:OpenBabel::OBPhModel
AssignSpinMultiplicity	mol.cpp	/^  bool OBMol::AssignSpinMultiplicity(bool NoImplicitH)$/;"	f	class:OpenBabel::OBMol
AssignStruct	chains.cpp	/^  } AssignStruct;$/;"	t	namespace:OpenBabel	typeref:struct:OpenBabel::__anon6	file:
AssignTorVals	rotor.cpp	/^  bool OBRotorList::AssignTorVals(OBMol &mol)$/;"	f	class:OpenBabel::OBRotorList
AssignTotalChargeToAtoms	mol.cpp	/^  bool OBMol::AssignTotalChargeToAtoms(int charge)$/;"	f	class:OpenBabel::OBMol
AssignTypes	typer.cpp	/^  void OBAtomTyper::AssignTypes(OBMol &mol)$/;"	f	class:OpenBabel::OBAtomTyper
AssignTypes	typer.cpp	/^  void OBRingTyper::AssignTypes(OBMol &mol)$/;"	f	class:OpenBabel::OBRingTyper
Assigned	tautomer.cpp	/^      Assigned,$/;"	e	enum:OpenBabel::TautomerImpl::Type	file:
AssignmentPropagation	tautomer.cpp	/^    void AssignmentPropagation(OBMol *mol, std::vector<Type> &atomTypes, std::vector<Type> &bondTypes, const std::vector<OBAtom*> &canonAtoms,$/;"	f	struct:OpenBabel::TautomerImpl
AtomIndex	chains.cpp	/^  static int  AtomIndex;$/;"	m	namespace:OpenBabel	file:
AtomNumber	tautomer.cpp	/^    enum AtomNumber {$/;"	g	struct:OpenBabel::TautomerImpl	file:
AverageBondAngle	atom.cpp	/^  double	  OBAtom::AverageBondAngle()$/;"	f	class:OpenBabel::OBAtom
BC_ASSIGN	chains.cpp	127;"	d	file:
BC_COUNT	chains.cpp	128;"	d	file:
BC_ELEM	chains.cpp	129;"	d	file:
BC_EVAL	chains.cpp	130;"	d	file:
BC_IDENT	chains.cpp	131;"	d	file:
BC_LOCAL	chains.cpp	132;"	d	file:
BE_ANDHI	parsmart.cpp	133;"	d	file:
BE_ANDLO	parsmart.cpp	134;"	d	file:
BE_ANY	parsmart.cpp	137;"	d	file:
BE_AROM	parsmart.cpp	143;"	d	file:
BE_DEFAULT	parsmart.cpp	138;"	d	file:
BE_DOUBLE	parsmart.cpp	140;"	d	file:
BE_DOWN	parsmart.cpp	146;"	d	file:
BE_DOWNUNSPEC	parsmart.cpp	148;"	d	file:
BE_NOT	parsmart.cpp	136;"	d	file:
BE_OR	parsmart.cpp	135;"	d	file:
BE_QUAD	parsmart.cpp	142;"	d	file:
BE_RING	parsmart.cpp	144;"	d	file:
BE_SINGLE	parsmart.cpp	139;"	d	file:
BE_TRIPLE	parsmart.cpp	141;"	d	file:
BE_UP	parsmart.cpp	145;"	d	file:
BE_UPUNSPEC	parsmart.cpp	147;"	d	file:
BF_AROMATIC	chains.cpp	137;"	d	file:
BF_DOUBLE	chains.cpp	135;"	d	file:
BF_SINGLE	chains.cpp	134;"	d	file:
BF_TRIPLE	chains.cpp	136;"	d	file:
BONDPOOL	parsmart.cpp	94;"	d	file:
BOSum	atom.cpp	/^  unsigned int OBAtom::BOSum() const$/;"	f	class:OpenBabel::OBAtom
BUFF_SIZE	dlhandler_unix.cpp	46;"	d	file:
BUFF_SIZE	dlhandler_win32.cpp	36;"	d	file:
BUFF_SIZE	obconversion.cpp	61;"	d	file:
Backtrack	isomorphism.cpp	/^      void Backtrack(State &state)$/;"	f	class:OpenBabel::VF2Mapper
Backtrack	tautomer.cpp	/^    void Backtrack(std::vector<Type> &atomTypes, std::vector<Type> &bondTypes, std::vector<Level> &levels, int &numHydrogens)$/;"	f	struct:OpenBabel::TautomerImpl
BadOptimization	pointgroup.cpp	/^    int                    BadOptimization       ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
BaseFindType	plugin.cpp	/^OBPlugin* OBPlugin::BaseFindType(PluginMapType& Map, const char* ID)$/;"	f	class:OpenBabel::OBPlugin
BatchFileName	obconversion.cpp	/^  string OBConversion::BatchFileName(string& BaseName, string& InFile)$/;"	f	class:OpenBabel::OBConversion
BeginAtom	mol.cpp	/^  OBAtom *OBMol::BeginAtom(OBAtomIterator &i)$/;"	f	class:OpenBabel::OBMol
BeginAtom	residue.cpp	/^  OBAtom *OBResidue::BeginAtom(vector<OBAtom*>::iterator &i)$/;"	f	class:OpenBabel::OBResidue
BeginBond	atom.cpp	/^  OBBond *OBAtom::BeginBond(OBBondIterator &i)$/;"	f	class:OpenBabel::OBAtom
BeginBond	mol.cpp	/^  OBBond *OBMol::BeginBond(OBBondIterator &i)$/;"	f	class:OpenBabel::OBMol
BeginModify	mol.cpp	/^  void OBMol::BeginModify()$/;"	f	class:OpenBabel::OBMol
BeginNbrAtom	atom.cpp	/^  OBAtom *OBAtom::BeginNbrAtom(OBBondIterator &i)$/;"	f	class:OpenBabel::OBAtom
BeginRing	generic.cpp	/^  OBRing *OBRingData::BeginRing(std::vector<OBRing*>::iterator &i)$/;"	f	class:OpenBabel::OBRingData
BinOpStruct	chains.cpp	/^  } BinOpStruct;$/;"	t	namespace:OpenBabel	typeref:struct:OpenBabel::__anon5	file:
Bit05All	chains.cpp	123;"	d	file:
BitC	chains.cpp	95;"	d	file:
BitC1	chains.cpp	120;"	d	file:
BitC2All	chains.cpp	125;"	d	file:
BitC2DNA	chains.cpp	118;"	d	file:
BitC2RNA	chains.cpp	117;"	d	file:
BitC3	chains.cpp	114;"	d	file:
BitC4	chains.cpp	112;"	d	file:
BitC5	chains.cpp	111;"	d	file:
BitCA	chains.cpp	93;"	d	file:
BitCAAll	chains.cpp	102;"	d	file:
BitCAGly	chains.cpp	94;"	d	file:
BitCAll	chains.cpp	103;"	d	file:
BitCOXT	chains.cpp	97;"	d	file:
BitCTer	chains.cpp	96;"	d	file:
BitN	chains.cpp	89;"	d	file:
BitNAll	chains.cpp	101;"	d	file:
BitNPT	chains.cpp	92;"	d	file:
BitNPro	chains.cpp	91;"	d	file:
BitNTer	chains.cpp	90;"	d	file:
BitO	chains.cpp	98;"	d	file:
BitO2	chains.cpp	119;"	d	file:
BitO3	chains.cpp	115;"	d	file:
BitO3All	chains.cpp	124;"	d	file:
BitO3Ter	chains.cpp	116;"	d	file:
BitO4	chains.cpp	113;"	d	file:
BitO5	chains.cpp	109;"	d	file:
BitO5Ter	chains.cpp	110;"	d	file:
BitOAll	chains.cpp	104;"	d	file:
BitOP	chains.cpp	108;"	d	file:
BitOXT	chains.cpp	99;"	d	file:
BitP	chains.cpp	106;"	d	file:
BitPAll	chains.cpp	122;"	d	file:
BitPTer	chains.cpp	107;"	d	file:
BondIndex	chains.cpp	/^  static int  BondIndex;$/;"	m	namespace:OpenBabel	file:
BothEven	rand.cpp	52;"	d	file:
Build	builder.cpp	/^  bool OBBuilder::Build(OBMol &mol, bool stereoWarnings)$/;"	f	class:OpenBabel::OBBuilder
BuildAtomBin	parsmart.cpp	/^  static AtomExpr *BuildAtomBin( int op, AtomExpr *lft, AtomExpr *rgt )$/;"	f	namespace:OpenBabel
BuildAtomLeaf	parsmart.cpp	/^  static AtomExpr *BuildAtomLeaf( int type, int val )$/;"	f	namespace:OpenBabel
BuildAtomNot	parsmart.cpp	/^  static AtomExpr *BuildAtomNot( AtomExpr *expr )$/;"	f	namespace:OpenBabel
BuildAtomPred	parsmart.cpp	/^  static AtomExpr *BuildAtomPred( int type )$/;"	f	namespace:OpenBabel
BuildAtomRecurs	parsmart.cpp	/^  static AtomExpr *BuildAtomRecurs( Pattern *pat )$/;"	f	namespace:OpenBabel
BuildBondBin	parsmart.cpp	/^  static BondExpr *BuildBondBin( int op, BondExpr *lft, BondExpr *rgt )$/;"	f	namespace:OpenBabel
BuildBondLeaf	parsmart.cpp	/^  static BondExpr *BuildBondLeaf( int type )$/;"	f	namespace:OpenBabel
BuildBondNot	parsmart.cpp	/^  static BondExpr *BuildBondNot( BondExpr *expr )$/;"	f	namespace:OpenBabel
BuildOBRTreeVector	ring.cpp	/^  void BuildOBRTreeVector(OBAtom *atom,OBRTree *prv,vector<OBRTree*> &vt,OBBitVec &bv)$/;"	f	namespace:OpenBabel
ByteCode	chains.cpp	/^  } ByteCode;$/;"	t	namespace:OpenBabel	typeref:union:OpenBabel::_ByteCode	file:
CONNMAX	mcdlutil.cpp	40;"	d	file:
CalcBondLength	rotor.cpp	/^  double OBRotor::CalcBondLength(double *c)$/;"	f	class:OpenBabel::OBRotor
CalcCanonicalLabels	canon.cpp	/^    static void CalcCanonicalLabels(OBMol *mol, const std::vector<unsigned int> &symmetry_classes,$/;"	f	struct:OpenBabel::CanonicalLabelsImpl
CalcSignedVolume	chiral.cpp	/^  double CalcSignedVolume(OBMol &mol,OBAtom *atm, bool ReZeroZ)$/;"	f	namespace:OpenBabel
CalcTorsion	rotor.cpp	/^  double OBRotor::CalcTorsion(double *c)$/;"	f	class:OpenBabel::OBRotor
Calculate13Angle	distgeom.cpp	/^  inline double Calculate13Angle(double a, double b, double c)$/;"	f	namespace:OpenBabel
Calculate13Distance	distgeom.cpp	/^  inline double Calculate13Distance(double ab, double bc, double angle)$/;"	f	namespace:OpenBabel
Calculate14DistCis	distgeom.cpp	/^  inline double Calculate14DistCis(double ab, double bc, double cd,$/;"	f	namespace:OpenBabel
Calculate14DistTrans	distgeom.cpp	/^  inline double Calculate14DistTrans(double ab, double bc, double cd,$/;"	f	namespace:OpenBabel
Calculate15DistAnyCis	distgeom.cpp	/^  inline double Calculate15DistAnyCis(double ab, double bc, double cd, double de,$/;"	f	namespace:OpenBabel
Calculate15DistAnyTrans	distgeom.cpp	/^  inline double Calculate15DistAnyTrans(double ab, double bc, double cd, double de,$/;"	f	namespace:OpenBabel
CalculateSymmetry	graphsym.cpp	/^  int OBGraphSymPrivate::CalculateSymmetry(std::vector<unsigned int> &atom_sym_classes)$/;"	f	class:OpenBabel::OBGraphSymPrivate
CanBeSquared	obutil.cpp	/^  bool CanBeSquared(const double &a)$/;"	f	namespace:OpenBabel
Candidate	isomorphism.cpp	/^        Candidate() : queryAtom(0), queriedAtom(0) {}$/;"	f	struct:OpenBabel::VF2Mapper::Candidate
Candidate	isomorphism.cpp	/^        Candidate(OBQueryAtom *_queryAtom, OBAtom *_queriedAtom)$/;"	f	struct:OpenBabel::VF2Mapper::Candidate
Candidate	isomorphism.cpp	/^      struct Candidate {$/;"	s	class:OpenBabel::VF2Mapper	file:
CanonicalLabels	canon.cpp	/^  void CanonicalLabels(OBMol *mol, const std::vector<unsigned int> &symmetry_classes,$/;"	f	namespace:OpenBabel
CanonicalLabelsImpl	canon.cpp	/^  struct CanonicalLabelsImpl$/;"	s	namespace:OpenBabel	file:
CanonicalLabelsRecursive	canon.cpp	/^    static void CanonicalLabelsRecursive(OBAtom *current, unsigned int label, Timeout &timeout, FullCode &bestCode, State &state)$/;"	f	struct:OpenBabel::CanonicalLabelsImpl
CanonicalTautomer	tautomer.cpp	/^  void CanonicalTautomer(OBMol *mol)$/;"	f	namespace:OpenBabel
Carbon	tautomer.cpp	/^      Carbon = 6,$/;"	e	enum:OpenBabel::TautomerImpl::AtomNumber	file:
CartesianToFractional	generic.cpp	/^  vector3 OBUnitCell::CartesianToFractional(vector3 cart) const$/;"	f	class:OpenBabel::OBUnitCell
CartesianToInternal	obutil.cpp	/^  void CartesianToInternal(std::vector<OBInternalCoord*> &vic,OBMol &mol)$/;"	f	namespace:OpenBabel
Center	mol.cpp	/^  vector3 OBMol::Center(int nconf)$/;"	f	class:OpenBabel::OBMol
Center	mol.cpp	/^  void OBMol::Center()$/;"	f	class:OpenBabel::OBMol
CenterOfSomething	pointgroup.cpp	/^    double                 CenterOfSomething[ DIMENSION ];$/;"	m	class:OpenBabel::PointGroupPrivate	file:
ChainsAtomName	chains.cpp	/^  static char ChainsAtomName[ATOMMAX][4] = {$/;"	m	namespace:OpenBabel	file:
ChainsResName	chains.cpp	/^static char ChainsResName[RESIDMAX][4] = {$/;"	v	file:
CheckAromaticity	typer.cpp	/^  void OBAromaticTyper::CheckAromaticity(OBAtom *atom,int depth)$/;"	f	class:OpenBabel::OBAromaticTyper
CheckBounds	distgeom.cpp	/^  bool OBDistanceGeometry::CheckBounds()$/;"	f	class:OpenBabel::OBDistanceGeometry
CheckFP	fingerprint.cpp	/^  OBFingerprint* FptIndex::CheckFP()$/;"	f	class:OpenBabel::FptIndex
CheckForUnintendedBatch	obconversion.cpp	/^  bool OBConversion::CheckForUnintendedBatch(const string& infile, const string& outfile)$/;"	f	class:OpenBabel::OBConversion
CheckStereoConstraints	distgeom.cpp	/^  bool OBDistanceGeometry::CheckStereoConstraints()$/;"	f	class:OpenBabel::OBDistanceGeometry
ClassCount	mol.cpp	/^  static void ClassCount(vector<pair<OBAtom*,unsigned int> > &vp,unsigned int &count)$/;"	f	namespace:OpenBabel
ClassDescription	transform.cpp	/^  const char* OBMol::ClassDescription()$/;"	f	class:OpenBabel::OBMol
CleanAtomType	obutil.cpp	/^  void CleanAtomType(char *id)$/;"	f	namespace:OpenBabel
CleanupMol	chains.cpp	/^  void OBChainsParser::CleanupMol(void)$/;"	f	class:OpenBabel::OBChainsParser
Clear	atom.cpp	/^  bool OBAtom::Clear()$/;"	f	class:OpenBabel::OBAtom
Clear	base.cpp	/^  bool OBBase::Clear()$/;"	f	class:OpenBabel::OBBase
Clear	bitvec.cpp	/^  void OBBitVec::Clear()$/;"	f	class:OpenBabel::OBBitVec
Clear	forcefield.cpp	/^  void OBFFConstraints::Clear()$/;"	f	class:OpenBabel::OBFFConstraints
Clear	generic.cpp	/^  void OBAngle::Clear()$/;"	f	class:OpenBabel::OBAngle
Clear	generic.cpp	/^  void OBAngleData::Clear()$/;"	f	class:OpenBabel::OBAngleData
Clear	generic.cpp	/^  void OBChiralData::Clear()$/;"	f	class:OpenBabel::OBChiralData
Clear	generic.cpp	/^  void OBTorsion::Clear()$/;"	f	class:OpenBabel::OBTorsion
Clear	generic.cpp	/^  void OBTorsionData::Clear()$/;"	f	class:OpenBabel::OBTorsionData
Clear	mol.cpp	/^  bool OBMol::Clear()$/;"	f	class:OpenBabel::OBMol
Clear	residue.cpp	/^  bool OBResidue::Clear(void)$/;"	f	class:OpenBabel::OBResidue
Clear	rotor.cpp	/^  void OBRotorList::Clear()$/;"	f	class:OpenBabel::OBRotorList
ClearGroups	forcefield.cpp	/^  void OBForceField::ClearGroups()$/;"	f	class:OpenBabel::OBForceField
ClearResidueInformation	chains.cpp	/^  void OBChainsParser::ClearResidueInformation(OBMol &mol)$/;"	f	class:OpenBabel::OBChainsParser
ClearSymmetry	graphsym.cpp	/^  void OBGraphSym::ClearSymmetry()$/;"	f	class:OpenBabel::OBGraphSym
Clone	rotamer.cpp	/^  OBGenericData* OBRotamerList::Clone(OBBase* newparent) const$/;"	f	class:OpenBabel::OBRotamerList
CloneData	base.cpp	/^  void OBBase::CloneData(OBGenericData *d)$/;"	f	class:OpenBabel::OBBase
CloseOutFile	obconversion.cpp	/^  void OBConversion::CloseOutFile()$/;"	f	class:OpenBabel::OBConversion
Compare	descriptor.cpp	/^bool OBDescriptor::Compare(OBBase* pOb, istream& optionText, bool noEval, string* param)$/;"	f	class:OpenBabel::OBDescriptor
CompareBondPairSecond	canon.cpp	/^  inline bool CompareBondPairSecond(const std::pair<OBBond*,unsigned int> &a,const std::pair<OBBond*,unsigned int> &b)$/;"	f	namespace:OpenBabel
CompareConformerHighScore	conformersearch.cpp	/^  struct CompareConformerHighScore {$/;"	s	namespace:OpenBabel	file:
CompareConformerLowScore	conformersearch.cpp	/^  struct CompareConformerLowScore {$/;"	s	namespace:OpenBabel	file:
ComparePairFirst	graphsym.cpp	/^  inline bool ComparePairFirst(const std::pair<OBAtom*,unsigned int> &a,const std::pair<OBAtom*,unsigned int> &b)$/;"	f	namespace:OpenBabel
ComparePairSecond	graphsym.cpp	/^  inline bool ComparePairSecond(const std::pair<OBAtom*,unsigned int> &a,const std::pair<OBAtom*,unsigned int> &b)$/;"	f	namespace:OpenBabel
CompareRingSize	ring.cpp	/^  bool CompareRingSize(const OBRing *a,const OBRing *b)$/;"	f	namespace:OpenBabel
CompareRotor	mcdlutil.cpp	/^  bool CompareRotor(const pair<int, int> &a, const pair<int, int> &b)$/;"	f	namespace:OpenBabel
CompareRotor	rotor.cpp	/^  bool CompareRotor(const pair<OBBond*,int> &a,const pair<OBBond*,int> &b)$/;"	f	namespace:OpenBabel
CompareStringWithFilter	descriptor.cpp	/^bool OBDescriptor::CompareStringWithFilter(istream& optionText, string& sval, bool, bool NoCompOK)$/;"	f	class:OpenBabel::OBDescriptor
CompareUnsigned	graphsym.cpp	/^  inline bool CompareUnsigned(const unsigned int &a,const unsigned int &b)$/;"	f	namespace:OpenBabel
CompileAutomorphismQuery	isomorphism.cpp	/^  OBQuery* CompileAutomorphismQuery(OBMol *mol, const OBBitVec &mask, const std::vector<unsigned int> &symClasses)$/;"	f	namespace:OpenBabel
CompileMoleculeQuery	query.cpp	/^  OBQuery* CompileMoleculeQuery(OBMol *mol, const OBBitVec &mask)$/;"	f	namespace:OpenBabel
CompileSmilesQuery	query.cpp	/^  OBQuery* CompileSmilesQuery(const std::string &smiles, const OBBitVec &mask)$/;"	f	namespace:OpenBabel
CompleteCode	canon.cpp	/^    static void CompleteCode(OBMol *mol, FullCode &fullcode, State &state)$/;"	f	struct:OpenBabel::CanonicalLabelsImpl
ConformerScore	conformersearch.cpp	/^    ConformerScore(const RotorKey &key, double _score) : rotorKey(key), score(_score) {}$/;"	f	struct:OpenBabel::ConformerScore
ConformerScore	conformersearch.cpp	/^  struct ConformerScore {$/;"	s	namespace:OpenBabel	file:
ConjugateGradients	forcefield.cpp	/^  void OBForceField::ConjugateGradients(int steps, double econv, int method)$/;"	f	class:OpenBabel::OBForceField
ConjugateGradientsInitialize	forcefield.cpp	/^  void OBForceField::ConjugateGradientsInitialize(int steps, double econv,$/;"	f	class:OpenBabel::OBForceField
ConjugateGradientsTakeNSteps	forcefield.cpp	/^  bool OBForceField::ConjugateGradientsTakeNSteps(int n)$/;"	f	class:OpenBabel::OBForceField
Connect	builder.cpp	/^  bool OBBuilder::Connect(OBMol &mol, int idxA, int idxB, int bondOrder)$/;"	f	class:OpenBabel::OBBuilder
Connect	builder.cpp	/^  bool OBBuilder::Connect(OBMol &mol, int idxA, int idxB,$/;"	f	class:OpenBabel::OBBuilder
ConnectFrags	builder.cpp	/^  void OBBuilder::ConnectFrags(OBMol &mol, OBMol &workMol, vector<int> match, vector<vector3> coords,$/;"	f	class:OpenBabel::OBBuilder
ConnectTheDots	mol.cpp	/^  void OBMol::ConnectTheDots(void)$/;"	f	class:OpenBabel::OBMol
ConstrainBackbone	chains.cpp	/^  void OBChainsParser::ConstrainBackbone(OBMol &mol, Template *templ, int tmax)$/;"	f	class:OpenBabel::OBChainsParser
ContigFragList	mol.cpp	/^  void OBMol::ContigFragList(std::vector<std::vector<int> >&cfl)$/;"	f	class:OpenBabel::OBMol
Convert	obconversion.cpp	/^  int OBConversion::Convert()$/;"	f	class:OpenBabel::OBConversion
Convert	obconversion.cpp	/^  int OBConversion::Convert(istream* is, ostream* os)$/;"	f	class:OpenBabel::OBConversion
ConvertDativeBonds	mol.cpp	/^  bool OBMol::ConvertDativeBonds()$/;"	f	class:OpenBabel::OBMol
ConvertZeroBonds	mol.cpp	/^  bool OBMol::ConvertZeroBonds()$/;"	f	class:OpenBabel::OBMol
CoordsToIndex	grid.cpp	/^  int OBFloatGrid::CoordsToIndex(double x, double y, double z)$/;"	f	class:OpenBabel::OBFloatGrid
CoordsToIndex	grid.cpp	/^  void OBFloatGrid::CoordsToIndex(int *idx,double *c)$/;"	f	class:OpenBabel::OBFloatGrid
CopyAtomExpr	parsmart.cpp	/^  static AtomExpr *CopyAtomExpr( AtomExpr *expr )$/;"	f	namespace:OpenBabel
CopyBondExpr	parsmart.cpp	/^  static BondExpr *CopyBondExpr( BondExpr *expr )$/;"	f	namespace:OpenBabel
CopyConformer	mol.cpp	/^  void OBMol::CopyConformer(double *c,int idx)$/;"	f	class:OpenBabel::OBMol
CopyOptions	obconversion.cpp	/^  void OBConversion::CopyOptions(OBConversion* pSourceConv, Option_type typ)$/;"	f	class:OpenBabel::OBConversion
CopyPattern	parsmart.cpp	/^  static Pattern *CopyPattern( Pattern *pat )$/;"	f	namespace:OpenBabel
CorrectAromaticNitrogens	typer.cpp	/^  void OBAtomTyper::CorrectAromaticNitrogens(OBMol &mol)$/;"	f	class:OpenBabel::OBAtomTyper
CorrectBadResonanceForm	mol.cpp	/^  void CorrectBadResonanceForm(OBMol &mol)$/;"	f	namespace:OpenBabel
CorrectChirality	chiral.cpp	/^  bool CorrectChirality(OBMol &, OBAtom *atm, atomreftype i, atomreftype o)$/;"	f	namespace:OpenBabel
CorrectForPH	mol.cpp	/^  bool OBMol::CorrectForPH(double pH)$/;"	f	class:OpenBabel::OBMol
CorrectForPH	phmodel.cpp	/^  void OBPhModel::CorrectForPH(OBMol &mol, double pH)$/;"	f	class:OpenBabel::OBPhModel
CorrectStereoAtoms	builder.cpp	/^  bool OBBuilder::CorrectStereoAtoms(OBMol &mol, bool warn)$/;"	f	class:OpenBabel::OBBuilder
CorrectStereoBonds	builder.cpp	/^  bool OBBuilder::CorrectStereoBonds(OBMol &mol)$/;"	f	class:OpenBabel::OBBuilder
CorrectStereoConstraints	distgeom.cpp	/^  void OBDistanceGeometry::CorrectStereoConstraints(double lambda)$/;"	f	class:OpenBabel::OBDistanceGeometry
CorrectVelocities	forcefield.cpp	/^  void OBForceField::CorrectVelocities()$/;"	f	class:OpenBabel::OBForceField
CorrectedBondRad	data.cpp	/^  double OBElementTable::CorrectedBondRad(int atomicnum, int hyb)$/;"	f	class:OpenBabel::OBElementTable
CorrectedVdwRad	data.cpp	/^  double OBElementTable::CorrectedVdwRad(int atomicnum, int hyb)$/;"	f	class:OpenBabel::OBElementTable
CountAndRenumberClasses	graphsym.cpp	/^  void OBGraphSymPrivate::CountAndRenumberClasses(std::vector<std::pair<OBAtom*,unsigned int> > &vp,$/;"	f	class:OpenBabel::OBGraphSymPrivate
CountBits	bitvec.cpp	/^  unsigned OBBitVec::CountBits() const$/;"	f	class:OpenBabel::OBBitVec
CountBondsOfOrder	atom.cpp	/^  int OBAtom::CountBondsOfOrder(unsigned int order)$/;"	f	class:OpenBabel::OBAtom
CountFreeOxygens	atom.cpp	/^  unsigned int OBAtom::CountFreeOxygens() const$/;"	f	class:OpenBabel::OBAtom
CountFreeSulfurs	atom.cpp	/^  unsigned int OBAtom::CountFreeSulfurs() const$/;"	f	class:OpenBabel::OBAtom
CountRingBonds	atom.cpp	/^  unsigned int OBAtom::CountRingBonds() const$/;"	f	class:OpenBabel::OBAtom
CreateAtom	mol.cpp	/^  OBAtom *OBMol::CreateAtom(void)$/;"	f	class:OpenBabel::OBMol
CreateAtom	parsmart.cpp	/^  static int CreateAtom( Pattern *pat, AtomExpr *expr, int part,int vb)$/;"	f	namespace:OpenBabel
CreateBond	mol.cpp	/^  OBBond *OBMol::CreateBond(void)$/;"	f	class:OpenBabel::OBMol
CreateBond	parsmart.cpp	/^  static int CreateBond( Pattern *pat, BondExpr *expr, int src, int dst )$/;"	f	namespace:OpenBabel
CreateConformerList	rotamer.cpp	/^  vector<double*> OBRotamerList::CreateConformerList(OBMol& mol)$/;"	f	class:OpenBabel::OBRotamerList
CreateNewClassVector	graphsym.cpp	/^  void OBGraphSymPrivate::CreateNewClassVector(OBMol *mol, std::vector<std::pair<OBAtom*,unsigned int> > &vp1,$/;"	f	class:OpenBabel::OBGraphSymPrivate
CreateNewClassVector	graphsym.cpp	/^  void OBGraphSymPrivate::CreateNewClassVector(std::vector<std::pair<OBAtom*,unsigned int> > &vp1,$/;"	f	class:OpenBabel::OBGraphSymPrivate
CreateNewClassVector	mol.cpp	/^  static void CreateNewClassVector(vector<pair<OBAtom*,unsigned int> > &vp1,vector<pair<OBAtom*,unsigned int> > &vp2)$/;"	f	namespace:OpenBabel
CreateResidue	mol.cpp	/^  OBResidue *OBMol::CreateResidue(void)$/;"	f	class:OpenBabel::OBMol
CubeRoot	obutil.cpp	/^  double CubeRoot(double X)$/;"	f	namespace:OpenBabel
CurrentDepth	obiter.cpp	/^  int OBMolAtomBFSIter::CurrentDepth() const$/;"	f	class:OpenBabel::OBMolAtomBFSIter
CurrentDepth	obiter.cpp	/^  int OBMolBondBFSIter::CurrentDepth() const$/;"	f	class:OpenBabel::OBMolBondBFSIter
DATADIR	obconversion.cpp	29;"	d	file:
DEBUG	canon.cpp	37;"	d	file:
DEBUG	isomorphism.cpp	7;"	d	file:
DEBUG	kekulize.cpp	21;"	d	file:
DEFAULTBONDLENGTH	mcdlutil.cpp	172;"	d	file:
DEUTERIUM_ATOM	mcdlutil.cpp	147;"	d	file:
DIGITAL_UNIX_COMPATIBLE	snprintf.c	309;"	d	file:
DIMENSION	pointgroup.cpp	36;"	d	file:
DIST12_TOL	distgeom.cpp	34;"	d	file:
DIST13_TOL	distgeom.cpp	35;"	d	file:
DIST14_TOL	distgeom.cpp	36;"	d	file:
DIST15_TOL	distgeom.cpp	37;"	d	file:
DOUBLE	kekulize.cpp	45;"	d	file:
DOUBLE_ALLOWED	kekulize.cpp	49;"	d	file:
DOUBLE_ASSIGNED	kekulize.cpp	48;"	d	file:
DOUBLE_PROHIBITED	kekulize.cpp	50;"	d	file:
DefaultStrategy	zipstream.h	/^    DefaultStrategy = 0$/;"	e	enum:zlib_stream::EStrategy
DeferMolOutput	obmolecformat.cpp	/^  bool OBMoleculeFormat::DeferMolOutput(OBMol* pmol, OBConversion* pConv, OBFormat* pF )$/;"	f	class:OpenBabel::OBMoleculeFormat
DefineMonomer	chains.cpp	/^  void OBChainsParser::DefineMonomer(void **tree, int resid, const char *smiles)$/;"	f	class:OpenBabel::OBChainsParser
DeleteAtom	mol.cpp	/^  bool OBMol::DeleteAtom(OBAtom *atom, bool destroyAtom)$/;"	f	class:OpenBabel::OBMol
DeleteBond	atom.cpp	/^  bool OBAtom::DeleteBond(OBBond *bond)$/;"	f	class:OpenBabel::OBAtom
DeleteBond	mol.cpp	/^  bool OBMol::DeleteBond(OBBond *bond, bool destroyBond)$/;"	f	class:OpenBabel::OBMol
DeleteByteCode	chains.cpp	/^  static void DeleteByteCode(ByteCode *node)$/;"	f	namespace:OpenBabel
DeleteConformer	mol.cpp	/^  void OBMol::DeleteConformer(int idx)$/;"	f	class:OpenBabel::OBMol
DeleteConstraint	forcefield.cpp	/^  void OBFFConstraints::DeleteConstraint(int index)$/;"	f	class:OpenBabel::OBFFConstraints
DeleteData	base.cpp	/^  bool OBBase::DeleteData(const string& s)$/;"	f	class:OpenBabel::OBBase
DeleteData	base.cpp	/^  void OBBase::DeleteData(OBGenericData *gd)$/;"	f	class:OpenBabel::OBBase
DeleteData	base.cpp	/^  void OBBase::DeleteData(unsigned int dt)$/;"	f	class:OpenBabel::OBBase
DeleteData	base.cpp	/^  void OBBase::DeleteData(vector<OBGenericData*> &vg)$/;"	f	class:OpenBabel::OBBase
DeleteDeferredMols	obmolecformat.cpp	/^  bool OBMoleculeFormat::DeleteDeferredMols()$/;"	f	class:OpenBabel::OBMoleculeFormat
DeleteExpandedAtoms	alias.cpp	/^void AliasData::DeleteExpandedAtoms(OBMol& mol)$/;"	f	class:OpenBabel::AliasData
DeleteHydrogen	mol.cpp	/^  bool OBMol::DeleteHydrogen(OBAtom *atom)$/;"	f	class:OpenBabel::OBMol
DeleteHydrogens	mol.cpp	/^  bool OBMol::DeleteHydrogens()$/;"	f	class:OpenBabel::OBMol
DeleteHydrogens	mol.cpp	/^  bool OBMol::DeleteHydrogens(OBAtom *atom)$/;"	f	class:OpenBabel::OBMol
DeleteNonPolarHydrogens	mol.cpp	/^  bool OBMol::DeleteNonPolarHydrogens()$/;"	f	class:OpenBabel::OBMol
DeletePolarHydrogens	mol.cpp	/^  bool OBMol::DeletePolarHydrogens()$/;"	f	class:OpenBabel::OBMol
DeleteProperties	descriptor.cpp	/^void OBDescriptor::DeleteProperties(OBBase* pOb, const string& DescrList)$/;"	f	class:OpenBabel::OBDescriptor
DeleteResidue	mol.cpp	/^  bool OBMol::DeleteResidue(OBResidue *residue, bool destroyResidue)$/;"	f	class:OpenBabel::OBMol
DeleteStereoOnAtom	mol.cpp	/^  const void DeleteStereoOnAtom(OBMol& mol, OBStereo::Ref atomId)$/;"	f	namespace:OpenBabel
Description	alias.cpp	/^  const char* Description(){ return "Generate aliases as an alternative representation."; }$/;"	f	class:OpenBabel::OpGenAlias
Description	obconversion.cpp	/^  const char* OBConversion::Description()$/;"	f	class:OpenBabel::OBConversion
DestroyAtom	mol.cpp	/^  void OBMol::DestroyAtom(OBAtom *atom)$/;"	f	class:OpenBabel::OBMol
DestroyBond	mol.cpp	/^  void OBMol::DestroyBond(OBBond *bond)$/;"	f	class:OpenBabel::OBMol
DestroyResidue	mol.cpp	/^  void OBMol::DestroyResidue(OBResidue *residue)$/;"	f	class:OpenBabel::OBMol
DetectExplosion	forcefield.cpp	/^  bool OBForceField::DetectExplosion()$/;"	f	class:OpenBabel::OBForceField
DetermineConnectedChains	chains.cpp	/^  bool OBChainsParser::DetermineConnectedChains(OBMol &mol)$/;"	f	class:OpenBabel::OBChainsParser
DetermineFRJ	ring.cpp	/^  static int DetermineFRJ(OBMol &mol)$/;"	f	namespace:OpenBabel
DetermineFactors	rand.cpp	/^  static int DetermineFactors( unsigned int x, unsigned int *factors )$/;"	f	namespace:OpenBabel
DetermineHetAtoms	chains.cpp	/^  bool OBChainsParser::DetermineHetAtoms(OBMol &mol)$/;"	f	class:OpenBabel::OBChainsParser
DetermineHydrogens	chains.cpp	/^  bool OBChainsParser::DetermineHydrogens(OBMol &mol)$/;"	f	class:OpenBabel::OBChainsParser
DetermineIncrement	rand.cpp	/^  static unsigned int DetermineIncrement( unsigned int m )$/;"	f	namespace:OpenBabel
DetermineNucleicBackbone	chains.cpp	/^  bool OBChainsParser::DetermineNucleicBackbone(OBMol &mol)$/;"	f	class:OpenBabel::OBChainsParser
DetermineNucleicSidechains	chains.cpp	/^  bool OBChainsParser::DetermineNucleicSidechains(OBMol &mol)$/;"	f	class:OpenBabel::OBChainsParser
DeterminePeptideBackbone	chains.cpp	/^  bool OBChainsParser::DeterminePeptideBackbone(OBMol &mol)$/;"	f	class:OpenBabel::OBChainsParser
DeterminePeptideSidechains	chains.cpp	/^  bool OBChainsParser::DeterminePeptideSidechains(OBMol &mol)$/;"	f	class:OpenBabel::OBChainsParser
DeterminePotency	rand.cpp	/^  static int DeterminePotency( unsigned int m, unsigned int a )$/;"	f	namespace:OpenBabel
DetermineSequence	rand.cpp	/^  int DetermineSequence( unsigned int m, unsigned int *pm,$/;"	f	namespace:OpenBabel
Display	descriptor.cpp	/^bool OBDescriptor::Display(std::string&txt, const char* param, const char* ID)$/;"	f	class:OpenBabel::OBDescriptor
Display	format.cpp	/^bool OBFormat::Display(std::string& txt, const char* param, const char* ID)$/;"	f	class:OpenBabel::OBFormat
Display	plugin.cpp	/^bool OBPlugin::Display(string& txt, const char* param, const char* ID)$/;"	f	class:OpenBabel::OBPlugin
DistanceFromCenter	pointgroup.cpp	/^    double *               DistanceFromCenter    ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
DistanceGeometry	forcefield.cpp	/^  void OBForceField::DistanceGeometry()$/;"	f	class:OpenBabel::OBForceField
DistanceGeometryPrivate	distgeom.cpp	/^    DistanceGeometryPrivate(const unsigned int N)$/;"	f	class:OpenBabel::DistanceGeometryPrivate
DistanceGeometryPrivate	distgeom.cpp	/^  class DistanceGeometryPrivate {$/;"	c	namespace:OpenBabel	file:
DiverseConfGen	confsearch.cpp	/^int OBForceField::DiverseConfGen(double rmsd, unsigned int nconfs, double energy_gap, bool verbose)$/;"	f	class:OpenBabel::OBForceField
Do	alias.cpp	/^bool OpGenAlias::Do(OBBase* pOb, const char* OptionText, OpMap* pmap, OBConversion*)$/;"	f	class:OpenBabel::OpGenAlias
DoOutputOptions	obmolecformat.cpp	/^  bool OBMoleculeFormat::DoOutputOptions(OBBase* pOb, OBConversion* pConv)$/;"	f	class:OpenBabel::OBMoleculeFormat
DoTransformations	transform.cpp	/^  OBBase* OBMol::DoTransformations(const std::map<std::string, std::string>* pOptions, OBConversion* pConv)$/;"	f	class:OpenBabel::OBMol
Donor	tautomer.cpp	/^      Donor,$/;"	e	enum:OpenBabel::TautomerImpl::Type	file:
Double	tautomer.cpp	/^      Double$/;"	e	enum:OpenBabel::TautomerImpl::Type	file:
DoubleAdd	rand.cpp	/^  void DoubleAdd( DoubleType *x, unsigned int y )$/;"	f	namespace:OpenBabel
DoubleModulus	rand.cpp	/^  unsigned int DoubleModulus( DoubleType *n,  unsigned int d )$/;"	f	namespace:OpenBabel
DoubleMultiply	rand.cpp	/^  void DoubleMultiply( unsigned int x, unsigned int y, DoubleType *z )$/;"	f	namespace:OpenBabel
Duplicate	atom.cpp	/^  void OBAtom::Duplicate(OBAtom *src)$/;"	f	class:OpenBabel::OBAtom
EPSILON	generic.cpp	393;"	d	file:
EPSILON	generic.cpp	400;"	d	file:
EStrategy	zipstream.h	/^enum EStrategy$/;"	g	namespace:zlib_stream
EXACTNUMBER_MASK	mcdlutil.cpp	/^    static int const EXACTNUMBER_MASK=AROMATIC_MASK << 1;$/;"	m	class:OpenBabel::TEditedMolecule	file:
ElemDesc	residue.cpp	/^  char ElemDesc[MAXELEM][4] = {$/;"	m	namespace:OpenBabel	file:
ElemNo	residue.cpp	/^  unsigned int ElemNo = MINELEM;$/;"	m	namespace:OpenBabel	file:
EnableStaticPlugins	plugin.cpp	/^std::vector<std::string> EnableStaticPlugins()$/;"	f	namespace:OpenBabel
EndModify	mol.cpp	/^  void OBMol::EndModify(bool nukePerceivedData)$/;"	f	class:OpenBabel::OBMol
Enumerate	tautomer.cpp	/^    void Enumerate(OBMol *mol, TautomerFunctor &functor, bool canonical)$/;"	f	struct:OpenBabel::TautomerImpl
EnumerateRecursive	tautomer.cpp	/^    void EnumerateRecursive(OBMol *mol, std::vector<Type> &atomTypes, std::vector<Type> &bondTypes, const std::vector<OBAtom*> &canonAtoms,$/;"	f	struct:OpenBabel::TautomerImpl
EnumerateTautomers	tautomer.cpp	/^  void EnumerateTautomers(OBMol *mol, TautomerFunctor &functor)$/;"	f	namespace:OpenBabel
EquivalentBondExpr	parsmart.cpp	/^  static bool EquivalentBondExpr( BondExpr *expr1, BondExpr *expr2 )$/;"	f	namespace:OpenBabel
EvalAtomExpr	parsmart.cpp	/^  bool OBSmartsMatcher::EvalAtomExpr(AtomExpr *expr,OBAtom *atom)$/;"	f	class:OpenBabel::OBSmartsMatcher
EvalBondExpr	parsmart.cpp	/^  bool OBSmartsMatcher::EvalBondExpr(BondExpr *expr,OBBond *bond)$/;"	f	class:OpenBabel::OBSmartsMatcher
ExcludeSmallRing	typer.cpp	/^  void OBAromaticTyper::ExcludeSmallRing(OBMol &mol)$/;"	f	class:OpenBabel::OBAromaticTyper
Expand	alias.cpp	/^  bool AliasData::Expand(OBMol& mol, const unsigned int atomindex)$/;"	f	class:OpenBabel::AliasData
ExpandConformerList	rotamer.cpp	/^  void OBRotamerList::ExpandConformerList(OBMol &mol,vector<double*> &clist)$/;"	f	class:OpenBabel::OBRotamerList
ExpandKekule	mol.cpp	/^  bool ExpandKekule(OBMol &mol, vector<OBAtom*> &va,$/;"	f	namespace:OpenBabel
ExplicitHydrogenCount	atom.cpp	/^  unsigned int OBAtom::ExplicitHydrogenCount(bool ExcludeIsotopes) const$/;"	f	class:OpenBabel::OBAtom
ExtendInvariants	graphsym.cpp	/^  int OBGraphSymPrivate::ExtendInvariants(std::vector<std::pair<OBAtom*, unsigned int> > &symmetry_classes)$/;"	f	class:OpenBabel::OBGraphSymPrivate
False	rand.cpp	46;"	d	file:
FastRotorSearch	forcefield.cpp	/^  int OBForceField::FastRotorSearch(bool permute)$/;"	f	class:OpenBabel::OBForceField
FastSearchIndexer	fingerprint.cpp	/^  FastSearchIndexer::FastSearchIndexer(FptIndex* pindex, std::ostream* os, int nmols)$/;"	f	class:OpenBabel::FastSearchIndexer
FastSearchIndexer	fingerprint.cpp	/^  FastSearchIndexer::FastSearchIndexer(string& datafilename, ostream* os,$/;"	f	class:OpenBabel::FastSearchIndexer
FastSingleMatch	parsmart.cpp	/^  void OBSmartsMatcher::FastSingleMatch(OBMol &mol, const Pattern *pat,$/;"	f	class:OpenBabel::OBSmartsMatcher
FatalAllocationError	parsmart.cpp	/^  static void FatalAllocationError( const char *ptr )$/;"	f	namespace:OpenBabel
FatalMemoryError	chains.cpp	/^  static void FatalMemoryError(void)$/;"	f	namespace:OpenBabel
FillAngleArray	generic.cpp	/^  bool OBAngleData::FillAngleArray(std::vector<std::vector<unsigned int> > &angles)$/;"	f	class:OpenBabel::OBAngleData
FillAngleArray	generic.cpp	/^  unsigned int OBAngleData::FillAngleArray(int **angles, unsigned int &size)$/;"	f	class:OpenBabel::OBAngleData
FillChargeVectors	chargemodel.cpp	/^  void OBChargeModel::FillChargeVectors(OBMol &mol)$/;"	f	class:OpenBabel::OBChargeModel
FillTorsionArray	generic.cpp	/^  bool OBTorsionData::FillTorsionArray(std::vector<std::vector<unsigned int> > &torsions)$/;"	f	class:OpenBabel::OBTorsionData
FillUnitCell	generic.cpp	/^  void OBUnitCell::FillUnitCell(OBMol *mol)$/;"	f	class:OpenBabel::OBUnitCell
FilterCompare	descriptor.cpp	/^bool OBDescriptor::FilterCompare(OBBase* pOb, std::istream& optionText, bool noEval)$/;"	f	class:OpenBabel::OBDescriptor
Find	fingerprint.cpp	/^  bool FastSearch::Find(OBBase* pOb, vector<unsigned int>& SeekPositions,$/;"	f	class:OpenBabel::FastSearch
FindAngles	mol.cpp	/^  void OBMol::FindAngles()$/;"	f	class:OpenBabel::OBMol
FindAutomorphisms	isomorphism.cpp	/^  bool FindAutomorphisms(OBMol *mol, Automorphisms &maps, const OBBitVec &mask, std::size_t maxMemory)$/;"	f	namespace:OpenBabel
FindAutomorphisms	isomorphism.cpp	/^  bool FindAutomorphisms(OBMol *mol, Automorphisms &maps, const std::vector<unsigned int> &symClasses, const OBBitVec &mask, std::size_t maxMemory)$/;"	f	namespace:OpenBabel
FindAutomorphisms	isomorphism.cpp	/^  void FindAutomorphisms(OBIsomorphismMapper::Functor &functor, OBMol *mol,$/;"	f	namespace:OpenBabel
FindChildren	mol.cpp	/^  void OBMol::FindChildren(vector<OBAtom*> &children,OBAtom *bgn,OBAtom *end)$/;"	f	class:OpenBabel::OBMol
FindChildren	mol.cpp	/^  void OBMol::FindChildren(vector<int> &children,int first,int second)$/;"	f	class:OpenBabel::OBMol
FindFormat	obconversion.cpp	/^  OBFormat* OBConversion::FindFormat(const char* ID)$/;"	f	class:OpenBabel::OBConversion
FindFormat	obconversion.cpp	/^  OBFormat* OBConversion::FindFormat(const std::string ID)$/;"	f	class:OpenBabel::OBConversion
FindLSSR	ring.cpp	/^  void OBMol::FindLSSR()$/;"	f	class:OpenBabel::OBMol
FindLargestFragment	mol.cpp	/^  void OBMol::FindLargestFragment(OBBitVec &lf)$/;"	f	class:OpenBabel::OBMol
FindMatch	fingerprint.cpp	/^ bool FastSearch::FindMatch(OBBase* pOb, vector<unsigned int>& SeekPositions,$/;"	f	class:OpenBabel::FastSearch
FindOrbits	canon.cpp	/^    static void FindOrbits(Orbits &orbits, OBMol *mol, const std::vector<unsigned int> &labels1,$/;"	f	struct:OpenBabel::CanonicalLabelsImpl
FindRingAtoms	graphsym.cpp	/^  void OBGraphSymPrivate::FindRingAtoms(OBBitVec &ring_atoms)$/;"	f	class:OpenBabel::OBGraphSymPrivate
FindRingAtomsAndBonds	ring.cpp	/^  void OBMol::FindRingAtomsAndBonds()$/;"	f	class:OpenBabel::OBMol
FindRingAtomsAndBonds2	ring.cpp	/^  static unsigned int FindRingAtomsAndBonds2(OBMol &mol)$/;"	f	namespace:OpenBabel
FindRings	ring.cpp	/^  static int FindRings(OBAtom *atom, int *avisit, unsigned char *bvisit,$/;"	f	namespace:OpenBabel
FindRotors	rotor.cpp	/^  bool OBRotorList::FindRotors(OBMol &mol, bool sampleRingBonds)$/;"	f	class:OpenBabel::OBRotorList
FindSSSR	ring.cpp	/^  void OBMol::FindSSSR()$/;"	f	class:OpenBabel::OBMol
FindSimilar	fingerprint.cpp	/^  bool FastSearch::FindSimilar(OBBase* pOb, multimap<double, unsigned int>& SeekposMap,$/;"	f	class:OpenBabel::FastSearch
FindSmallestRing	bond.cpp	/^  OBRing* OBBond::FindSmallestRing() const$/;"	f	class:OpenBabel::OBBond
FindTorsions	mol.cpp	/^  void OBMol::FindTorsions()$/;"	f	class:OpenBabel::OBMol
FirstLine	plugin.cpp	/^string OBPlugin::FirstLine(const char* txt)$/;"	f	class:OpenBabel::OBPlugin
FixRingStereo	builder.cpp	/^  bool OBBuilder::FixRingStereo(std::vector<std::pair<OBStereo::Ref, bool> > atomIds, OBMol &mol,$/;"	f	class:OpenBabel::OBBuilder
FlipSpiro	builder.cpp	/^  void OBBuilder::FlipSpiro(OBMol &mol, int idx)$/;"	f	class:OpenBabel::OBBuilder
Fold	bitvec.cpp	/^  void OBBitVec::Fold(unsigned new_bit_size)$/;"	f	class:OpenBabel::OBBitVec
Fold	fingerprint.cpp	/^  void OBFingerprint::Fold(vector<unsigned int>& vec, unsigned int nbits)$/;"	f	class:OpenBabel::OBFingerprint
FormatFromExt	obconversion.cpp	/^  OBFormat* OBConversion::FormatFromExt(const char* filename)$/;"	f	class:OpenBabel::OBConversion
FormatFromExt	obconversion.cpp	/^  OBFormat* OBConversion::FormatFromExt(const char* filename, bool& isgzip)$/;"	f	class:OpenBabel::OBConversion
FormatFromExt	obconversion.cpp	/^  OBFormat* OBConversion::FormatFromExt(const std::string filename)$/;"	f	class:OpenBabel::OBConversion
FormatFromExt	obconversion.cpp	/^  OBFormat* OBConversion::FormatFromExt(const std::string filename, bool& isgzip)$/;"	f	class:OpenBabel::OBConversion
FormatFromMIME	format.cpp	/^OBFormat* OBFormat::FormatFromMIME(const char* MIME)$/;"	f	class:OpenBabel::OBFormat
FormatFromMIME	obconversion.cpp	/^  OBFormat* OBConversion::FormatFromMIME(const char* MIME)$/;"	f	class:OpenBabel::OBConversion
Formatpos	obconversion.cpp	/^  typedef OBPlugin::PluginIterator Formatpos;$/;"	t	namespace:OpenBabel	file:
FourThirdsPI	obutil.cpp	773;"	d	file:
FractionalToCartesian	generic.cpp	/^  vector3 OBUnitCell::FractionalToCartesian(vector3 frac) const$/;"	f	class:OpenBabel::OBUnitCell
FreeAtomExpr	parsmart.cpp	/^  static void FreeAtomExpr( AtomExpr *expr )$/;"	f	namespace:OpenBabel
FreeBondExpr	parsmart.cpp	/^  static void FreeBondExpr( BondExpr *expr )$/;"	f	namespace:OpenBabel
FreePattern	parsmart.cpp	/^  static void FreePattern( Pattern *pat )$/;"	f	namespace:OpenBabel
FromNameLookup	alias.cpp	/^bool AliasData::FromNameLookup(OBMol& mol, const unsigned int atomindex)$/;"	f	class:OpenBabel::AliasData
FromString	bitvec.cpp	/^  void OBBitVec::FromString(const std::string & line, int new_bit_size)$/;"	f	class:OpenBabel::OBBitVec
FromVecInt	bitvec.cpp	/^  void OBBitVec::FromVecInt(const std::vector<int> & bit_offsets)$/;"	f	class:OpenBabel::OBBitVec
FullCode	canon.cpp	/^      FullCode()$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::FullCode
FullCode	canon.cpp	/^      FullCode(const std::vector<unsigned int> &_labels, const std::vector<unsigned short> &from)$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::FullCode
FullCode	canon.cpp	/^    struct FullCode$/;"	s	struct:OpenBabel::CanonicalLabelsImpl	file:
FullConvert	obconversion.cpp	/^  int OBConversion::FullConvert(std::vector<std::string>& FileList, std::string& OutputFileName,$/;"	f	class:OpenBabel::OBConversion
GSVResize	molchrg.cpp	/^  void OBGastChrg::GSVResize(int size)$/;"	f	class:OpenBabel::OBGastChrg
GasteigerSigmaChi	molchrg.cpp	/^  bool OBGastChrg::GasteigerSigmaChi(OBAtom *atom,double &a,double &b,double &c )$/;"	f	class:OpenBabel::OBGastChrg
GasteigerState	molchrg.cpp	/^  GasteigerState::GasteigerState()$/;"	f	class:OpenBabel::GasteigerState
GenerateAromElem	parsmart.cpp	/^  static AtomExpr *GenerateAromElem( int elem, int flag )$/;"	f	namespace:OpenBabel
GenerateByteCodes	chains.cpp	/^  void GenerateByteCodes(ByteCode **node, int resid, int curr, int prev, int bond)$/;"	f	namespace:OpenBabel
GenerateDefaultBond	parsmart.cpp	/^  static BondExpr *GenerateDefaultBond( void )$/;"	f	namespace:OpenBabel
GenerateElement	parsmart.cpp	/^  static AtomExpr *GenerateElement( int elem )$/;"	f	namespace:OpenBabel
GenerateSequence	rand.cpp	/^  void GenerateSequence( unsigned int p, unsigned int m,$/;"	f	namespace:OpenBabel
GenerateVelocities	forcefield.cpp	/^  void OBForceField::GenerateVelocities()$/;"	f	class:OpenBabel::OBForceField
GetA	generic.cpp	/^  double OBUnitCell::GetA() const$/;"	f	class:OpenBabel::OBUnitCell
GetAccuracy	spectrophore.cpp	/^OBSpectrophore::GetAccuracy(void) const$/;"	f	class:OpenBabel::OBSpectrophore
GetAlias	alias.cpp	/^  std::string AliasData::GetAlias(bool rightAligned)const$/;"	f	class:OpenBabel::AliasData
GetAllData	base.cpp	/^  std::vector<OBGenericData *> OBBase::GetAllData(const unsigned int dt)$/;"	f	class:OpenBabel::OBBase
GetAllredRochowElectroNeg	data.cpp	/^  double OBElementTable::GetAllredRochowElectroNeg(int atomicnum)$/;"	f	class:OpenBabel::OBElementTable
GetAlpha	generic.cpp	/^  double OBUnitCell::GetAlpha() const$/;"	f	class:OpenBabel::OBUnitCell
GetAminoAcidProperty	residue.cpp	/^  bool OBResidue::GetAminoAcidProperty(int property) const$/;"	f	class:OpenBabel::OBResidue
GetAngle	atom.cpp	/^  double OBAtom::GetAngle(OBAtom *b, OBAtom *c)$/;"	f	class:OpenBabel::OBAtom
GetAngle	atom.cpp	/^  double OBAtom::GetAngle(int b, int c)$/;"	f	class:OpenBabel::OBAtom
GetAngle	generic.cpp	/^  bool OBTorsion::GetAngle(double &radians, unsigned int index)$/;"	f	class:OpenBabel::OBTorsion
GetAngle	mol.cpp	/^  double OBMol::GetAngle( OBAtom* a, OBAtom* b, OBAtom* c)$/;"	f	class:OpenBabel::OBMol
GetAtom	mol.cpp	/^  OBAtom *OBMol::GetAtom(int idx) const$/;"	f	class:OpenBabel::OBMol
GetAtom4Refs	generic.cpp	/^  std::vector<unsigned int> OBChiralData::GetAtom4Refs(atomreftype t) const$/;"	f	class:OpenBabel::OBChiralData
GetAtomById	mol.cpp	/^  OBAtom *OBMol::GetAtomById(unsigned long id) const$/;"	f	class:OpenBabel::OBMol
GetAtomID	residue.cpp	/^  string OBResidue::GetAtomID(OBAtom *atom) const$/;"	f	class:OpenBabel::OBResidue
GetAtomIDNumber	residue.cpp	/^  static unsigned int GetAtomIDNumber(const char *atomid)$/;"	f	namespace:OpenBabel
GetAtomIdx	ring.cpp	/^  int OBRTree::GetAtomIdx()$/;"	f	class:OpenBabel::OBRTree
GetAtomProperty	residue.cpp	/^  bool OBResidue::GetAtomProperty(OBAtom *atom, int property) const$/;"	f	class:OpenBabel::OBResidue
GetAtomRef	generic.cpp	/^  unsigned int OBChiralData::GetAtomRef(int a, atomreftype t)$/;"	f	class:OpenBabel::OBChiralData
GetAtomTypes	forcefield.cpp	/^  bool OBForceField::GetAtomTypes(OBMol &mol)$/;"	f	class:OpenBabel::OBForceField
GetAtomicMass	atom.cpp	/^  double OBAtom::GetAtomicMass() const$/;"	f	class:OpenBabel::OBAtom
GetAtomicNum	data.cpp	/^  int OBElementTable::GetAtomicNum(const char *identifier, int &iso)$/;"	f	class:OpenBabel::OBElementTable
GetAtomicNum	data.cpp	/^  int OBElementTable::GetAtomicNum(const char *sym)$/;"	f	class:OpenBabel::OBElementTable
GetAtomicNum	data.cpp	/^  int OBElementTable::GetAtomicNum(string name, int &iso)$/;"	f	class:OpenBabel::OBElementTable
GetAtomicNum	parsmart.cpp	/^  int OBSmartsPattern::GetAtomicNum(int idx)$/;"	f	class:OpenBabel::OBSmartsPattern
GetAtoms	generic.cpp	/^  triple<OBAtom*,OBAtom*,OBAtom*> OBAngle::GetAtoms()$/;"	f	class:OpenBabel::OBAngle
GetAtoms	residue.cpp	/^  vector<OBAtom*> OBResidue::GetAtoms(void) const$/;"	f	class:OpenBabel::OBResidue
GetAvgBounds	distgeom.cpp	/^    float GetAvgBounds(int i, int j)$/;"	f	class:OpenBabel::DistanceGeometryPrivate
GetAxes	griddata.cpp	/^  void OBGridData::GetAxes( double x[3], double y[3], double z[3] ) const$/;"	f	class:OpenBabel::OBGridData
GetAxes	griddata.cpp	/^  void OBGridData::GetAxes( vector3 &v1, vector3 &v2, vector3 &v3 ) const$/;"	f	class:OpenBabel::OBGridData
GetB	generic.cpp	/^  double OBUnitCell::GetB() const$/;"	f	class:OpenBabel::OBUnitCell
GetBeta	generic.cpp	/^  double OBUnitCell::GetBeta() const$/;"	f	class:OpenBabel::OBUnitCell
GetBit	fingerprint.cpp	/^  bool OBFingerprint::GetBit(const vector<unsigned int>& vec, const unsigned int n)$/;"	f	class:OpenBabel::OBFingerprint
GetBond	atom.cpp	/^  OBBond *OBAtom::GetBond(OBAtom *nbr)$/;"	f	class:OpenBabel::OBAtom
GetBond	mol.cpp	/^  OBBond *OBMol::GetBond(OBAtom *bgn,OBAtom *end) const$/;"	f	class:OpenBabel::OBMol
GetBond	mol.cpp	/^  OBBond *OBMol::GetBond(int bgn, int end) const$/;"	f	class:OpenBabel::OBMol
GetBond	mol.cpp	/^  OBBond *OBMol::GetBond(int idx) const$/;"	f	class:OpenBabel::OBMol
GetBond	parsmart.cpp	/^  void OBSmartsPattern::GetBond(int &src,int &dst,int &ord,int idx)$/;"	f	class:OpenBabel::OBSmartsPattern
GetBondById	mol.cpp	/^  OBBond *OBMol::GetBondById(unsigned long id) const$/;"	f	class:OpenBabel::OBMol
GetBondIdx	generic.cpp	/^  unsigned int OBTorsion::GetBondIdx()$/;"	f	class:OpenBabel::OBTorsion
GetBonds	residue.cpp	/^  vector<OBBond*> OBResidue::GetBonds(bool exterior) const$/;"	f	class:OpenBabel::OBResidue
GetBoundsMatrix	distgeom.cpp	/^  Eigen::MatrixXf OBDistanceGeometry::GetBoundsMatrix()$/;"	f	class:OpenBabel::OBDistanceGeometry
GetC	generic.cpp	/^  double OBUnitCell::GetC() const$/;"	f	class:OpenBabel::OBUnitCell
GetCellMatrix	generic.cpp	/^  matrix3x3 OBUnitCell::GetCellMatrix() const$/;"	f	class:OpenBabel::OBUnitCell
GetCellVectors	generic.cpp	/^  vector<vector3> OBUnitCell::GetCellVectors() const$/;"	f	class:OpenBabel::OBUnitCell
GetCellVolume	generic.cpp	/^  double OBUnitCell::GetCellVolume() const$/;"	f	class:OpenBabel::OBUnitCell
GetChain	residue.cpp	/^  char OBResidue::GetChain(void) const$/;"	f	class:OpenBabel::OBResidue
GetChainNum	residue.cpp	/^  unsigned int OBResidue::GetChainNum(void) const$/;"	f	class:OpenBabel::OBResidue
GetCharge	parsmart.cpp	/^  int OBSmartsPattern::GetCharge(int idx)$/;"	f	class:OpenBabel::OBSmartsPattern
GetChemObject	obconversion.cpp	/^  OBBase* OBConversion::GetChemObject()$/;"	f	class:OpenBabel::OBConversion
GetChiralFlag	parsmart.cpp	/^  static int GetChiralFlag(AtomExpr *expr)$/;"	f	namespace:OpenBabel
GetChirality	chiral.cpp	/^  void GetChirality(OBMol &mol, std::vector<int> &chirality)$/;"	f	namespace:OpenBabel
GetCisTransStereo	distgeom.cpp	/^  OBCisTransStereo * OBDistanceGeometry::GetCisTransStereo(OBBond *bond)$/;"	f	class:OpenBabel::OBDistanceGeometry
GetConformers	conformersearch.cpp	/^  void OBConformerSearch::GetConformers(OBMol &mol)$/;"	f	class:OpenBabel::OBConformerSearch
GetConformers	distgeom.cpp	/^  void OBDistanceGeometry::GetConformers(OBMol &mol)$/;"	f	class:OpenBabel::OBDistanceGeometry
GetConformers	forcefield.cpp	/^  bool OBForceField::GetConformers(OBMol &mol)$/;"	f	class:OpenBabel::OBForceField
GetConstraintAtomA	forcefield.cpp	/^  int OBFFConstraints::GetConstraintAtomA(int index) const$/;"	f	class:OpenBabel::OBFFConstraints
GetConstraintAtomB	forcefield.cpp	/^  int OBFFConstraints::GetConstraintAtomB(int index) const$/;"	f	class:OpenBabel::OBFFConstraints
GetConstraintAtomC	forcefield.cpp	/^  int OBFFConstraints::GetConstraintAtomC(int index) const$/;"	f	class:OpenBabel::OBFFConstraints
GetConstraintAtomD	forcefield.cpp	/^  int OBFFConstraints::GetConstraintAtomD(int index) const$/;"	f	class:OpenBabel::OBFFConstraints
GetConstraintEnergy	forcefield.cpp	/^  double OBFFConstraints::GetConstraintEnergy()$/;"	f	class:OpenBabel::OBFFConstraints
GetConstraintType	forcefield.cpp	/^  int OBFFConstraints::GetConstraintType(int index) const$/;"	f	class:OpenBabel::OBFFConstraints
GetConstraintValue	forcefield.cpp	/^  double OBFFConstraints::GetConstraintValue(int index) const$/;"	f	class:OpenBabel::OBFFConstraints
GetConstraints	forcefield.cpp	/^  OBFFConstraints& OBForceField::GetConstraints()$/;"	f	class:OpenBabel::OBForceField
GetCoordinates	forcefield.cpp	/^  bool OBForceField::GetCoordinates(OBMol &mol)$/;"	f	class:OpenBabel::OBForceField
GetCorrectedBondVector	builder.cpp	/^  vector3 GetCorrectedBondVector(OBAtom *atom1, OBAtom *atom2, int bondOrder = 1)$/;"	f	namespace:OpenBabel
GetCovalentRad	data.cpp	/^  double OBElementTable::GetCovalentRad(int atomicnum)$/;"	f	class:OpenBabel::OBElementTable
GetCurrentValence	mol.cpp	/^  int GetCurrentValence(OBAtom *atom)$/;"	f	namespace:OpenBabel
GetCutoff	confsearch.cpp	/^      inline double GetCutoff() {$/;"	f	class:OpenBabel::OBDiversePoses
GetDFFVector	rotor.cpp	/^  bool GetDFFVector(OBMol &mol,vector<int> &dffv,OBBitVec &bv)$/;"	f	namespace:OpenBabel
GetData	base.cpp	/^  OBGenericData *OBBase::GetData(const char *s)$/;"	f	class:OpenBabel::OBBase
GetData	base.cpp	/^  OBGenericData *OBBase::GetData(const string &s)$/;"	f	class:OpenBabel::OBBase
GetData	base.cpp	/^  OBGenericData *OBBase::GetData(const unsigned int dt)$/;"	f	class:OpenBabel::OBBase
GetData	base.cpp	/^  std::vector<OBGenericData*>  OBBase::GetData(DataOrigin source)$/;"	f	class:OpenBabel::OBBase
GetDataVector	grid.cpp	/^  std::vector<double> OBFloatGrid::GetDataVector()$/;"	f	class:OpenBabel::OBFloatGrid
GetDipoleMoment	chargemodel.cpp	/^  vector3 OBChargeModel::GetDipoleMoment(OBMol &mol)$/;"	f	class:OpenBabel::OBChargeModel
GetDistance	atom.cpp	/^  double OBAtom::GetDistance(OBAtom *b)$/;"	f	class:OpenBabel::OBAtom
GetDistance	atom.cpp	/^  double OBAtom::GetDistance(int b)$/;"	f	class:OpenBabel::OBAtom
GetDistance	atom.cpp	/^  double OBAtom::GetDistance(vector3 *v)$/;"	f	class:OpenBabel::OBAtom
GetElectroNeg	data.cpp	/^  double OBElementTable::GetElectroNeg(int atomicnum)$/;"	f	class:OpenBabel::OBElementTable
GetElectronAffinity	data.cpp	/^  double OBElementTable::GetElectronAffinity(int atomicnum)$/;"	f	class:OpenBabel::OBElementTable
GetEnergies	mol.cpp	/^  vector<double> OBMol::GetEnergies()$/;"	f	class:OpenBabel::OBMol
GetEnergy	mol.cpp	/^  double OBMol::GetEnergy(int ci)$/;"	f	class:OpenBabel::OBMol
GetEquibLength	bond.cpp	/^  double OBBond::GetEquibLength() const$/;"	f	class:OpenBabel::OBBond
GetExactMass	atom.cpp	/^  double OBAtom::GetExactMass() const$/;"	f	class:OpenBabel::OBAtom
GetExactMass	data.cpp	/^  double        OBIsotopeTable::GetExactMass(const unsigned int ele,$/;"	f	class:OpenBabel::OBIsotopeTable
GetExactMass	mol.cpp	/^  double OBMol::GetExactMass(bool implicitH)$/;"	f	class:OpenBabel::OBMol
GetExprAtomicNum	parsmart.cpp	/^  static int GetExprAtomicNum(AtomExpr *expr)$/;"	f	namespace:OpenBabel
GetExprCharge	parsmart.cpp	/^  static int GetExprCharge(AtomExpr *expr)$/;"	f	namespace:OpenBabel
GetExprOrder	parsmart.cpp	/^  static int GetExprOrder(BondExpr *expr)$/;"	f	namespace:OpenBabel
GetFactor	forcefield.cpp	/^  double OBFFConstraints::GetFactor()$/;"	f	class:OpenBabel::OBFFConstraints
GetFirstAtom	mol.cpp	/^  OBAtom *OBMol::GetFirstAtom() const$/;"	f	class:OpenBabel::OBMol
GetFormula	mol.cpp	/^  string OBMol::GetFormula()$/;"	f	class:OpenBabel::OBMol
GetFractionalMatrix	generic.cpp	/^  matrix3x3 OBUnitCell::GetFractionalMatrix() const$/;"	f	class:OpenBabel::OBUnitCell
GetFragment	builder.cpp	/^  OBBitVec OBBuilder::GetFragment(OBAtom *atom)$/;"	f	class:OpenBabel::OBBuilder
GetFromType	data.cpp	/^  std::string OBTypeTable::GetFromType()$/;"	f	class:OpenBabel::OBTypeTable
GetGIDVector	mol.cpp	/^  void OBMol::GetGIDVector(vector<unsigned int> &vgid)$/;"	f	class:OpenBabel::OBMol
GetGIVector	graphsym.cpp	/^  void OBGraphSymPrivate::GetGIVector(vector<unsigned int> &vid)$/;"	f	class:OpenBabel::OBGraphSymPrivate
GetGIVector	mol.cpp	/^  void OBMol::GetGIVector(vector<unsigned int> &vid)$/;"	f	class:OpenBabel::OBMol
GetGTDVector	graphsym.cpp	/^  bool OBGraphSymPrivate::GetGTDVector(vector<int> &gtd)$/;"	f	class:OpenBabel::OBGraphSymPrivate
GetGTDVector	mol.cpp	/^  bool OBMol::GetGTDVector(vector<int> &gtd)$/;"	f	class:OpenBabel::OBMol
GetGamma	generic.cpp	/^  double OBUnitCell::GetGamma() const$/;"	f	class:OpenBabel::OBUnitCell
GetGeometry	distgeom.cpp	/^  bool OBDistanceGeometry::GetGeometry(OBMol &mol, bool useCurrentGeom)$/;"	f	class:OpenBabel::OBDistanceGeometry
GetGradient	forcefield.cpp	/^  vector3 OBFFConstraints::GetGradient(int a)$/;"	f	class:OpenBabel::OBFFConstraints
GetGrid	forcefield.cpp	/^  OBGridData* OBForceField::GetGrid(double step, double padding, const char* type, double pchg)$/;"	f	class:OpenBabel::OBForceField
GetHeatOfFormation	data.cpp	/^  int OBAtomicHeatOfFormationTable::GetHeatOfFormation(std::string elem,$/;"	f	class:OpenBabel::OBAtomicHeatOfFormationTable
GetHeavyAtomCoords	confsearch.cpp	/^  vector<vector3> OBDiversePoses::GetHeavyAtomCoords(const vector<vector3> &all_coords) {$/;"	f	class:OpenBabel::OBDiversePoses
GetHeavyAtomCoords	confsearch.cpp	/^vector<vector3> GetHeavyAtomCoords(const OBMol* mol, const vector<vector3> &all_coords) {$/;"	f	namespace:OpenBabel
GetHeteroValence	atom.cpp	/^  unsigned int OBAtom::GetHeteroValence() const$/;"	f	class:OpenBabel::OBAtom
GetHvyBondSum	graphsym.cpp	/^  unsigned int OBGraphSymPrivate::GetHvyBondSum(OBAtom *atom)$/;"	f	class:OpenBabel::OBGraphSymPrivate
GetHvyValence	atom.cpp	/^  unsigned int OBAtom::GetHvyValence() const$/;"	f	class:OpenBabel::OBAtom
GetHvyValence	graphsym.cpp	/^  unsigned int OBGraphSymPrivate::GetHvyValence(OBAtom *atom)$/;"	f	class:OpenBabel::OBGraphSymPrivate
GetHyb	atom.cpp	/^  unsigned int OBAtom::GetHyb() const$/;"	f	class:OpenBabel::OBAtom
GetIdentifier	descriptor.cpp	/^pair<string,string> OBDescriptor::GetIdentifier(istream& optionText)$/;"	f	class:OpenBabel::OBDescriptor
GetIdx	residue.cpp	/^  unsigned int OBResidue::GetIdx(void) const$/;"	f	class:OpenBabel::OBResidue
GetImplicitValence	atom.cpp	/^  unsigned int OBAtom::GetImplicitValence() const$/;"	f	class:OpenBabel::OBAtom
GetInsertionCode	residue.cpp	/^  char OBResidue::GetInsertionCode(void) const$/;"	f	class:OpenBabel::OBResidue
GetInstance	isomorphism.cpp	/^  OBIsomorphismMapper* OBIsomorphismMapper::GetInstance(OBQuery *query, const std::string &algorithm)$/;"	f	class:OpenBabel::OBIsomorphismMapper
GetInternalCoord	mol.cpp	/^  std::vector<OBInternalCoord*> OBMol::GetInternalCoord()$/;"	f	class:OpenBabel::OBMol
GetIonization	data.cpp	/^  double OBElementTable::GetIonization(int atomicnum)$/;"	f	class:OpenBabel::OBElementTable
GetLSSR	mol.cpp	/^  vector<OBRing*> &OBMol::GetLSSR()$/;"	f	class:OpenBabel::OBMol
GetLatticeType	generic.cpp	/^  OBUnitCell::LatticeType OBUnitCell::GetLatticeType( int spacegroup ) const$/;"	f	class:OpenBabel::OBUnitCell
GetLatticeType	generic.cpp	/^  OBUnitCell::LatticeType OBUnitCell::GetLatticeType() const$/;"	f	class:OpenBabel::OBUnitCell
GetLength	bond.cpp	/^  double OBBond::GetLength() const$/;"	f	class:OpenBabel::OBBond
GetLowerBounds	distgeom.cpp	/^    float GetLowerBounds(int i, int j)$/;"	f	class:OpenBabel::DistanceGeometryPrivate
GetMass	data.cpp	/^  double OBElementTable::GetMass(int atomicnum)$/;"	f	class:OpenBabel::OBElementTable
GetMaxBonds	data.cpp	/^  int OBElementTable::GetMaxBonds(int atomicnum)$/;"	f	class:OpenBabel::OBElementTable
GetMaxValue	griddata.cpp	/^  double OBGridData::GetMaxValue() const$/;"	f	class:OpenBabel::OBGridData
GetMaxVector	griddata.cpp	/^  vector3 OBGridData::GetMaxVector() const$/;"	f	class:OpenBabel::OBGridData
GetMessageSummary	oberror.cpp	/^  string OBMessageHandler::GetMessageSummary()$/;"	f	class:OpenBabel::OBMessageHandler
GetMessagesOfLevel	oberror.cpp	/^  std::vector<std::string> OBMessageHandler::GetMessagesOfLevel(const obMessageLevel level)$/;"	f	class:OpenBabel::OBMessageHandler
GetMinValue	griddata.cpp	/^  double OBGridData::GetMinValue() const$/;"	f	class:OpenBabel::OBGridData
GetMolWt	mol.cpp	/^  double OBMol::GetMolWt(bool implicitH)$/;"	f	class:OpenBabel::OBMol
GetNRMSD	confsearch.cpp	/^      inline int GetNRMSD() {$/;"	f	class:OpenBabel::OBDiversePoses
GetName	data.cpp	/^  string OBElementTable::GetName(int atomicnum)$/;"	f	class:OpenBabel::OBElementTable
GetName	residue.cpp	/^  string OBResidue::GetName(void) const$/;"	f	class:OpenBabel::OBResidue
GetNewBondVector	atom.cpp	/^  bool OBAtom::GetNewBondVector(vector3 &v,double length)$/;"	f	class:OpenBabel::OBAtom
GetNewBondVector	builder.cpp	/^  vector3 OBBuilder::GetNewBondVector(OBAtom *atom)$/;"	f	class:OpenBabel::OBBuilder
GetNewBondVector	builder.cpp	/^  vector3 OBBuilder::GetNewBondVector(OBAtom *atom, double length)$/;"	f	class:OpenBabel::OBBuilder
GetNext	confsearch.cpp	/^  inline unsigned int LFSR::GetNext()$/;"	f	class:OpenBabel::LFSR
GetNextAtom	atom.cpp	/^  OBAtom *OBAtom::GetNextAtom()$/;"	f	class:OpenBabel::OBAtom
GetNextFormat	obconversion.cpp	/^  bool OBConversion::GetNextFormat(Formatpos& itr, const char*& str,OBFormat*& pFormat)$/;"	f	class:OpenBabel::OBConversion
GetNextFragment	mol.cpp	/^  bool OBMol::GetNextFragment( OBMolAtomDFSIter& iter, OBMol& newmol ) {$/;"	f	class:OpenBabel::OBMol
GetNormalization	spectrophore.cpp	/^OBSpectrophore::GetNormalization(void) const$/;"	f	class:OpenBabel::OBSpectrophore
GetNum	residue.cpp	/^  unsigned int OBResidue::GetNum(void)$/;"	f	class:OpenBabel::OBResidue
GetNumAtoms	residue.cpp	/^  unsigned int OBResidue::GetNumAtoms(void) const$/;"	f	class:OpenBabel::OBResidue
GetNumElectrostaticPairs	forcefield.cpp	/^  unsigned int OBForceField::GetNumElectrostaticPairs()$/;"	f	class:OpenBabel::OBForceField
GetNumPairs	forcefield.cpp	/^  unsigned int OBForceField::GetNumPairs()$/;"	f	class:OpenBabel::OBForceField
GetNumString	residue.cpp	/^  std::string OBResidue::GetNumString(void)$/;"	f	class:OpenBabel::OBResidue
GetNumSymmetries	griddata.cpp	/^  int OBGridData::GetNumSymmetries() const$/;"	f	class:OpenBabel::OBGridData
GetNumVDWPairs	forcefield.cpp	/^  unsigned int OBForceField::GetNumVDWPairs()$/;"	f	class:OpenBabel::OBForceField
GetNumberOfElements	data.cpp	/^  unsigned int OBElementTable::GetNumberOfElements()$/;"	f	class:OpenBabel::OBElementTable
GetNumberOfFrequencies	generic.cpp	/^unsigned int OBVibrationData::GetNumberOfFrequencies() const$/;"	f	class:OpenBabel::OBVibrationData
GetNumberOfPoints	griddata.cpp	/^  int OBGridData::GetNumberOfPoints() const$/;"	f	class:OpenBabel::OBGridData
GetNumberOfPoints	griddata.cpp	/^  void OBGridData::GetNumberOfPoints( int &nx, int &ny, int &nz) const$/;"	f	class:OpenBabel::OBGridData
GetNumberOfSteps	griddata.cpp	/^  void OBGridData::GetNumberOfSteps( int steps[ 3 ] ) const$/;"	f	class:OpenBabel::OBGridData
GetOffset	generic.cpp	/^  vector3 OBUnitCell::GetOffset() const$/;"	f	class:OpenBabel::OBUnitCell
GetOptionParams	obconversion.cpp	/^  int OBConversion::GetOptionParams(string name, Option_type typ)$/;"	f	class:OpenBabel::OBConversion
GetOrientationMatrix	generic.cpp	/^  matrix3x3 OBUnitCell::GetOrientationMatrix() const$/;"	f	class:OpenBabel::OBUnitCell
GetOriginVector	griddata.cpp	/^  vector3 OBGridData::GetOriginVector() const$/;"	f	class:OpenBabel::OBGridData
GetOriginVector	griddata.cpp	/^  void OBGridData::GetOriginVector( double o[ 3 ] ) const$/;"	f	class:OpenBabel::OBGridData
GetOrthoMatrix	generic.cpp	/^  matrix3x3 OBUnitCell::GetOrthoMatrix() const$/;"	f	class:OpenBabel::OBUnitCell
GetOutputIndex	obconversion.cpp	/^  int OBConversion::GetOutputIndex() const$/;"	f	class:OpenBabel::OBConversion
GetParameter	forcefield.cpp	/^  OBFFParameter* OBForceField::GetParameter(const char* a, const char* b, const char* c,$/;"	f	class:OpenBabel::OBForceField
GetParameter	forcefield.cpp	/^  OBFFParameter* OBForceField::GetParameter(int a, int b, int c, int d,$/;"	f	class:OpenBabel::OBForceField
GetParameterIdx	forcefield.cpp	/^  int OBForceField::GetParameterIdx(int a, int b, int c, int d, vector<OBFFParameter> &parameter)$/;"	f	class:OpenBabel::OBForceField
GetParity4Ref	chiral.cpp	/^  int GetParity4Ref(vector<unsigned int> pref)$/;"	f	namespace:OpenBabel
GetPartialCharge	atom.cpp	/^  double OBAtom::GetPartialCharge()$/;"	f	class:OpenBabel::OBAtom
GetPartialCharges	forcefield.cpp	/^  bool OBForceField::GetPartialCharges(OBMol &mol)$/;"	f	class:OpenBabel::OBForceField
GetPlugin	plugin.cpp	/^OBPlugin* OBPlugin::GetPlugin(const char* Type, const char* ID)$/;"	f	class:OpenBabel::OBPlugin
GetProxVector	grid.cpp	/^  vector<int> *OBProxGrid::GetProxVector(double *c)$/;"	f	class:OpenBabel::OBProxGrid
GetProxVector	grid.cpp	/^  vector<int> *OBProxGrid::GetProxVector(double x,double y,double z)$/;"	f	class:OpenBabel::OBProxGrid
GetRGB	data.cpp	/^  vector<double> OBElementTable::GetRGB(int atomicnum)$/;"	f	class:OpenBabel::OBElementTable
GetReferenceArray	rotamer.cpp	/^  void OBRotamerList::GetReferenceArray(unsigned char *ref)const$/;"	f	class:OpenBabel::OBRotamerList
GetResKey	residue.cpp	/^  unsigned int OBResidue::GetResKey(void) const$/;"	f	class:OpenBabel::OBResidue
GetResidue	atom.cpp	/^  OBResidue *OBAtom::GetResidue()$/;"	f	class:OpenBabel::OBAtom
GetResidue	atom.cpp	/^  OBResidue *OBAtom::GetResidue(bool perception)$/;"	f	class:OpenBabel::OBAtom
GetResidue	mol.cpp	/^  OBResidue *OBMol::GetResidue(int idx) const$/;"	f	class:OpenBabel::OBMol
GetResidueNumber	residue.cpp	/^  static unsigned int GetResidueNumber(const char *res)$/;"	f	namespace:OpenBabel
GetResidueProperty	residue.cpp	/^  bool OBResidue::GetResidueProperty(int property) const$/;"	f	class:OpenBabel::OBResidue
GetResolution	spectrophore.cpp	/^OBSpectrophore::GetResolution(void) const$/;"	f	class:OpenBabel::OBSpectrophore
GetRootAtom	ring.cpp	/^  unsigned int OBRing::GetRootAtom()$/;"	f	class:OpenBabel::OBRing
GetRotorIncrements	rotor.cpp	/^  void OBRotorRules::GetRotorIncrements(OBMol &mol,OBBond *bond,$/;"	f	class:OpenBabel::OBRotorRules
GetSSSR	mol.cpp	/^  vector<OBRing*> &OBMol::GetSSSR()$/;"	f	class:OpenBabel::OBMol
GetSerialNum	residue.cpp	/^  unsigned int OBResidue::GetSerialNum(OBAtom *atom) const$/;"	f	class:OpenBabel::OBResidue
GetSize	confsearch.cpp	/^  size_t OBDiversePoses::GetSize() {$/;"	f	class:OpenBabel::OBDiversePoses
GetSize	generic.cpp	/^  unsigned int OBChiralData::GetSize(atomreftype t) const$/;"	f	class:OpenBabel::OBChiralData
GetSpaceGroupNumber	generic.cpp	/^  int OBUnitCell::GetSpaceGroupNumber( std::string name) const$/;"	f	class:OpenBabel::OBUnitCell
GetSpacedFormula	mol.cpp	/^  string OBMol::GetSpacedFormula(int ones, const char* sp, bool implicitH)$/;"	f	class:OpenBabel::OBMol
GetSpectrophore	spectrophore.cpp	/^OBSpectrophore::GetSpectrophore(OpenBabel::OBMol* mol)$/;"	f	class:OpenBabel::OBSpectrophore
GetStereo	spectrophore.cpp	/^OBSpectrophore::GetStereo(void) const$/;"	f	class:OpenBabel::OBSpectrophore
GetStringValue	descriptor.cpp	/^double OBDescriptor::GetStringValue(OBBase* pOb, string& svalue, string* param)$/;"	f	class:OpenBabel::OBDescriptor
GetSupportedInputFormat	obconversion.cpp	/^  std::vector<std::string> OBConversion::GetSupportedInputFormat()$/;"	f	class:OpenBabel::OBConversion
GetSupportedOutputFormat	obconversion.cpp	/^  std::vector<std::string> OBConversion::GetSupportedOutputFormat()$/;"	f	class:OpenBabel::OBConversion
GetSymbol	data.cpp	/^  const char *OBElementTable::GetSymbol(int atomicnum)$/;"	f	class:OpenBabel::OBElementTable
GetSymmetry	graphsym.cpp	/^  int OBGraphSym::GetSymmetry(std::vector<unsigned int> &symmetry_classes)$/;"	f	class:OpenBabel::OBGraphSym
GetTitle	mol.cpp	/^  const char *OBMol::GetTitle(bool replaceNewlines) const$/;"	f	class:OpenBabel::OBMol
GetTitle	obconversion.cpp	/^  const char* OBConversion::GetTitle() const$/;"	f	class:OpenBabel::OBConversion
GetToType	data.cpp	/^  std::string OBTypeTable::GetToType()$/;"	f	class:OpenBabel::OBTypeTable
GetTorsion	mol.cpp	/^  double OBMol::GetTorsion(OBAtom *a,OBAtom *b,OBAtom *c,OBAtom *d)$/;"	f	class:OpenBabel::OBMol
GetTorsion	mol.cpp	/^  double OBMol::GetTorsion(int a,int b,int c,int d)$/;"	f	class:OpenBabel::OBMol
GetTorsions	generic.cpp	/^  vector<quad<OBAtom*,OBAtom*,OBAtom*,OBAtom*> > OBTorsion::GetTorsions()$/;"	f	class:OpenBabel::OBTorsion
GetTotalCharge	mol.cpp	/^  int OBMol::GetTotalCharge()$/;"	f	class:OpenBabel::OBMol
GetTotalSpinMultiplicity	mol.cpp	/^  unsigned int OBMol::GetTotalSpinMultiplicity()$/;"	f	class:OpenBabel::OBMol
GetTree	confsearch.cpp	/^      Tree* GetTree() { return &poses; }$/;"	f	class:OpenBabel::OBDiversePoses
GetType	atom.cpp	/^  char *OBAtom::GetType()$/;"	f	class:OpenBabel::OBAtom
GetType	format.cpp	/^const type_info& OBFormat::GetType()$/;"	f	class:OpenBabel::OBFormat
GetType	ring.cpp	/^  char* OBRing::GetType()$/;"	f	class:OpenBabel::OBRing
GetTypeMap	plugin.cpp	/^OBPlugin::PluginMapType& OBPlugin::GetTypeMap(const char* PluginID)$/;"	f	class:OpenBabel::OBPlugin
GetUMapList	parsmart.cpp	/^  std::vector<std::vector<int> > &OBSmartsPattern::GetUMapList()$/;"	f	class:OpenBabel::OBSmartsPattern
GetUnit	griddata.cpp	/^  OBGridData::Unit OBGridData::GetUnit() const$/;"	f	class:OpenBabel::OBGridData
GetUnrestricted	griddata.cpp	/^  bool OBGridData::GetUnrestricted() const$/;"	f	class:OpenBabel::OBGridData
GetUpperBounds	distgeom.cpp	/^    float GetUpperBounds(int i, int j)$/;"	f	class:OpenBabel::DistanceGeometryPrivate
GetValue	griddata.cpp	/^  double OBGridData::GetValue( int i, int j, int k ) const$/;"	f	class:OpenBabel::OBGridData
GetValue	griddata.cpp	/^  double OBGridData::GetValue(vector3 pos) const$/;"	f	class:OpenBabel::OBGridData
GetValues	descriptor.cpp	/^  string OBDescriptor::GetValues(OBBase* pOb, const std::string& DescrList)$/;"	f	class:OpenBabel::OBDescriptor
GetValues	griddata.cpp	/^  std::vector< double > OBGridData::GetValues() const$/;"	f	class:OpenBabel::OBGridData
GetVdwRad	data.cpp	/^  double OBElementTable::GetVdwRad(int atomicnum)$/;"	f	class:OpenBabel::OBElementTable
GetVector	atom.cpp	/^  const vector3 &OBAtom::GetVector() const$/;"	f	class:OpenBabel::OBAtom
GetVector	atom.cpp	/^  vector3 &OBAtom::GetVector()$/;"	f	class:OpenBabel::OBAtom
GetVectorBinding	parsmart.cpp	/^  int OBSmartsPattern::GetVectorBinding()$/;"	f	class:OpenBabel::OBSmartsPattern
GetXAxis	griddata.cpp	/^  vector3 OBGridData::GetXAxis() const$/;"	f	class:OpenBabel::OBGridData
GetYAxis	griddata.cpp	/^  vector3 OBGridData::GetYAxis() const$/;"	f	class:OpenBabel::OBGridData
GetZAxis	griddata.cpp	/^  vector3 OBGridData::GetZAxis() const$/;"	f	class:OpenBabel::OBGridData
GradientStep	pointgroup.cpp	/^    double                 GradientStep          ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
GraphPotentials	chiral.cpp	/^  void GraphPotentials(OBMol &mol, std::vector<double> &pot)$/;"	f	namespace:OpenBabel
GridDataPrivate	griddata.cpp	/^    GridDataPrivate() {    }$/;"	f	class:OpenBabel::GridDataPrivate
GridDataPrivate	griddata.cpp	/^  class GridDataPrivate {$/;"	c	namespace:OpenBabel	file:
HALOGEN_ATOM	mcdlutil.cpp	149;"	d	file:
HETERO_ATOM	mcdlutil.cpp	151;"	d	file:
HPUX_COMPATIBLE	snprintf.c	305;"	d	file:
Has2D	mol.cpp	/^  bool OBMol::Has2D(bool Not3D)$/;"	f	class:OpenBabel::OBMol
Has3D	mol.cpp	/^  bool OBMol::Has3D()$/;"	f	class:OpenBabel::OBMol
HasAlphaBetaUnsat	atom.cpp	/^  bool OBAtom::HasAlphaBetaUnsat(bool includePandS)$/;"	f	class:OpenBabel::OBAtom
HasBondOfOrder	atom.cpp	/^  bool OBAtom::HasBondOfOrder(unsigned int order)$/;"	f	class:OpenBabel::OBAtom
HasData	base.cpp	/^  bool OBBase::HasData(const char *s)$/;"	f	class:OpenBabel::OBBase
HasData	base.cpp	/^  bool OBBase::HasData(const string &s)$/;"	f	class:OpenBabel::OBBase
HasData	base.cpp	/^  bool OBBase::HasData(const unsigned int dt)$/;"	f	class:OpenBabel::OBBase
HasGroups	forcefield.cpp	/^  bool OBForceField::HasGroups()$/;"	f	class:OpenBabel::OBForceField
HasMatch	parsmart.cpp	/^  bool OBSmartsPattern::HasMatch(OBMol &mol) const$/;"	f	class:OpenBabel::OBSmartsPattern
HasNonSingleBond	atom.cpp	/^  bool OBAtom::HasNonSingleBond()$/;"	f	class:OpenBabel::OBAtom
HasNonZeroCoords	mol.cpp	/^  bool OBMol::HasNonZeroCoords()$/;"	f	class:OpenBabel::OBMol
HiPart	rand.cpp	55;"	d	file:
HighestBondOrder	atom.cpp	/^  int OBAtom::HighestBondOrder()$/;"	f	class:OpenBabel::OBAtom
HtoMethyl	atom.cpp	/^  bool OBAtom::HtoMethyl()$/;"	f	class:OpenBabel::OBAtom
Hybridized	tautomer.cpp	/^      Hybridized,$/;"	e	enum:OpenBabel::TautomerImpl::Type	file:
IMols	obmolecformat.cpp	/^  std::map<std::string, OBMol*> OBMoleculeFormat::IMols;$/;"	m	class:OpenBabel::OBMoleculeFormat	file:
IdentifyElement	chains.cpp	/^  int OBChainsParser::IdentifyElement(char *ptr)$/;"	f	class:OpenBabel::OBChainsParser
IdentifyPointGroup	pointgroup.cpp	/^  const char* OBPointGroup::IdentifyPointGroup()$/;"	f	class:OpenBabel::OBPointGroup
IdentifyPointGroup	pointgroup.cpp	/^  const char* OBPointGroup::IdentifyPointGroup(double tolerance)$/;"	f	class:OpenBabel::OBPointGroup
IdentifyPointGroupSymbol	pointgroup.cpp	/^  OBPointGroup::Symbol OBPointGroup::IdentifyPointGroupSymbol(double tolerance)$/;"	f	class:OpenBabel::OBPointGroup
IdentifyResidue	chains.cpp	/^  int OBChainsParser::IdentifyResidue(void *tree, OBMol &mol, unsigned int seed,$/;"	f	class:OpenBabel::OBChainsParser
IgnoreCalculation	forcefield.cpp	/^  bool OBForceField::IgnoreCalculation(int a, int b)$/;"	f	class:OpenBabel::OBForceField
IgnoreCalculation	forcefield.cpp	/^  bool OBForceField::IgnoreCalculation(int a, int b, int c)$/;"	f	class:OpenBabel::OBForceField
IgnoreCalculation	forcefield.cpp	/^  bool OBForceField::IgnoreCalculation(int a, int b, int c, int d)$/;"	f	class:OpenBabel::OBForceField
ImplicitHydrogenCount	atom.cpp	/^  unsigned int OBAtom::ImplicitHydrogenCount() const$/;"	f	class:OpenBabel::OBAtom
ImproperAxes	pointgroup.cpp	/^    SYMMETRY_ELEMENT **    ImproperAxes          ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
ImproperAxesCount	pointgroup.cpp	/^    int                    ImproperAxesCount     ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
ImproperAxesCounts	pointgroup.cpp	/^    int *                  ImproperAxesCounts    ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
IncrementedFileName	obconversion.cpp	/^  string OBConversion::IncrementedFileName(string& BaseName, const int Count)$/;"	f	class:OpenBabel::OBConversion
IndexToCoords	grid.cpp	/^  void OBFloatGrid::IndexToCoords(int idx, double &x, double &y, double &z)$/;"	f	class:OpenBabel::OBFloatGrid
Init	data.cpp	/^  void OBGlobalDataBase::Init()$/;"	f	class:OpenBabel::OBGlobalDataBase
Init	grid.cpp	/^  void OBFloatGrid::Init(OBMol &box, double spacing, double pad)$/;"	f	class:OpenBabel::OBFloatGrid
Init	grid.cpp	/^  void OBGrid::Init(OBMol &box)$/;"	f	class:OpenBabel::OBGrid
Init	parsmart.cpp	/^  bool OBSmartsPattern::Init(const char *buffer)$/;"	f	class:OpenBabel::OBSmartsPattern
Init	parsmart.cpp	/^  bool OBSmartsPattern::Init(const std::string &s)$/;"	f	class:OpenBabel::OBSmartsPattern
Init	phmodel.cpp	/^  bool OBChemTsfm::Init(string &bgn,string &end)$/;"	f	class:OpenBabel::OBChemTsfm
InitialPartialCharges	molchrg.cpp	/^  void OBGastChrg::InitialPartialCharges(OBMol &mol)$/;"	f	class:OpenBabel::OBGastChrg
Inject	grid.cpp	/^  double OBFloatGrid::Inject(double x, double y, double z)$/;"	f	class:OpenBabel::OBFloatGrid
InsertAtom	mol.cpp	/^  bool OBMol::InsertAtom(OBAtom &atom)$/;"	f	class:OpenBabel::OBMol
InsertAtom	residue.cpp	/^  void OBResidue::InsertAtom(OBAtom *atom)$/;"	f	class:OpenBabel::OBResidue
InternalToCartesian	obutil.cpp	/^  void InternalToCartesian(std::vector<OBInternalCoord*> &vic,OBMol &mol)$/;"	f	namespace:OpenBabel
Interpolate	grid.cpp	/^  double OBFloatGrid::Interpolate(double x, double y, double z)$/;"	f	class:OpenBabel::OBFloatGrid
InterpolateDerivatives	grid.cpp	/^  double OBFloatGrid::InterpolateDerivatives(double x,double y,double z,double *derivatives)$/;"	f	class:OpenBabel::OBFloatGrid
InversionCenters	pointgroup.cpp	/^    SYMMETRY_ELEMENT **    InversionCenters      ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
InversionCentersCount	pointgroup.cpp	/^    int                    InversionCentersCount ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
InvertCase	obutil.cpp	/^  void InvertCase(char *cptr)$/;"	f	namespace:OpenBabel
InvertCase	obutil.cpp	/^  void InvertCase(std::string &s, unsigned int start)$/;"	f	namespace:OpenBabel
IsAcid	phmodel.cpp	/^  bool OBChemTsfm::IsAcid()$/;"	f	class:OpenBabel::OBChemTsfm
IsAmide	bond.cpp	/^   bool OBBond::IsAmide()$/;"	f	class:OpenBabel::OBBond
IsAmideNitrogen	atom.cpp	/^  bool OBAtom::IsAmideNitrogen()$/;"	f	class:OpenBabel::OBAtom
IsAromatic	atom.cpp	/^  bool OBAtom::IsAromatic() const$/;"	f	class:OpenBabel::OBAtom
IsAromatic	bond.cpp	/^  bool OBBond::IsAromatic() const$/;"	f	class:OpenBabel::OBBond
IsAromatic	ring.cpp	/^  bool OBRing::IsAromatic()$/;"	f	class:OpenBabel::OBRing
IsAromaticNOxide	atom.cpp	/^  bool OBAtom::IsAromaticNOxide()$/;"	f	class:OpenBabel::OBAtom
IsAxial	atom.cpp	/^  bool OBAtom::IsAxial()$/;"	f	class:OpenBabel::OBAtom
IsBase	phmodel.cpp	/^  bool OBChemTsfm::IsBase()$/;"	f	class:OpenBabel::OBChemTsfm
IsCarbonyl	bond.cpp	/^  bool OBBond::IsCarbonyl()$/;"	f	class:OpenBabel::OBBond
IsCarboxylOxygen	atom.cpp	/^  bool OBAtom::IsCarboxylOxygen()$/;"	f	class:OpenBabel::OBAtom
IsChiral	atom.cpp	/^  bool OBAtom::IsChiral()$/;"	f	class:OpenBabel::OBAtom
IsChiral	mol.cpp	/^  bool OBMol::IsChiral()$/;"	f	class:OpenBabel::OBMol
IsClosure	bond.cpp	/^  bool OBBond::IsClosure()$/;"	f	class:OpenBabel::OBBond
IsConnected	atom.cpp	/^  bool OBAtom::IsConnected(OBAtom *a1)$/;"	f	class:OpenBabel::OBAtom
IsDouble	bond.cpp	/^  bool OBBond::IsDouble()$/;"	f	class:OpenBabel::OBBond
IsDoubleBondGeometry	bond.cpp	/^  bool OBBond::IsDoubleBondGeometry()$/;"	f	class:OpenBabel::OBBond
IsEmpty	bitvec.cpp	/^  bool OBBitVec::IsEmpty() const$/;"	f	class:OpenBabel::OBBitVec
IsEster	bond.cpp	/^  bool OBBond::IsEster()$/;"	f	class:OpenBabel::OBBond
IsEven	rand.cpp	49;"	d	file:
IsFirstInput	obconversion.cpp	/^  bool OBConversion::IsFirstInput()$/;"	f	class:OpenBabel::OBConversion
IsFixed	forcefield.cpp	/^  bool OBFFConstraints::IsFixed(int index)$/;"	f	class:OpenBabel::OBFFConstraints
IsFixedBond	rotor.cpp	/^  bool OBRotorList::IsFixedBond(OBBond *bond)$/;"	f	class:OpenBabel::OBRotorList
IsGood	conformersearch.cpp	/^  bool OBConformerSearch::IsGood(const RotorKey &key)$/;"	f	class:OpenBabel::OBConformerSearch
IsGood	conformersearch.cpp	/^  bool OBStericConformerFilter::IsGood(const OBMol &mol, const RotorKey &key, double *conformer)$/;"	f	class:OpenBabel::OBStericConformerFilter
IsHbondAcceptor	atom.cpp	/^  bool OBAtom::IsHbondAcceptor() {$/;"	f	class:OpenBabel::OBAtom
IsHbondAcceptorSimple	atom.cpp	/^  bool OBAtom::IsHbondAcceptorSimple()$/;"	f	class:OpenBabel::OBAtom
IsHbondDonor	atom.cpp	/^  bool OBAtom::IsHbondDonor()$/;"	f	class:OpenBabel::OBAtom
IsHbondDonorH	atom.cpp	/^  bool OBAtom::IsHbondDonorH()$/;"	f	class:OpenBabel::OBAtom
IsHetAtom	residue.cpp	/^  bool OBResidue::IsHetAtom(OBAtom *atom) const$/;"	f	class:OpenBabel::OBResidue
IsHeteroatom	atom.cpp	/^  bool OBAtom::IsHeteroatom()$/;"	f	class:OpenBabel::OBAtom
IsIgnored	forcefield.cpp	/^  bool OBFFConstraints::IsIgnored(int index)$/;"	f	class:OpenBabel::OBFFConstraints
IsInRing	atom.cpp	/^  bool OBAtom::IsInRing() const$/;"	f	class:OpenBabel::OBAtom
IsInRing	bond.cpp	/^  bool OBBond::IsInRing() const$/;"	f	class:OpenBabel::OBBond
IsInRingSize	atom.cpp	/^  bool OBAtom::IsInRingSize(int size) const$/;"	f	class:OpenBabel::OBAtom
IsInSameRing	forcefield.cpp	/^  bool OBForceField::IsInSameRing(OBAtom* a, OBAtom* b)$/;"	f	class:OpenBabel::OBForceField
IsInvalidAtom	parsmart.cpp	/^  static int IsInvalidAtom( AtomExpr *expr )$/;"	f	namespace:OpenBabel
IsKDouble	bond.cpp	/^  bool OBBond::IsKDouble()$/;"	f	class:OpenBabel::OBBond
IsKSingle	bond.cpp	/^  bool OBBond::IsKSingle()$/;"	f	class:OpenBabel::OBBond
IsKTriple	bond.cpp	/^  bool OBBond::IsKTriple()$/;"	f	class:OpenBabel::OBBond
IsLast	obconversion.cpp	/^  bool OBConversion::IsLast()$/;"	f	class:OpenBabel::OBConversion
IsMember	ring.cpp	/^  bool OBRing::IsMember(OBAtom *a)$/;"	f	class:OpenBabel::OBRing
IsMember	ring.cpp	/^  bool OBRing::IsMember(OBBond *b)$/;"	f	class:OpenBabel::OBRing
IsMetal	atom.cpp	/^  bool OBAtom::IsMetal()$/;"	f	class:OpenBabel::OBAtom
IsNan	obutil.cpp	/^  bool IsNan(const double &a)$/;"	f	namespace:OpenBabel
IsNear	obutil.cpp	/^  bool IsNear(const double &a, const double &b, const double epsilon)$/;"	f	namespace:OpenBabel
IsNearZero	obutil.cpp	/^  bool IsNearZero(const double &a, const double epsilon)$/;"	f	namespace:OpenBabel
IsNitroOxygen	atom.cpp	/^  bool OBAtom::IsNitroOxygen()$/;"	f	class:OpenBabel::OBAtom
IsNonPolarHydrogen	atom.cpp	/^  bool OBAtom::IsNonPolarHydrogen()$/;"	f	class:OpenBabel::OBAtom
IsNotCorH	atom.cpp	/^  bool OBAtom::IsNotCorH()$/;"	f	class:OpenBabel::OBAtom
IsOdd	rand.cpp	50;"	d	file:
IsOddPrime	rand.cpp	/^  static int IsOddPrime( unsigned int x )$/;"	f	namespace:OpenBabel
IsOneFour	atom.cpp	/^  bool OBAtom::IsOneFour(OBAtom *a1)$/;"	f	class:OpenBabel::OBAtom
IsOneThree	atom.cpp	/^  bool OBAtom::IsOneThree(OBAtom *a1)$/;"	f	class:OpenBabel::OBAtom
IsOption	obconversion.cpp	/^  const char* OBConversion::IsOption(const char* opt, Option_type opttyp)$/;"	f	class:OpenBabel::OBConversion
IsPhosphateOxygen	atom.cpp	/^  bool OBAtom::IsPhosphateOxygen()$/;"	f	class:OpenBabel::OBAtom
IsPolarHydrogen	atom.cpp	/^  bool OBAtom::IsPolarHydrogen()$/;"	f	class:OpenBabel::OBAtom
IsPrimaryAmide	bond.cpp	/^   bool OBBond::IsPrimaryAmide()$/;"	f	class:OpenBabel::OBBond
IsPrime	rand.cpp	53;"	d	file:
IsProtonRotor	generic.cpp	/^  bool OBTorsion::IsProtonRotor()$/;"	f	class:OpenBabel::OBTorsion
IsResidueType	residue.cpp	/^  bool OBResidue::IsResidueType(int restype) const$/;"	f	class:OpenBabel::OBResidue
IsRotor	bond.cpp	/^  bool OBBond::IsRotor(bool includeRingBonds)$/;"	f	class:OpenBabel::OBBond
IsSecondaryAmide	bond.cpp	/^   bool OBBond::IsSecondaryAmide()$/;"	f	class:OpenBabel::OBBond
IsSetupNeeded	forcefield.cpp	/^  bool OBForceField::IsSetupNeeded(OBMol &mol)$/;"	f	class:OpenBabel::OBForceField
IsSingle	bond.cpp	/^  bool OBBond::IsSingle()$/;"	f	class:OpenBabel::OBBond
IsSpiroAtom	builder.cpp	/^  bool OBBuilder::IsSpiroAtom(unsigned long atomId, OBMol &mol)$/;"	f	class:OpenBabel::OBBuilder
IsSulfateOxygen	atom.cpp	/^  bool OBAtom::IsSulfateOxygen()$/;"	f	class:OpenBabel::OBAtom
IsSulfoneOxygen	atom.cpp	/^  static bool IsSulfoneOxygen(OBAtom* atm)$/;"	f	namespace:OpenBabel
IsSuppressibleHydrogen	mol.cpp	/^  static bool IsSuppressibleHydrogen(OBAtom *atom, OBAtomClassData *pac)$/;"	f	namespace:OpenBabel
IsTertiaryAmide	bond.cpp	/^   bool OBBond::IsTertiaryAmide()$/;"	f	class:OpenBabel::OBBond
IsTriple	bond.cpp	/^  bool OBBond::IsTriple()$/;"	f	class:OpenBabel::OBBond
IsUniqueKey	conformersearch.cpp	/^  bool OBConformerSearch::IsUniqueKey(const RotorKeys &keys, const RotorKey &key) const$/;"	f	class:OpenBabel::OBConformerSearch
IsXFixed	forcefield.cpp	/^  bool OBFFConstraints::IsXFixed(int index)$/;"	f	class:OpenBabel::OBFFConstraints
IsYFixed	forcefield.cpp	/^  bool OBFFConstraints::IsYFixed(int index)$/;"	f	class:OpenBabel::OBFFConstraints
IsZFixed	forcefield.cpp	/^  bool OBFFConstraints::IsZFixed(int index)$/;"	f	class:OpenBabel::OBFFConstraints
IsZero	obutil.cpp	768;"	d	file:
Istype	patty.cpp	/^  int patty::Istype(const std::string &type)$/;"	f	class:OpenBabel::patty
Iterate	graphsym.cpp	/^  int OBGraphSymPrivate::Iterate(vector<unsigned int> &symClasses)$/;"	f	class:OpenBabel::OBGraphSymPrivate
KBOSum	atom.cpp	/^  unsigned int OBAtom::KBOSum() const$/;"	f	class:OpenBabel::OBAtom
KekulePropagate	mol.cpp	/^  static bool KekulePropagate(OBAtom *atom,vector<int> &visit,vector<int> &ival,int depth)$/;"	f	namespace:OpenBabel
Kekulize	kekulize.cpp	/^  namespace Kekulize {$/;"	n	namespace:OpenBabel	file:
Kekulize	mol.cpp	/^  bool OBMol::Kekulize()$/;"	f	class:OpenBabel::OBMol
LENGTH_LIMIT	strncasecmp.c	22;"	d	file:
LENGTH_LIMIT_EXPR	strncasecmp.c	27;"	d	file:
LENGTH_LIMIT_EXPR	strncasecmp.c	31;"	d	file:
LFSR	confsearch.cpp	/^  LFSR::LFSR(unsigned int range, unsigned int start = 1): _range(range), _lfsr(start)$/;"	f	class:OpenBabel::LFSR
LFSR	confsearch.cpp	/^  class LFSR$/;"	c	namespace:OpenBabel	file:
LIMIT	generic.cpp	383;"	d	file:
LIMIT	generic.cpp	390;"	d	file:
LINUX_COMPATIBLE	snprintf.c	317;"	d	file:
LabelFragments	canon.cpp	/^    static void LabelFragments(OBAtom *current, std::vector<OBAtom*> &nbrs, unsigned int label, Timeout &timeout, FullCode &bestCode, State &state)$/;"	f	struct:OpenBabel::CanonicalLabelsImpl
LeadingZeros	rand.cpp	/^  static int LeadingZeros( unsigned int x )$/;"	f	namespace:OpenBabel
Level	tautomer.cpp	/^    struct Level $/;"	s	struct:OpenBabel::TautomerImpl	file:
LewisAcidBaseCounts	atom.cpp	/^  pair<int, int> OBAtom::LewisAcidBaseCounts() const$/;"	f	class:OpenBabel::OBAtom
LineSearch	forcefield.cpp	/^  double OBForceField::LineSearch(double *currentCoords, double *direction)$/;"	f	class:OpenBabel::OBForceField
LineSearch	forcefield.cpp	/^  vector3 OBForceField::LineSearch(OBAtom *atom, vector3 &direction)$/;"	f	class:OpenBabel::OBForceField
LineSearchTakeStep	forcefield.cpp	/^  void OBForceField::LineSearchTakeStep(double* origCoords, double *direction, double step)$/;"	f	class:OpenBabel::OBForceField
List	plugin.cpp	/^void OBPlugin::List(const char* PluginID, const char* param, ostream* os)$/;"	f	class:OpenBabel::OBPlugin
ListAsString	plugin.cpp	/^string OBPlugin::ListAsString(const char* PluginID, const char* param)$/;"	f	class:OpenBabel::OBPlugin
ListAsVector	plugin.cpp	/^bool OBPlugin::ListAsVector(const char* PluginID, const char* param, vector<string>& vlist)$/;"	f	class:OpenBabel::OBPlugin
LoPart	rand.cpp	56;"	d	file:
LoadAllPlugins	plugin.cpp	/^void OBPlugin::LoadAllPlugins()$/;"	f	class:OpenBabel::OBPlugin
LoadAlphaOrbitals	generic.cpp	/^  void OBOrbitalData::LoadAlphaOrbitals(std::vector<double> energies, std::vector<std::string> symmetries, int alphaHOMO)$/;"	f	class:OpenBabel::OBOrbitalData
LoadBetaOrbitals	generic.cpp	/^  void OBOrbitalData::LoadBetaOrbitals(std::vector<double> energies, std::vector<std::string> symmetries, int betaHOMO)$/;"	f	class:OpenBabel::OBOrbitalData
LoadClosedShellOrbitals	generic.cpp	/^  void OBOrbitalData::LoadClosedShellOrbitals(std::vector<double> energies, std::vector<std::string> symmetries, int alphaHOMO)$/;"	f	class:OpenBabel::OBOrbitalData
LoadFile	alias.cpp	/^bool AliasData::LoadFile(SmartsTable& smtable)$/;"	f	class:OpenBabel::AliasData
LoadFile	alias.cpp	/^bool AliasData::LoadFile(SuperAtomTable& table)$/;"	f	class:OpenBabel::AliasData
LoadFragments	builder.cpp	/^  void OBBuilder::LoadFragments()  {$/;"	f	class:OpenBabel::OBBuilder
LookupBO	data.cpp	/^  int OBResidueData::LookupBO(const string &s)$/;"	f	class:OpenBabel::OBResidueData
LookupBO	data.cpp	/^  int OBResidueData::LookupBO(const string &s1, const string &s2)$/;"	f	class:OpenBabel::OBResidueData
LookupType	data.cpp	/^  bool OBResidueData::LookupType(const string &atmid,string &type,int &hyb)$/;"	f	class:OpenBabel::OBResidueData
LowBit	bitvec.cpp	68;"	d	file:
MAXFACT	rand.cpp	60;"	d	file:
MAXNUCLEIC	chains.cpp	60;"	d	file:
MAXPARAM	pointgroup.cpp	37;"	d	file:
MAXPEPTIDE	chains.cpp	59;"	d	file:
MAXPRIMES	rand.cpp	64;"	d	file:
MAX_DEPTH	kekulize.cpp	30;"	d	file:
MAX_IDENTITY_NODES	canon.cpp	39;"	d	file:
MAX_SWEEPS	obutil.cpp	889;"	d	file:
MAX_TIME	kekulize.cpp	27;"	d	file:
METALL_ATOM	mcdlutil.cpp	148;"	d	file:
M_PI	pointgroup.cpp	33;"	d	file:
MakeCombinedMolecule	obmolecformat.cpp	/^  OBMol* OBMoleculeFormat::MakeCombinedMolecule(OBMol* pFirst, OBMol* pSecond)$/;"	f	class:OpenBabel::OBMoleculeFormat
MakeDativeBonds	mol.cpp	/^  bool OBMol::MakeDativeBonds()$/;"	f	class:OpenBabel::OBMol
MakeSelection	conformersearch.cpp	/^  double OBConformerSearch::MakeSelection()$/;"	f	class:OpenBabel::OBConformerSearch
MapAll	isomorphism.cpp	/^      void MapAll(const OBMol *queried, Mappings &maps, const OBBitVec &mask, std::size_t maxMemory)$/;"	f	class:OpenBabel::VF2Mapper
MapAllFunctor	isomorphism.cpp	/^      MapAllFunctor(OBIsomorphismMapper::Mappings &maps, std::size_t maxMemory)$/;"	f	class:OpenBabel::MapAllFunctor
MapAllFunctor	isomorphism.cpp	/^  class MapAllFunctor : public OBIsomorphismMapper::Functor$/;"	c	namespace:OpenBabel	file:
MapFirst	isomorphism.cpp	/^      void MapFirst(const OBMol *queried, Mapping &map, const OBBitVec &mask)$/;"	f	class:OpenBabel::VF2Mapper
MapGeneric	isomorphism.cpp	/^      void MapGeneric(Functor &functor, const OBMol *queried, const OBBitVec &mask)$/;"	f	class:OpenBabel::VF2Mapper
MapNext	isomorphism.cpp	/^      void MapNext(State &state, OBQueryAtom *queryAtom, OBAtom *queriedAtom)$/;"	f	class:OpenBabel::VF2Mapper
MapUnique	isomorphism.cpp	/^      void MapUnique(const OBMol *queried, Mappings &maps, const OBBitVec &mask)$/;"	f	class:OpenBabel::VF2Mapper
MarkGrowBonds	parsmart.cpp	/^  static void MarkGrowBonds(Pattern *pat)$/;"	f	namespace:OpenBabel
Match	parsmart.cpp	/^  bool OBSmartsPattern::Match(OBMol &mol, std::vector<std::vector<int> > & mlist,$/;"	f	class:OpenBabel::OBSmartsPattern
Match	parsmart.cpp	/^  bool OBSmartsPattern::Match(OBMol &mol,bool single)$/;"	f	class:OpenBabel::OBSmartsPattern
Match	parsmart.cpp	/^  void OBSSMatch::Match(std::vector<std::vector<int> > &mlist,int bidx)$/;"	f	class:OpenBabel::OBSSMatch
Match2Constraints	chains.cpp	/^  bool OBChainsParser::Match2Constraints(Template *tmpl, OBAtom *na, OBAtom *nb)$/;"	f	class:OpenBabel::OBChainsParser
Match3Constraints	chains.cpp	/^  bool OBChainsParser::Match3Constraints(Template *tmpl, OBAtom *na, OBAtom *nb, OBAtom *nc)$/;"	f	class:OpenBabel::OBChainsParser
Match4Constraints	chains.cpp	/^  bool OBChainsParser::Match4Constraints(Template *tmpl, OBAtom *na, OBAtom *nb, OBAtom *nc, OBAtom *nd)$/;"	f	class:OpenBabel::OBChainsParser
MatchConstraint	chains.cpp	/^  bool OBChainsParser::MatchConstraint(OBAtom *atom, int mask)$/;"	f	class:OpenBabel::OBChainsParser
MatchPairData	descriptor.cpp	/^  bool OBDescriptor::MatchPairData(OBBase* pOb, string& s)$/;"	f	class:OpenBabel::OBDescriptor
Matches	isomorphism.cpp	/^      bool Matches(const OBAtom *atom) const$/;"	f	class:OpenBabel::OBAutomorphismQueryAtom
MatchesSMARTS	atom.cpp	/^  bool OBAtom::MatchesSMARTS(const char *pattern)$/;"	f	class:OpenBabel::OBAtom
MaxAxisOrder	pointgroup.cpp	/^    int                    MaxAxisOrder          ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
MaxOptCycles	pointgroup.cpp	/^    int                    MaxOptCycles          ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
MaxOptStep	pointgroup.cpp	/^    double                 MaxOptStep            ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
MemberOfRingCount	atom.cpp	/^  unsigned int OBAtom::MemberOfRingCount() const$/;"	f	class:OpenBabel::OBAtom
MemberOfRingSize	atom.cpp	/^  unsigned int OBAtom::MemberOfRingSize() const$/;"	f	class:OpenBabel::OBAtom
MinOptStep	pointgroup.cpp	/^    double                 MinOptStep            ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
MolArray	obmolecformat.cpp	/^  std::vector<OBMol> OBMoleculeFormat::MolArray;$/;"	m	class:OpenBabel::OBMoleculeFormat	file:
MolecularDynamicsTakeNSteps	forcefield.cpp	/^  void OBForceField::MolecularDynamicsTakeNSteps(int n, double T, double timestep, int method)$/;"	f	class:OpenBabel::OBForceField
MolecularPlane	pointgroup.cpp	/^    SYMMETRY_ELEMENT *     MolecularPlane        ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
MonOpStruct	chains.cpp	/^  } MonOpStruct;$/;"	t	namespace:OpenBabel	typeref:struct:OpenBabel::__anon4	file:
MonoAtom	chains.cpp	/^  static MonoAtomType MonoAtom[MaxMonoAtom];$/;"	m	namespace:OpenBabel	file:
MonoAtomCount	chains.cpp	/^  static int MonoAtomCount;$/;"	m	namespace:OpenBabel	file:
MonoAtomType	chains.cpp	/^  } MonoAtomType;$/;"	t	namespace:OpenBabel	typeref:struct:OpenBabel::__anon2	file:
MonoBond	chains.cpp	/^  static MonoBondType MonoBond[MaxMonoBond];$/;"	m	namespace:OpenBabel	file:
MonoBondCount	chains.cpp	/^  static int MonoBondCount;$/;"	m	namespace:OpenBabel	file:
MonoBondType	chains.cpp	/^  } MonoBondType;$/;"	t	namespace:OpenBabel	typeref:struct:OpenBabel::__anon3	file:
NALKALYATOMS	mcdlutil.cpp	117;"	d	file:
NALKALYEARTHATOMS	mcdlutil.cpp	119;"	d	file:
NAROMMAX	mcdlutil.cpp	143;"	d	file:
NBONDTYPES	mcdlutil.cpp	326;"	d	file:
NCHROMIUMATOMS	mcdlutil.cpp	127;"	d	file:
NCOPPERATOMS	mcdlutil.cpp	135;"	d	file:
NDATABASE_MOLECULES	mcdlutil.cpp	173;"	d	file:
NEED_SNPRINTF_ONLY	snprintf.c	293;"	d	file:
NEU	data_utilities.cpp	99;"	d	file:
NEXACTATOMS	mcdlutil.cpp	115;"	d	file:
NHALOGENS	mcdlutil.cpp	141;"	d	file:
NHEAVY_METALS	mcdlutil.cpp	145;"	d	file:
NHETERO	mcdlutil.cpp	142;"	d	file:
NLIGHT_METALS	mcdlutil.cpp	144;"	d	file:
NLIKEFEATOMS	mcdlutil.cpp	131;"	d	file:
NMANGANESEATOMS	mcdlutil.cpp	129;"	d	file:
NMETALS	mcdlutil.cpp	140;"	d	file:
NOOTHER_MASK	mcdlutil.cpp	/^    static int const NOOTHER_MASK=1;$/;"	m	class:OpenBabel::TEditedMolecule	file:
NOT_IN_RINGS	kekulize.cpp	47;"	d	file:
NPLATINUMATOMS	mcdlutil.cpp	133;"	d	file:
NTITANATOMS	mcdlutil.cpp	123;"	d	file:
NTRIVALENTATOMS	mcdlutil.cpp	121;"	d	file:
NUCLEOMAX	chains.cpp	67;"	d	file:
NVANADIUMATOMS	mcdlutil.cpp	125;"	d	file:
NZINKATOMS	mcdlutil.cpp	137;"	d	file:
NewAtom	mol.cpp	/^  OBAtom *OBMol::NewAtom()$/;"	f	class:OpenBabel::OBMol
NewAtom	mol.cpp	/^  OBAtom *OBMol::NewAtom(unsigned long id)$/;"	f	class:OpenBabel::OBMol
NewBond	mol.cpp	/^  OBBond *OBMol::NewBond()$/;"	f	class:OpenBabel::OBMol
NewBond	mol.cpp	/^  OBBond *OBMol::NewBond(unsigned long id)$/;"	f	class:OpenBabel::OBMol
NewExtension	obutil.cpp	/^  string NewExtension(string &src,char *ext)$/;"	f	namespace:OpenBabel
NewPerceiveKekuleBonds	kekulize.cpp	/^  void OBMol::NewPerceiveKekuleBonds()$/;"	f	class:OpenBabel::OBMol
NewResidue	mol.cpp	/^  OBResidue *OBMol::NewResidue()$/;"	f	class:OpenBabel::OBMol
Newton2NumLineSearch	forcefield.cpp	/^  double OBForceField::Newton2NumLineSearch(double *direction)$/;"	f	class:OpenBabel::OBForceField
NextAtom	mol.cpp	/^  OBAtom *OBMol::NextAtom(OBAtomIterator &i)$/;"	f	class:OpenBabel::OBMol
NextAtom	residue.cpp	/^  OBAtom *OBResidue::NextAtom(vector<OBAtom*>::iterator &i)$/;"	f	class:OpenBabel::OBResidue
NextBit	bitvec.cpp	/^  int OBBitVec::NextBit(int last_bit_offset) const$/;"	f	class:OpenBabel::OBBitVec
NextBond	atom.cpp	/^  OBBond *OBAtom::NextBond(OBBondIterator &i)$/;"	f	class:OpenBabel::OBAtom
NextBond	mol.cpp	/^  OBBond *OBMol::NextBond(OBBondIterator &i)$/;"	f	class:OpenBabel::OBMol
NextCandidate	isomorphism.cpp	/^      Candidate NextCandidate(State &state, const Candidate &lastCandidate)$/;"	f	class:OpenBabel::VF2Mapper
NextFloat	rand.cpp	/^  double OBRandom::NextFloat()$/;"	f	class:OpenBabel::OBRandom
NextGeneration	conformersearch.cpp	/^  void OBConformerSearch::NextGeneration()$/;"	f	class:OpenBabel::OBConformerSearch
NextInt	rand.cpp	/^  int OBRandom::NextInt()$/;"	f	class:OpenBabel::OBRandom
NextNbrAtom	atom.cpp	/^  OBAtom *OBAtom::NextNbrAtom(OBBondIterator &i)$/;"	f	class:OpenBabel::OBAtom
NextRing	generic.cpp	/^  OBRing *OBRingData::NextRing(std::vector<OBRing*>::iterator &i)$/;"	f	class:OpenBabel::OBRingData
Nitrogen	tautomer.cpp	/^      Nitrogen = 7,$/;"	e	enum:OpenBabel::TautomerImpl::AtomNumber	file:
NoSymmetryClass	graphsym.cpp	/^  const unsigned int OBGraphSym::NoSymmetryClass = 0x7FFFFFFF;$/;"	m	class:OpenBabel::OBGraphSym	file:
NormalAxes	pointgroup.cpp	/^    SYMMETRY_ELEMENT **    NormalAxes            ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
NormalAxesCount	pointgroup.cpp	/^    int                    NormalAxesCount       ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
NormalAxesCounts	pointgroup.cpp	/^    int *                  NormalAxesCounts      ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
NotAtomExpr	parsmart.cpp	/^  static AtomExpr *NotAtomExpr( AtomExpr *expr )$/;"	f	namespace:OpenBabel
Nucleotide	chains.cpp	/^  static Template Nucleotide[MAXNUCLEIC] = {$/;"	m	namespace:OpenBabel	file:
Nucleotides	chains.cpp	/^  static ResidType Nucleotides[NUCLEOMAX] = {$/;"	m	namespace:OpenBabel	file:
NumHvyAtoms	mol.cpp	/^  unsigned int OBMol::NumHvyAtoms()$/;"	f	class:OpenBabel::OBMol
NumInputObjects	obconversion.cpp	/^  int OBConversion::NumInputObjects()$/;"	f	class:OpenBabel::OBConversion
NumRotors	mol.cpp	/^  unsigned int OBMol::NumRotors(bool includeRingBonds)$/;"	f	class:OpenBabel::OBMol
NumericalDerivative	forcefield.cpp	/^  vector3 OBForceField::NumericalDerivative(OBAtom *atom, int terms)$/;"	f	class:OpenBabel::OBForceField
NumericalSecondDerivative	forcefield.cpp	/^  vector3 OBForceField::NumericalSecondDerivative(OBAtom *atom, int terms)$/;"	f	class:OpenBabel::OBForceField
OBAngle	generic.cpp	/^  OBAngle::OBAngle():$/;"	f	class:OpenBabel::OBAngle
OBAngle	generic.cpp	/^  OBAngle::OBAngle(OBAtom *vertex,OBAtom *a,OBAtom *b):$/;"	f	class:OpenBabel::OBAngle
OBAngle	generic.cpp	/^  OBAngle::OBAngle(const OBAngle &src):$/;"	f	class:OpenBabel::OBAngle
OBAngleData	generic.cpp	/^  OBAngleData::OBAngleData()$/;"	f	class:OpenBabel::OBAngleData
OBAngleData	generic.cpp	/^  OBAngleData::OBAngleData(const OBAngleData &src)$/;"	f	class:OpenBabel::OBAngleData
OBAromaticTyper	typer.cpp	/^  OBAromaticTyper::OBAromaticTyper()$/;"	f	class:OpenBabel::OBAromaticTyper
OBAtom	atom.cpp	/^  OBAtom::OBAtom()$/;"	f	class:OpenBabel::OBAtom
OBAtomAtomIter	obiter.cpp	/^  OBAtomAtomIter::OBAtomAtomIter(OBAtom &atm)$/;"	f	class:OpenBabel::OBAtomAtomIter
OBAtomAtomIter	obiter.cpp	/^  OBAtomAtomIter::OBAtomAtomIter(OBAtom *atm)$/;"	f	class:OpenBabel::OBAtomAtomIter
OBAtomAtomIter	obiter.cpp	/^  OBAtomAtomIter::OBAtomAtomIter(const OBAtomAtomIter &ai)$/;"	f	class:OpenBabel::OBAtomAtomIter
OBAtomBondIter	obiter.cpp	/^  OBAtomBondIter::OBAtomBondIter(OBAtom &atm)$/;"	f	class:OpenBabel::OBAtomBondIter
OBAtomBondIter	obiter.cpp	/^  OBAtomBondIter::OBAtomBondIter(OBAtom *atm)$/;"	f	class:OpenBabel::OBAtomBondIter
OBAtomBondIter	obiter.cpp	/^  OBAtomBondIter::OBAtomBondIter(const OBAtomBondIter &bi)$/;"	f	class:OpenBabel::OBAtomBondIter
OBAtomIncrement	mol.cpp	1629;"	d	file:
OBAtomIncrement	mol.cpp	1638;"	d	file:
OBAtomIncrement	mol.cpp	1759;"	d	file:
OBAtomIncrement	mol.cpp	1768;"	d	file:
OBAtomTyper	typer.cpp	/^  OBAtomTyper::OBAtomTyper()$/;"	f	class:OpenBabel::OBAtomTyper
OBAtomicHeatOfFormationTable	data.cpp	/^  OBAtomicHeatOfFormationTable::OBAtomicHeatOfFormationTable(void)$/;"	f	class:OpenBabel::OBAtomicHeatOfFormationTable
OBAutomorphismQueryAtom	isomorphism.cpp	/^      OBAutomorphismQueryAtom(unsigned int _symClass, const std::vector<unsigned int> &_symClasses)$/;"	f	class:OpenBabel::OBAutomorphismQueryAtom
OBAutomorphismQueryAtom	isomorphism.cpp	/^  class OBAutomorphismQueryAtom : public OBQueryAtom$/;"	c	namespace:OpenBabel	file:
OBBond	bond.cpp	/^  OBBond::OBBond() \/*: d(new OBBondPrivate)*\/$/;"	f	class:OpenBabel::OBBond
OBBondIncrement	mol.cpp	1710;"	d	file:
OBBondIncrement	mol.cpp	1718;"	d	file:
OBBondIncrement	mol.cpp	3064;"	d	file:
OBBondIncrement	mol.cpp	3072;"	d	file:
OBBondPrivate	bond.cpp	/^      OBBondPrivate() {}$/;"	f	class:OpenBabel::OBBondPrivate
OBBondPrivate	bond.cpp	/^  class OBBondPrivate$/;"	c	namespace:OpenBabel	file:
OBBondTyper	bondtyper.cpp	/^  OBBondTyper::OBBondTyper()$/;"	f	class:OpenBabel::OBBondTyper
OBChainsParser	chains.cpp	/^  OBChainsParser::OBChainsParser(void)$/;"	f	class:OpenBabel::OBChainsParser
OBChiralData	generic.cpp	/^  OBChiralData::OBChiralData()$/;"	f	class:OpenBabel::OBChiralData
OBChiralData	generic.cpp	/^  OBChiralData::OBChiralData(const OBChiralData &src)$/;"	f	class:OpenBabel::OBChiralData
OBCommentData	generic.cpp	/^  OBCommentData::OBCommentData():$/;"	f	class:OpenBabel::OBCommentData
OBCommentData	generic.cpp	/^  OBCommentData::OBCommentData(const OBCommentData &src) :$/;"	f	class:OpenBabel::OBCommentData
OBCompareInt	obutil.cpp	/^  bool OBCompareInt(const int &a,const int &b)$/;"	f	namespace:OpenBabel
OBComparePairFirst	mol.cpp	/^  static bool OBComparePairFirst(const pair<OBAtom*,unsigned int> &a,const pair<OBAtom*,unsigned int> &b)$/;"	f	namespace:OpenBabel
OBComparePairSecond	mol.cpp	/^  static bool OBComparePairSecond(const pair<OBAtom*,unsigned int> &a,const pair<OBAtom*,unsigned int> &b)$/;"	f	namespace:OpenBabel
OBCompareUnsigned	obutil.cpp	/^  bool OBCompareUnsigned(const unsigned int &a,const unsigned int &b)$/;"	f	namespace:OpenBabel
OBConformerData	generic.cpp	/^  OBConformerData::OBConformerData() :$/;"	f	class:OpenBabel::OBConformerData
OBConformerData	generic.cpp	/^  OBConformerData::OBConformerData(const OBConformerData &src) :$/;"	f	class:OpenBabel::OBConformerData
OBConformerSearch	conformersearch.cpp	/^  OBConformerSearch::OBConformerSearch()$/;"	f	class:OpenBabel::OBConformerSearch
OBConversion	obconversion.cpp	/^  OBConversion::OBConversion(const OBConversion& o)$/;"	f	class:OpenBabel::OBConversion
OBConversion	obconversion.cpp	/^  OBConversion::OBConversion(istream* is, ostream* os) :$/;"	f	class:OpenBabel::OBConversion
OBConversion	obconversion.cpp	/^  OBConversion::OBConversion(string infile, string outfile):$/;"	f	class:OpenBabel::OBConversion
OBDistanceGeometry	distgeom.cpp	/^  OBDistanceGeometry::OBDistanceGeometry(): _d(NULL) {}$/;"	f	class:OpenBabel::OBDistanceGeometry
OBDistanceGeometry	distgeom.cpp	/^  OBDistanceGeometry::OBDistanceGeometry(const OBMol &mol, bool useCurrentGeometry): _d(NULL)$/;"	f	class:OpenBabel::OBDistanceGeometry
OBDiversePoses	confsearch.cpp	/^  OBDiversePoses::OBDiversePoses(const OBMol &ref, double RMSD, bool percise):$/;"	f	class:OpenBabel::OBDiversePoses
OBDiversePoses	confsearch.cpp	/^  class OBDiversePoses {$/;"	c	namespace:OpenBabel	file:
OBElementTable	data.cpp	/^  OBElementTable::OBElementTable()$/;"	f	class:OpenBabel::OBElementTable
OBError	oberror.cpp	/^  OBError::OBError( const string &method,$/;"	f	class:OpenBabel::OBError
OBExternalBond	generic.cpp	/^  OBExternalBond::OBExternalBond(OBAtom *atom,OBBond *bond,int idx):$/;"	f	class:OpenBabel::OBExternalBond
OBExternalBond	generic.cpp	/^  OBExternalBond::OBExternalBond(const OBExternalBond &src):$/;"	f	class:OpenBabel::OBExternalBond
OBExternalBondData	generic.cpp	/^  OBExternalBondData::OBExternalBondData():$/;"	f	class:OpenBabel::OBExternalBondData
OBFFConstraints	forcefield.cpp	/^  OBFFConstraints::OBFFConstraints()$/;"	f	class:OpenBabel::OBFFConstraints
OBGenericData	generic.cpp	/^  OBGenericData::OBGenericData(const std::string attr, const unsigned int type,$/;"	f	class:OpenBabel::OBGenericData
OBGraphSym	graphsym.cpp	/^  OBGraphSym::OBGraphSym(OBMol* pmol, const OBBitVec* frag_atoms) : d(new OBGraphSymPrivate)$/;"	f	class:OpenBabel::OBGraphSym
OBGraphSymPrivate	graphsym.cpp	/^  class OBGraphSymPrivate$/;"	c	namespace:OpenBabel	file:
OBGridData	griddata.cpp	/^  OBGridData::OBGridData() : OBGenericData("GridData", OBGenericDataType::GridData),$/;"	f	class:OpenBabel::OBGridData
OBIsomorphismMapper	isomorphism.cpp	/^  OBIsomorphismMapper::OBIsomorphismMapper(OBQuery *query) : m_query(query), m_timeout(60)$/;"	f	class:OpenBabel::OBIsomorphismMapper
OBIsotopeTable	data.cpp	/^  OBIsotopeTable::OBIsotopeTable()$/;"	f	class:OpenBabel::OBIsotopeTable
OBLocale	locale.cpp	/^  OBLocale::OBLocale()$/;"	f	class:OpenBabel::OBLocale
OBLocalePrivate	locale.cpp	/^    OBLocalePrivate(): counter(0)$/;"	f	class:OpenBabel::OBLocalePrivate
OBLocalePrivate	locale.cpp	/^  class OBLocalePrivate {$/;"	c	namespace:OpenBabel	file:
OBMessageHandler	oberror.cpp	/^  OBMessageHandler::OBMessageHandler() :$/;"	f	class:OpenBabel::OBMessageHandler
OBMol	mol.cpp	/^  OBMol::OBMol()$/;"	f	class:OpenBabel::OBMol
OBMol	mol.cpp	/^  OBMol::OBMol(const OBMol &mol) : OBBase(mol)$/;"	f	class:OpenBabel::OBMol
OBMolAngleIter	obiter.cpp	/^  OBMolAngleIter::OBMolAngleIter(OBMol &mol)$/;"	f	class:OpenBabel::OBMolAngleIter
OBMolAngleIter	obiter.cpp	/^  OBMolAngleIter::OBMolAngleIter(OBMol *mol)$/;"	f	class:OpenBabel::OBMolAngleIter
OBMolAngleIter	obiter.cpp	/^  OBMolAngleIter::OBMolAngleIter(const OBMolAngleIter &ai)$/;"	f	class:OpenBabel::OBMolAngleIter
OBMolAtomBFSIter	obiter.cpp	/^  OBMolAtomBFSIter::OBMolAtomBFSIter(OBMol &mol, int StartIndex):$/;"	f	class:OpenBabel::OBMolAtomBFSIter
OBMolAtomBFSIter	obiter.cpp	/^  OBMolAtomBFSIter::OBMolAtomBFSIter(OBMol *mol, int StartIndex):$/;"	f	class:OpenBabel::OBMolAtomBFSIter
OBMolAtomBFSIter	obiter.cpp	/^  OBMolAtomBFSIter::OBMolAtomBFSIter(const OBMolAtomBFSIter &ai)$/;"	f	class:OpenBabel::OBMolAtomBFSIter
OBMolAtomDFSIter	obiter.cpp	/^  OBMolAtomDFSIter::OBMolAtomDFSIter(OBMol &mol, int StartIndex):$/;"	f	class:OpenBabel::OBMolAtomDFSIter
OBMolAtomDFSIter	obiter.cpp	/^  OBMolAtomDFSIter::OBMolAtomDFSIter(OBMol *mol, int StartIndex):$/;"	f	class:OpenBabel::OBMolAtomDFSIter
OBMolAtomDFSIter	obiter.cpp	/^  OBMolAtomDFSIter::OBMolAtomDFSIter(const OBMolAtomDFSIter &ai)$/;"	f	class:OpenBabel::OBMolAtomDFSIter
OBMolAtomIter	obiter.cpp	/^  OBMolAtomIter::OBMolAtomIter(OBMol &mol)$/;"	f	class:OpenBabel::OBMolAtomIter
OBMolAtomIter	obiter.cpp	/^  OBMolAtomIter::OBMolAtomIter(OBMol *mol)$/;"	f	class:OpenBabel::OBMolAtomIter
OBMolAtomIter	obiter.cpp	/^  OBMolAtomIter::OBMolAtomIter(const OBMolAtomIter &ai)$/;"	f	class:OpenBabel::OBMolAtomIter
OBMolBondBFSIter	obiter.cpp	/^  OBMolBondBFSIter::OBMolBondBFSIter(OBMol &mol, int StartIndex):$/;"	f	class:OpenBabel::OBMolBondBFSIter
OBMolBondBFSIter	obiter.cpp	/^  OBMolBondBFSIter::OBMolBondBFSIter(OBMol *mol, int StartIndex):$/;"	f	class:OpenBabel::OBMolBondBFSIter
OBMolBondBFSIter	obiter.cpp	/^  OBMolBondBFSIter::OBMolBondBFSIter(const OBMolBondBFSIter &ai)$/;"	f	class:OpenBabel::OBMolBondBFSIter
OBMolBondIter	obiter.cpp	/^  OBMolBondIter::OBMolBondIter(OBMol &mol)$/;"	f	class:OpenBabel::OBMolBondIter
OBMolBondIter	obiter.cpp	/^  OBMolBondIter::OBMolBondIter(OBMol *mol)$/;"	f	class:OpenBabel::OBMolBondIter
OBMolBondIter	obiter.cpp	/^  OBMolBondIter::OBMolBondIter(const OBMolBondIter &bi)$/;"	f	class:OpenBabel::OBMolBondIter
OBMolPairIter	obiter.cpp	/^  OBMolPairIter::OBMolPairIter(OBMol &mol)$/;"	f	class:OpenBabel::OBMolPairIter
OBMolPairIter	obiter.cpp	/^  OBMolPairIter::OBMolPairIter(OBMol *mol)$/;"	f	class:OpenBabel::OBMolPairIter
OBMolPairIter	obiter.cpp	/^  OBMolPairIter::OBMolPairIter(const OBMolPairIter &ai)$/;"	f	class:OpenBabel::OBMolPairIter
OBMolRingIter	obiter.cpp	/^  OBMolRingIter::OBMolRingIter(OBMol &mol): _parent(&mol)$/;"	f	class:OpenBabel::OBMolRingIter
OBMolRingIter	obiter.cpp	/^  OBMolRingIter::OBMolRingIter(OBMol *mol): _parent(mol)$/;"	f	class:OpenBabel::OBMolRingIter
OBMolRingIter	obiter.cpp	/^  OBMolRingIter::OBMolRingIter(const OBMolRingIter &ri)$/;"	f	class:OpenBabel::OBMolRingIter
OBMolToRWMol	RDKitConv.cpp	/^RDKit::RWMol OBMolToRWMol(OpenBabel::OBMol* pOBMol)$/;"	f
OBMolTorsionIter	obiter.cpp	/^  OBMolTorsionIter::OBMolTorsionIter(OBMol &mol)$/;"	f	class:OpenBabel::OBMolTorsionIter
OBMolTorsionIter	obiter.cpp	/^  OBMolTorsionIter::OBMolTorsionIter(OBMol *mol)$/;"	f	class:OpenBabel::OBMolTorsionIter
OBMolTorsionIter	obiter.cpp	/^  OBMolTorsionIter::OBMolTorsionIter(const OBMolTorsionIter &ai)$/;"	f	class:OpenBabel::OBMolTorsionIter
OBPairData	generic.cpp	/^  OBPairData::OBPairData() :$/;"	f	class:OpenBabel::OBPairData
OBPhModel	phmodel.cpp	/^  OBPhModel::OBPhModel()$/;"	f	class:OpenBabel::OBPhModel
OBPointGroup	pointgroup.cpp	/^  OBPointGroup::OBPointGroup()$/;"	f	class:OpenBabel::OBPointGroup
OBRTree	ring.cpp	/^  OBRTree::OBRTree(OBAtom *atom,OBRTree *prv)$/;"	f	class:OpenBabel::OBRTree
OBRandom	rand.cpp	/^  OBRandom::OBRandom(bool useSysRand)$/;"	f	class:OpenBabel::OBRandom
OBReleaseVersion	base.cpp	/^  std::string OBReleaseVersion()$/;"	f	namespace:OpenBabel
OBResidue	residue.cpp	/^  OBResidue::OBResidue()$/;"	f	class:OpenBabel::OBResidue
OBResidue	residue.cpp	/^  OBResidue::OBResidue(const OBResidue &src) :$/;"	f	class:OpenBabel::OBResidue
OBResidueAtomIter	obiter.cpp	/^  OBResidueAtomIter::OBResidueAtomIter(OBResidue &res):$/;"	f	class:OpenBabel::OBResidueAtomIter
OBResidueAtomIter	obiter.cpp	/^  OBResidueAtomIter::OBResidueAtomIter(OBResidue *res):$/;"	f	class:OpenBabel::OBResidueAtomIter
OBResidueAtomIter	obiter.cpp	/^  OBResidueAtomIter::OBResidueAtomIter(const OBResidueAtomIter &ri)$/;"	f	class:OpenBabel::OBResidueAtomIter
OBResidueData	data.cpp	/^  OBResidueData::OBResidueData()$/;"	f	class:OpenBabel::OBResidueData
OBResidueIter	obiter.cpp	/^  OBResidueIter::OBResidueIter(OBMol &mol)$/;"	f	class:OpenBabel::OBResidueIter
OBResidueIter	obiter.cpp	/^  OBResidueIter::OBResidueIter(OBMol *mol)$/;"	f	class:OpenBabel::OBResidueIter
OBResidueIter	obiter.cpp	/^  OBResidueIter::OBResidueIter(const OBResidueIter &ri)$/;"	f	class:OpenBabel::OBResidueIter
OBRing	ring.cpp	/^  OBRing::OBRing(const OBRing &src)$/;"	f	class:OpenBabel::OBRing
OBRing	ring.cpp	/^  OBRing::OBRing(vector<int> &path,int size) : _path(path)$/;"	f	class:OpenBabel::OBRing
OBRingData	generic.cpp	/^  OBRingData::OBRingData() :$/;"	f	class:OpenBabel::OBRingData
OBRingData	generic.cpp	/^  OBRingData::OBRingData(const OBRingData &src)$/;"	f	class:OpenBabel::OBRingData
OBRingTyper	typer.cpp	/^  OBRingTyper::OBRingTyper()$/;"	f	class:OpenBabel::OBRingTyper
OBRotor	rotor.cpp	/^  OBRotor::OBRotor()$/;"	f	class:OpenBabel::OBRotor
OBRotorList	rotor.cpp	/^  OBRotorList::OBRotorList()$/;"	f	class:OpenBabel::OBRotorList
OBRotorRules	rotor.cpp	/^  OBRotorRules::OBRotorRules()$/;"	f	class:OpenBabel::OBRotorRules
OBSSMatch	parsmart.cpp	/^  OBSSMatch::OBSSMatch(OBMol &mol, const Pattern *pat)$/;"	f	class:OpenBabel::OBSSMatch
OBSpectrophore	spectrophore.cpp	/^OBSpectrophore::OBSpectrophore(const OBSpectrophore& s)$/;"	f	class:OpenBabel::OBSpectrophore
OBSpectrophore	spectrophore.cpp	/^OBSpectrophore::OBSpectrophore(void)$/;"	f	class:OpenBabel::OBSpectrophore
OBStericConformerFilter	conformersearch.cpp	/^  OBStericConformerFilter::OBStericConformerFilter ()$/;"	f	class:OpenBabel::OBStericConformerFilter
OBStericConformerFilter	conformersearch.cpp	/^  OBStericConformerFilter::OBStericConformerFilter (double cutoff, double vdw_factor, bool check_hydrogens)$/;"	f	class:OpenBabel::OBStericConformerFilter
OBSymmetryData	generic.cpp	/^  OBSymmetryData::OBSymmetryData():$/;"	f	class:OpenBabel::OBSymmetryData
OBSymmetryData	generic.cpp	/^  OBSymmetryData::OBSymmetryData(const OBSymmetryData &src) :$/;"	f	class:OpenBabel::OBSymmetryData
OBTorsion	generic.cpp	/^  OBTorsion::OBTorsion(OBAtom *a,OBAtom *b, OBAtom *c,OBAtom *d)$/;"	f	class:OpenBabel::OBTorsion
OBTorsion	generic.cpp	/^  OBTorsion::OBTorsion(const OBTorsion &src)$/;"	f	class:OpenBabel::OBTorsion
OBTorsionData	generic.cpp	/^  OBTorsionData::OBTorsionData()$/;"	f	class:OpenBabel::OBTorsionData
OBTorsionData	generic.cpp	/^  OBTorsionData::OBTorsionData(const OBTorsionData &src)$/;"	f	class:OpenBabel::OBTorsionData
OBTypeTable	data.cpp	/^  OBTypeTable::OBTypeTable()$/;"	f	class:OpenBabel::OBTypeTable
OBUNITCELL_CALL_CONST_OVERLOAD	generic.cpp	637;"	d	file:
OBUNITCELL_CALL_CONST_OVERLOAD_ARG	generic.cpp	642;"	d	file:
OBUnitCell	generic.cpp	/^  OBUnitCell::OBUnitCell():$/;"	f	class:OpenBabel::OBUnitCell
OBUnitCell	generic.cpp	/^  OBUnitCell::OBUnitCell(const OBUnitCell &src) :$/;"	f	class:OpenBabel::OBUnitCell
OBVirtualBond	generic.cpp	/^  OBVirtualBond::OBVirtualBond():$/;"	f	class:OpenBabel::OBVirtualBond
OBVirtualBond	generic.cpp	/^  OBVirtualBond::OBVirtualBond(int bgn,int end,int ord,int stereo):$/;"	f	class:OpenBabel::OBVirtualBond
OB_BINARY_SETWORD	rotamer.cpp	24;"	d	file:
OB_DEFAULT_DELTA	rotor.cpp	1051;"	d	file:
OB_DEFAULT_DELTA	rotor.cpp	37;"	d	file:
OB_RTREE_CUTOFF	ring.cpp	689;"	d	file:
OB_RTREE_CUTOFF	ring.cpp	714;"	d	file:
OB_TITLE_SIZE	rotamer.cpp	23;"	d	file:
ONE_OVER_SQRT3	atom.cpp	1521;"	d	file:
OS_CODE	zipstream.h	47;"	d
OS_CODE	zipstream.h	50;"	d
OS_CODE	zipstream.h	53;"	d
OneThird	obutil.cpp	772;"	d	file:
OpGenAlias	alias.cpp	/^  OpGenAlias(const char* ID) : OBOp(ID, false){};$/;"	f	class:OpenBabel::OpGenAlias
OpGenAlias	alias.cpp	/^class OpGenAlias : public OBOp$/;"	c	namespace:OpenBabel	file:
OpenAndSetFormat	obconversion.cpp	/^  bool OBConversion::OpenAndSetFormat(bool SetFormat, ifstream* is, stringstream* ss)$/;"	f	class:OpenBabel::OBConversion
OpenBabel	alias.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	atom.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	base.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	bitvec.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	bond.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	bondtyper.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	builder.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	canon.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	chains.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	chargemodel.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	chiral.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	conformersearch.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	confsearch.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	data.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	data_utilities.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	descriptor.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	distgeom.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	dlhandler_unix.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	dlhandler_win32.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	doxygen_pages.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	fingerprint.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	forcefield.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	format.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	generic.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	graphsym.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	grid.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	griddata.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	isomorphism.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	kekulize.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	locale.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	matrix.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	mcdlutil.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	mol.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	molchrg.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	obconversion.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	oberror.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	obiter.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	obmolecformat.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	obutil.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	op.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	parsmart.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	patty.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	phmodel.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	plugin.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	pointgroup.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	query.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	rand.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	residue.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	ring.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	rotamer.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	rotor.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	spectrophore.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	tautomer.cpp	/^namespace OpenBabel {$/;"	n	file:
OpenBabel	tokenst.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	transform.cpp	/^namespace OpenBabel$/;"	n	file:
OpenBabel	typer.cpp	/^namespace OpenBabel$/;"	n	file:
OpenDatafile	tokenst.cpp	/^  std::string OpenDatafile(std::ifstream& ifs, const std::string& filename,$/;"	f	namespace:OpenBabel
OpenInAndOutFiles	obconversion.cpp	/^  bool OBConversion::OpenInAndOutFiles(std::string infilepath, std::string outfilepath)$/;"	f	class:OpenBabel::OBConversion
OptChangeHits	pointgroup.cpp	/^    int                    OptChangeHits         ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
OptChangeThreshold	pointgroup.cpp	/^    double                 OptChangeThreshold    ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
OptionParamArray	obconversion.cpp	/^  OBConversion::OPAMapType& OBConversion::OptionParamArray(Option_type typ)$/;"	f	class:OpenBabel::OBConversion
OptionsRegistered	obmolecformat.cpp	/^  bool OBMoleculeFormat::OptionsRegistered=false;$/;"	m	class:OpenBabel::OBMoleculeFormat	file:
Orbit	canon.cpp	/^    typedef std::vector<OBAtom*> Orbit;$/;"	t	struct:OpenBabel::CanonicalLabelsImpl	file:
Orbits	canon.cpp	/^    typedef std::vector<Orbit> Orbits;$/;"	t	struct:OpenBabel::CanonicalLabelsImpl	file:
Other	tautomer.cpp	/^      Other,$/;"	e	enum:OpenBabel::TautomerImpl::Type	file:
OutputDeferredMols	obmolecformat.cpp	/^  bool OBMoleculeFormat::OutputDeferredMols(OBConversion* pConv)$/;"	f	class:OpenBabel::OBMoleculeFormat
OutputMolsFromReaction	obmolecformat.cpp	/^  bool OBMoleculeFormat::OutputMolsFromReaction$/;"	f	class:OpenBabel::OBMoleculeFormat
Oxygen	tautomer.cpp	/^      Oxygen = 8,$/;"	e	enum:OpenBabel::TautomerImpl::AtomNumber	file:
PERL_COMPATIBLE	snprintf.c	313;"	d	file:
PI	mcdlutil.cpp	52;"	d	file:
PI	obutil.cpp	770;"	d	file:
POINT_GROUP	pointgroup.cpp	/^  } POINT_GROUP ;$/;"	t	namespace:OpenBabel	typeref:struct:OpenBabel::__anon8	file:
PORTABLE_SNPRINTF_VERSION_MAJOR	snprintf.c	288;"	d	file:
PORTABLE_SNPRINTF_VERSION_MAJOR	snprintf.h	4;"	d
PORTABLE_SNPRINTF_VERSION_MINOR	snprintf.c	289;"	d	file:
PORTABLE_SNPRINTF_VERSION_MINOR	snprintf.h	5;"	d
PREFER_PORTABLE_SNPRINTF	snprintf.c	296;"	d	file:
PackCoordinate	rotamer.cpp	/^  int PackCoordinate(double c[3],double max[3])$/;"	f	namespace:OpenBabel
PairedAtoms	pointgroup.cpp	/^    std::vector< std::pair<int, int> > PairedAtoms;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
ParseAtomExpr	parsmart.cpp	/^  AtomExpr *OBSmartsPattern::ParseAtomExpr( int level )$/;"	f	class:OpenBabel::OBSmartsPattern
ParseBondExpr	parsmart.cpp	/^  BondExpr *OBSmartsPattern::ParseBondExpr( int level )$/;"	f	class:OpenBabel::OBSmartsPattern
ParseBondPrimitive	parsmart.cpp	/^  BondExpr *OBSmartsPattern::ParseBondPrimitive( void )$/;"	f	class:OpenBabel::OBSmartsPattern
ParseComplexAtomPrimitive	parsmart.cpp	/^  AtomExpr *OBSmartsPattern::ParseComplexAtomPrimitive( void )$/;"	f	class:OpenBabel::OBSmartsPattern
ParseLine	bondtyper.cpp	/^  void OBBondTyper::ParseLine(const char *buffer)$/;"	f	class:OpenBabel::OBBondTyper
ParseLine	data.cpp	/^  void OBAtomicHeatOfFormationTable::ParseLine(const char *line)$/;"	f	class:OpenBabel::OBAtomicHeatOfFormationTable
ParseLine	data.cpp	/^  void OBElementTable::ParseLine(const char *buffer)$/;"	f	class:OpenBabel::OBElementTable
ParseLine	data.cpp	/^  void OBIsotopeTable::ParseLine(const char *buffer)$/;"	f	class:OpenBabel::OBIsotopeTable
ParseLine	data.cpp	/^  void OBResidueData::ParseLine(const char *buffer)$/;"	f	class:OpenBabel::OBResidueData
ParseLine	data.cpp	/^  void OBTypeTable::ParseLine(const char *buffer)$/;"	f	class:OpenBabel::OBTypeTable
ParseLine	phmodel.cpp	/^  void OBPhModel::ParseLine(const char *buffer)$/;"	f	class:OpenBabel::OBPhModel
ParseLine	rotor.cpp	/^  void OBRotorRules::ParseLine(const char *buffer)$/;"	f	class:OpenBabel::OBRotorRules
ParseLine	typer.cpp	/^  void OBAromaticTyper::ParseLine(const char *buffer)$/;"	f	class:OpenBabel::OBAromaticTyper
ParseLine	typer.cpp	/^  void OBAtomTyper::ParseLine(const char *buffer)$/;"	f	class:OpenBabel::OBAtomTyper
ParseLine	typer.cpp	/^  void OBRingTyper::ParseLine(const char *buffer)$/;"	f	class:OpenBabel::OBRingTyper
ParsePredicate	descriptor.cpp	/^double OBDescriptor::ParsePredicate(istream& optionText, char& ch1, char& ch2, string& svalue)$/;"	f	class:OpenBabel::OBDescriptor
ParseSMARTSError	parsmart.cpp	/^  Pattern *OBSmartsPattern::ParseSMARTSError( Pattern *pat, BondExpr *expr )$/;"	f	class:OpenBabel::OBSmartsPattern
ParseSMARTSPart	parsmart.cpp	/^  Pattern *OBSmartsPattern::ParseSMARTSPart( Pattern *result, int part )$/;"	f	class:OpenBabel::OBSmartsPattern
ParseSMARTSPattern	parsmart.cpp	/^  Pattern *OBSmartsPattern::ParseSMARTSPattern( void )$/;"	f	class:OpenBabel::OBSmartsPattern
ParseSMARTSRecord	parsmart.cpp	/^  Pattern *OBSmartsPattern::ParseSMARTSRecord( char *ptr )$/;"	f	class:OpenBabel::OBSmartsPattern
ParseSMARTSString	parsmart.cpp	/^  Pattern *OBSmartsPattern::ParseSMARTSString( char *ptr )$/;"	f	class:OpenBabel::OBSmartsPattern
ParseSimpleAtomPrimitive	parsmart.cpp	/^  AtomExpr *OBSmartsPattern::ParseSimpleAtomPrimitive( void )$/;"	f	class:OpenBabel::OBSmartsPattern
ParseSmiles	chains.cpp	/^  const char *OBChainsParser::ParseSmiles(const char *ptr, int prev)$/;"	f	class:OpenBabel::OBChainsParser
PartFragmentDefinition	mcdlutil.cpp	/^    PartFragmentDefinition(){$/;"	f	class:OpenBabel::PartFragmentDefinition
PartFragmentDefinition	mcdlutil.cpp	/^  class PartFragmentDefinition {$/;"	c	namespace:OpenBabel	file:
PartialCode	canon.cpp	/^      PartialCode(std::size_t numAtoms)$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::PartialCode
PartialCode	canon.cpp	/^    struct PartialCode$/;"	s	struct:OpenBabel::CanonicalLabelsImpl	file:
PathToRoot	ring.cpp	/^  void OBRTree::PathToRoot(vector<OBAtom*> &path)$/;"	f	class:OpenBabel::OBRTree
Peptide	chains.cpp	/^  static Template Peptide[MAXPEPTIDE] = {$/;"	m	namespace:OpenBabel	file:
PerceiveBondOrders	mol.cpp	/^  void OBMol::PerceiveBondOrders()$/;"	f	class:OpenBabel::OBMol
PerceiveChains	chains.cpp	/^  bool OBChainsParser::PerceiveChains(OBMol &mol, bool nukeSingleResidue)$/;"	f	class:OpenBabel::OBChainsParser
PerceiveKekuleBonds	mol.cpp	/^  bool OBMol::PerceiveKekuleBonds()$/;"	f	class:OpenBabel::OBMol
Planes	pointgroup.cpp	/^    SYMMETRY_ELEMENT **    Planes                ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
PlanesCount	pointgroup.cpp	/^    int                    PlanesCount           ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
Point	mcdlutil.cpp	/^  class Point {$/;"	c	namespace:OpenBabel	file:
PointGroupPrivate	pointgroup.cpp	/^    PointGroupPrivate()$/;"	f	class:OpenBabel::PointGroupPrivate
PointGroupPrivate	pointgroup.cpp	/^  class PointGroupPrivate$/;"	c	namespace:OpenBabel	file:
PointGroupRejectionReason	pointgroup.cpp	/^    char *                 PointGroupRejectionReason;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
PointGroups	pointgroup.cpp	/^  POINT_GROUP            PointGroups[]         = {$/;"	m	namespace:OpenBabel	file:
PointGroupsCount	pointgroup.cpp	135;"	d	file:
PosePair	confsearch.cpp	/^      typedef std::pair<vector<vector3>, double> PosePair;$/;"	t	class:OpenBabel::OBDiversePoses	file:
Precalc	rotor.cpp	/^  void OBRotor::Precalc(vector<double*> &cv)$/;"	f	class:OpenBabel::OBRotor
Precompute	rotor.cpp	/^  void OBRotor::Precompute(double *coordinates)$/;"	f	class:OpenBabel::OBRotor
PredictAndSave	descriptor.cpp	/^double OBDescriptor::PredictAndSave(OBBase* pOb, string* param)$/;"	f	class:OpenBabel::OBDescriptor
PrintFormalCharges	forcefield.cpp	/^  void OBForceField::PrintFormalCharges()$/;"	f	class:OpenBabel::OBForceField
PrintPartialCharges	forcefield.cpp	/^  void OBForceField::PrintPartialCharges()$/;"	f	class:OpenBabel::OBForceField
PrintTypes	forcefield.cpp	/^  void OBForceField::PrintTypes()$/;"	f	class:OpenBabel::OBForceField
PrintVelocities	forcefield.cpp	/^  void OBForceField::PrintVelocities()$/;"	f	class:OpenBabel::OBForceField
PropagatePotentialAromatic	typer.cpp	/^  void OBAromaticTyper::PropagatePotentialAromatic(OBAtom *atom)$/;"	f	class:OpenBabel::OBAromaticTyper
RESIDMAX	chains.cpp	46;"	d	file:
RESIDMIN	chains.cpp	44;"	d	file:
RUNDEF	mcdlutil.cpp	171;"	d	file:
RandomRotorSearch	forcefield.cpp	/^  void OBForceField::RandomRotorSearch(unsigned int conformers, unsigned int geomSteps,$/;"	f	class:OpenBabel::OBForceField
RandomRotorSearchInitialize	forcefield.cpp	/^  void OBForceField::RandomRotorSearchInitialize(unsigned int conformers, unsigned int geomSteps,$/;"	f	class:OpenBabel::OBForceField
RandomRotorSearchNextConformer	forcefield.cpp	/^  bool OBForceField::RandomRotorSearchNextConformer(unsigned int geomSteps)$/;"	f	class:OpenBabel::OBForceField
Read	fingerprint.cpp	/^  bool FptIndex::Read(istream* pIndexstream)$/;"	f	class:OpenBabel::FptIndex
Read	obconversion.cpp	/^  bool	OBConversion::Read(OBBase* pOb, std::istream* pin)$/;"	f	class:OpenBabel::OBConversion
ReadChemObjectImpl	obmolecformat.cpp	/^  bool OBMoleculeFormat::ReadChemObjectImpl(OBConversion* pConv, OBFormat* pFormat)$/;"	f	class:OpenBabel::OBMoleculeFormat
ReadFile	obconversion.cpp	/^  bool	OBConversion::ReadFile(OBBase* pOb, std::string filePath)$/;"	f	class:OpenBabel::OBConversion
ReadHeader	fingerprint.cpp	/^  bool FptIndex::ReadHeader(istream* pIndexstream)$/;"	f	class:OpenBabel::FptIndex
ReadIndex	fingerprint.cpp	/^  string FastSearch::ReadIndex(istream* pIndexstream)$/;"	f	class:OpenBabel::FastSearch
ReadIndexFile	fingerprint.cpp	/^  string FastSearch::ReadIndexFile(string IndexFilename)$/;"	f	class:OpenBabel::FastSearch
ReadNameIndex	obmolecformat.cpp	/^  bool OBMoleculeFormat::ReadNameIndex(NameIndexType& index,$/;"	f	class:OpenBabel::OBMoleculeFormat
ReadString	obconversion.cpp	/^  bool	OBConversion::ReadString(OBBase* pOb, std::string input)$/;"	f	class:OpenBabel::OBConversion
ReadStringFromFilter	descriptor.cpp	/^bool OBDescriptor::ReadStringFromFilter(istream& optionText, string& result)$/;"	f	class:OpenBabel::OBDescriptor
Rect	mcdlutil.cpp	/^  class Rect {$/;"	c	namespace:OpenBabel	file:
RecurseChain	chains.cpp	/^  unsigned int OBChainsParser::RecurseChain(OBMol &mol, unsigned int i, int c)$/;"	f	class:OpenBabel::OBChainsParser
RegisterFormat	format.cpp	/^int OBFormat::RegisterFormat(const char* ID, const char* MIME)$/;"	f	class:OpenBabel::OBFormat
RegisterFormat	obconversion.cpp	/^  int OBConversion::RegisterFormat(const char* ID, OBFormat* pFormat, const char* MIME)$/;"	f	class:OpenBabel::OBConversion
RegisterOptionParam	obconversion.cpp	/^  void OBConversion::RegisterOptionParam(string name, OBFormat* pFormat,$/;"	f	class:OpenBabel::OBConversion
RelativelyPrime	rand.cpp	/^  static int RelativelyPrime( unsigned int x, unsigned int y )$/;"	f	namespace:OpenBabel
RemoveAtom	residue.cpp	/^  void OBResidue::RemoveAtom(OBAtom *atom)$/;"	f	class:OpenBabel::OBResidue
RemoveOption	obconversion.cpp	/^  bool OBConversion::RemoveOption(const char* opt, Option_type opttyp)$/;"	f	class:OpenBabel::OBConversion
RemoveRedundant	ring.cpp	/^  void OBRingSearch::RemoveRedundant(int frj)$/;"	f	class:OpenBabel::OBRingSearch
RemoveSymTorsionValues	rotor.cpp	/^  void OBRotor::RemoveSymTorsionValues(int fold)$/;"	f	class:OpenBabel::OBRotor
RemoveSymVals	rotor.cpp	/^  void OBRotorList::RemoveSymVals(OBMol &mol)$/;"	f	class:OpenBabel::OBRotorList
RenumberAtoms	mol.cpp	/^  void OBMol::RenumberAtoms(vector<OBAtom*> &v)$/;"	f	class:OpenBabel::OBMol
RenumberAtoms	mol.cpp	/^  void OBMol::RenumberAtoms(vector<int> v)$/;"	f	class:OpenBabel::OBMol
ReportNumberConverted	obconversion.cpp	/^  void OBConversion::ReportNumberConverted(int count, OBFormat* pFormat)$/;"	f	class:OpenBabel::OBConversion
ResNo	residue.cpp	/^  unsigned int ResNo  = MINRES;$/;"	m	namespace:OpenBabel	file:
ResidType	chains.cpp	/^  }    ResidType;$/;"	t	namespace:OpenBabel	typeref:struct:OpenBabel::__anon1	file:
Residue	residue.cpp	/^  char Residue[MAXRES][4] = {$/;"	m	namespace:OpenBabel	file:
RestoreLocale	locale.cpp	/^  void OBLocale::RestoreLocale()$/;"	f	class:OpenBabel::OBLocale
RestrictedMatch	parsmart.cpp	/^  bool OBSmartsPattern::RestrictedMatch(OBMol &mol,$/;"	f	class:OpenBabel::OBSmartsPattern
RestrictedMatch	parsmart.cpp	/^  bool OBSmartsPattern::RestrictedMatch(OBMol &mol,OBBitVec &vres, bool single)$/;"	f	class:OpenBabel::OBSmartsPattern
RevertToAliasForm	alias.cpp	/^void AliasData::RevertToAliasForm(OBMol& mol)$/;"	f	class:OpenBabel::AliasData
Reweight	forcefield.cpp	/^  void Reweight(std::vector< std::vector <double> > &rotorWeights,$/;"	f	namespace:OpenBabel
Roots	obutil.cpp	/^  static double Roots[4];$/;"	m	namespace:OpenBabel	file:
Rotate	mol.cpp	/^  void OBMol::Rotate(const double m[9])$/;"	f	class:OpenBabel::OBMol
Rotate	mol.cpp	/^  void OBMol::Rotate(const double m[9],int nconf)$/;"	f	class:OpenBabel::OBMol
Rotate	mol.cpp	/^  void OBMol::Rotate(const double u[3][3])$/;"	f	class:OpenBabel::OBMol
SINGLE	kekulize.cpp	44;"	d	file:
SINT	rotamer.cpp	/^  static int SINT = 0x00000001;$/;"	m	namespace:OpenBabel	file:
SMARTSError	parsmart.cpp	/^  Pattern *OBSmartsPattern::SMARTSError( Pattern *pat )$/;"	f	class:OpenBabel::OBSmartsPattern
SMARTSParser	parsmart.cpp	/^  Pattern *OBSmartsPattern::SMARTSParser( Pattern *pat, ParseState *stat,$/;"	f	class:OpenBabel::OBSmartsPattern
SOLARIS_COMPATIBLE	snprintf.c	301;"	d	file:
SQRT_TWO_THIRDS	atom.cpp	1524;"	d	file:
STACKSIZE	chains.cpp	68;"	d	file:
STPTR	rotamer.cpp	/^  static unsigned char *STPTR = (unsigned char*)&SINT;$/;"	m	namespace:OpenBabel	file:
STRXCASECMP_DECLARE_N	strncasecmp.c	26;"	d	file:
STRXCASECMP_DECLARE_N	strncasecmp.c	30;"	d	file:
STRXCASECMP_FUNCTION	strncasecmp.c	/^STRXCASECMP_FUNCTION (const char *s1, const char *s2 STRXCASECMP_DECLARE_N)$/;"	f
STRXCASECMP_FUNCTION	strncasecmp.c	25;"	d	file:
STRXCASECMP_FUNCTION	strncasecmp.c	29;"	d	file:
SYMMETRY_ELEMENT	pointgroup.cpp	/^    typedef _SYMMETRY_ELEMENT_ SYMMETRY_ELEMENT;$/;"	t	class:OpenBabel::PointGroupPrivate	file:
SafeOpen	obutil.cpp	/^  bool SafeOpen(std::ifstream &fs, const char *filename)$/;"	f	namespace:OpenBabel
SafeOpen	obutil.cpp	/^  bool SafeOpen(std::ifstream &fs, const string &filename)$/;"	f	namespace:OpenBabel
SafeOpen	obutil.cpp	/^  bool SafeOpen(std::ofstream &fs, const char *filename)$/;"	f	namespace:OpenBabel
SafeOpen	obutil.cpp	/^  bool SafeOpen(std::ofstream &fs, const string &filename)$/;"	f	namespace:OpenBabel
SaveUniqueRing	ring.cpp	/^  bool OBRingSearch::SaveUniqueRing(deque<int> &d1,deque<int> &d2)$/;"	f	class:OpenBabel::OBRingSearch
Score	conformersearch.cpp	/^  double OBEnergyConformerScore::Score(OBMol &mol, unsigned int index,$/;"	f	class:OpenBabel::OBEnergyConformerScore
Score	conformersearch.cpp	/^  double OBMinimizingEnergyConformerScore::Score(OBMol &mol, unsigned int index,$/;"	f	class:OpenBabel::OBMinimizingEnergyConformerScore
Score	conformersearch.cpp	/^  double OBMinimizingRMSDConformerScore::Score(OBMol &mol, unsigned int index,$/;"	f	class:OpenBabel::OBMinimizingRMSDConformerScore
Score	conformersearch.cpp	/^  double OBRMSDConformerScore::Score(OBMol &mol, unsigned int index,$/;"	f	class:OpenBabel::OBRMSDConformerScore
Search	conformersearch.cpp	/^  void OBConformerSearch::Search()$/;"	f	class:OpenBabel::OBConformerSearch
SelectRootAtoms	typer.cpp	/^  void OBAromaticTyper::SelectRootAtoms(OBMol &mol, bool avoidInnerRingAtoms)$/;"	f	class:OpenBabel::OBAromaticTyper
Selenium	tautomer.cpp	/^      Selenium = 34,$/;"	e	enum:OpenBabel::TautomerImpl::AtomNumber	file:
Separate	mol.cpp	/^  vector<OBMol> OBMol::Separate(int StartIndex)$/;"	f	class:OpenBabel::OBMol
Set	bond.cpp	/^  void OBBond::Set(int idx,OBAtom *begin,OBAtom *end,int order,int flags)$/;"	f	class:OpenBabel::OBBond
Set	rotor.cpp	/^  void OBRotor::Set(double *c,double sn,double cs,double t,double invmag)$/;"	f	class:OpenBabel::OBRotor
Set	rotor.cpp	/^  void OBRotor::Set(double *coordinates, int idx)$/;"	f	class:OpenBabel::OBRotor
Set12Bounds	distgeom.cpp	/^  void OBDistanceGeometry::Set12Bounds(bool useGeom)$/;"	f	class:OpenBabel::OBDistanceGeometry
Set13Bounds	distgeom.cpp	/^  void OBDistanceGeometry::Set13Bounds(bool useGeom)$/;"	f	class:OpenBabel::OBDistanceGeometry
Set14Bounds	distgeom.cpp	/^  void OBDistanceGeometry::Set14Bounds()$/;"	f	class:OpenBabel::OBDistanceGeometry
Set15Bounds	distgeom.cpp	/^  void OBDistanceGeometry::Set15Bounds()$/;"	f	class:OpenBabel::OBDistanceGeometry
SetAccuracy	spectrophore.cpp	/^OBSpectrophore::SetAccuracy(const OBSpectrophore::AccuracyOption a)$/;"	f	class:OpenBabel::OBSpectrophore
SetAngle	generic.cpp	/^  bool OBTorsion::SetAngle(double radians,unsigned int index)$/;"	f	class:OpenBabel::OBTorsion
SetAromaticRingBounds	distgeom.cpp	/^  void OBDistanceGeometry::SetAromaticRingBounds()$/;"	f	class:OpenBabel::OBDistanceGeometry
SetAtom4Refs	generic.cpp	/^  bool OBChiralData::SetAtom4Refs(std::vector<unsigned int> atom4refs, atomreftype t)$/;"	f	class:OpenBabel::OBChiralData
SetAtomID	residue.cpp	/^  void OBResidue::SetAtomID(OBAtom *atom, const string &id)$/;"	f	class:OpenBabel::OBResidue
SetAtoms	generic.cpp	/^  void OBAngle::SetAtoms(OBAtom *vertex,OBAtom *a,OBAtom *b)$/;"	f	class:OpenBabel::OBAngle
SetAtoms	generic.cpp	/^  void OBAngle::SetAtoms(triple<OBAtom*,OBAtom*,OBAtom*> &atoms)$/;"	f	class:OpenBabel::OBAngle
SetBO	bond.cpp	/^  void OBBond::SetBO(int order)$/;"	f	class:OpenBabel::OBBond
SetBaseCoordinateSets	rotamer.cpp	/^  void OBRotamerList::SetBaseCoordinateSets(vector<double*> bc, unsigned int N)$/;"	f	class:OpenBabel::OBRotamerList
SetBit	fingerprint.cpp	/^  void OBFingerprint::SetBit(vector<unsigned int>& vec, const unsigned int n)$/;"	f	class:OpenBabel::OBFingerprint
SetBitOff	bitvec.cpp	/^  void OBBitVec::SetBitOff(unsigned bit_offset)$/;"	f	class:OpenBabel::OBBitVec
SetBitOn	bitvec.cpp	/^  void OBBitVec::SetBitOn(unsigned bit_offset)$/;"	f	class:OpenBabel::OBBitVec
SetBondOrder	bond.cpp	/^  void OBBond::SetBondOrder(int order)$/;"	f	class:OpenBabel::OBBond
SetBoundsMatrix	distgeom.cpp	/^  bool OBDistanceGeometry::SetBoundsMatrix(const Eigen::MatrixXf bounds)$/;"	f	class:OpenBabel::OBDistanceGeometry
SetChain	residue.cpp	/^  void OBResidue::SetChain(char chain)$/;"	f	class:OpenBabel::OBResidue
SetChainNum	residue.cpp	/^  void OBResidue::SetChainNum(unsigned int chainnum)$/;"	f	class:OpenBabel::OBResidue
SetConformer	mol.cpp	/^  void OBMol::SetConformer(int i)$/;"	f	class:OpenBabel::OBMol
SetConformers	forcefield.cpp	/^  bool OBForceField::SetConformers(OBMol &mol)$/;"	f	class:OpenBabel::OBForceField
SetConformers	mol.cpp	/^  void OBMol::SetConformers(vector<double*> &v)$/;"	f	class:OpenBabel::OBMol
SetConstraints	forcefield.cpp	/^  void OBForceField::SetConstraints(OBFFConstraints& constraints)$/;"	f	class:OpenBabel::OBForceField
SetCoordinates	forcefield.cpp	/^  bool OBForceField::SetCoordinates(OBMol &mol)$/;"	f	class:OpenBabel::OBForceField
SetCoordinates	mol.cpp	/^  void OBMol::SetCoordinates(double *newCoords)$/;"	f	class:OpenBabel::OBMol
SetCurrentCoordinates	rotamer.cpp	/^  bool OBRotamerList::SetCurrentCoordinates(OBMol &mol, std::vector<int> arr)$/;"	f	class:OpenBabel::OBRotamerList
SetData	generic.cpp	/^  void OBAngleData::SetData(OBAngle &angle)$/;"	f	class:OpenBabel::OBAngleData
SetData	generic.cpp	/^  void OBExternalBondData::SetData(OBAtom *atom,OBBond *bond,int idx)$/;"	f	class:OpenBabel::OBExternalBondData
SetData	generic.cpp	/^  void OBTorsionData::SetData(OBTorsion &torsion)$/;"	f	class:OpenBabel::OBTorsionData
SetData	generic.cpp	/^  void OBUnitCell::SetData(const double a, const double b, const double c,$/;"	f	class:OpenBabel::OBUnitCell
SetData	generic.cpp	/^  void OBUnitCell::SetData(const matrix3x3 m)$/;"	f	class:OpenBabel::OBUnitCell
SetData	generic.cpp	/^  void OBUnitCell::SetData(const vector3 v1, const vector3 v2, const vector3 v3)$/;"	f	class:OpenBabel::OBUnitCell
SetData	generic.cpp	/^void OBDOSData::SetData(double fermi,$/;"	f	class:OpenBabel::OBDOSData
SetData	generic.cpp	/^void OBElectronicTransitionData::SetData(const std::vector<double> & vWavelengths,$/;"	f	class:OpenBabel::OBElectronicTransitionData
SetData	generic.cpp	/^void OBVibrationData::SetData(const std::vector< std::vector< vector3 > > & vLx,$/;"	f	class:OpenBabel::OBVibrationData
SetDihedralAtoms	rotor.cpp	/^  void OBRotor::SetDihedralAtoms(int ref[4])$/;"	f	class:OpenBabel::OBRotor
SetDihedralAtoms	rotor.cpp	/^  void OBRotor::SetDihedralAtoms(std::vector<int> &ref)$/;"	f	class:OpenBabel::OBRotor
SetEDipole	generic.cpp	/^void OBElectronicTransitionData::SetEDipole(const std::vector<double> & vEDipole)$/;"	f	class:OpenBabel::OBElectronicTransitionData
SetEnergies	mol.cpp	/^  void OBMol::SetEnergies(std::vector<double> &energies)$/;"	f	class:OpenBabel::OBMol
SetEvalAtoms	rotor.cpp	/^  bool OBRotorList::SetEvalAtoms(OBMol &mol)$/;"	f	class:OpenBabel::OBRotorList
SetFactor	forcefield.cpp	/^  void OBFFConstraints::SetFactor(double factor)$/;"	f	class:OpenBabel::OBFFConstraints
SetFirstInput	obconversion.cpp	/^  void OBConversion::SetFirstInput(bool b)$/;"	f	class:OpenBabel::OBConversion
SetFixAtom	forcefield.cpp	/^  void OBForceField::SetFixAtom(int index)$/;"	f	class:OpenBabel::OBForceField
SetFormula	mol.cpp	/^  void OBMol::SetFormula(string molFormula)$/;"	f	class:OpenBabel::OBMol
SetFromType	data.cpp	/^  bool OBTypeTable::SetFromType(const char* from)$/;"	f	class:OpenBabel::OBTypeTable
SetHetAtom	residue.cpp	/^  void OBResidue::SetHetAtom(OBAtom *atom, bool hetatm)$/;"	f	class:OpenBabel::OBResidue
SetHybAndGeom	atom.cpp	/^  bool OBAtom::SetHybAndGeom(int hyb)$/;"	f	class:OpenBabel::OBAtom
SetIdx	residue.cpp	/^  void OBResidue::SetIdx(unsigned int idx)$/;"	f	class:OpenBabel::OBResidue
SetIgnoreAtom	forcefield.cpp	/^  void OBForceField::SetIgnoreAtom(int index)$/;"	f	class:OpenBabel::OBForceField
SetInAndOutFormats	obconversion.cpp	/^  bool OBConversion::SetInAndOutFormats(OBFormat* pIn, OBFormat* pOut, bool inzip, bool outzip)$/;"	f	class:OpenBabel::OBConversion
SetInAndOutFormats	obconversion.cpp	/^  bool OBConversion::SetInAndOutFormats(const char* inID, const char* outID, bool inzip, bool outzip)$/;"	f	class:OpenBabel::OBConversion
SetInFormat	obconversion.cpp	/^  bool OBConversion::SetInFormat(OBFormat* pIn, bool gzip)$/;"	f	class:OpenBabel::OBConversion
SetInFormat	obconversion.cpp	/^  bool OBConversion::SetInFormat(const char* inID, bool gzip)$/;"	f	class:OpenBabel::OBConversion
SetInStream	obconversion.cpp	/^  void OBConversion::SetInStream(std::istream* pIn, bool takeOwnership)$/;"	f	class:OpenBabel::OBConversion
SetInsertionCode	residue.cpp	/^  void    OBResidue::SetInsertionCode(const char insertioncode) {$/;"	f	class:OpenBabel::OBResidue
SetInternalCoord	mol.cpp	/^  void OBMol::SetInternalCoord(std::vector<OBInternalCoord*> int_coord) {$/;"	f	class:OpenBabel::OBMol
SetIsotope	atom.cpp	/^  void OBAtom::SetIsotope(unsigned int iso)$/;"	f	class:OpenBabel::OBAtom
SetKDouble	bond.cpp	/^  void OBBond::SetKDouble()$/;"	f	class:OpenBabel::OBBond
SetKSingle	bond.cpp	/^  void OBBond::SetKSingle()$/;"	f	class:OpenBabel::OBBond
SetKTriple	bond.cpp	/^  void OBBond::SetKTriple()$/;"	f	class:OpenBabel::OBBond
SetLength	bond.cpp	/^  void OBBond::SetLength(OBAtom *fixed, double length)$/;"	f	class:OpenBabel::OBBond
SetLength	bond.cpp	/^  void OBBond::SetLength(double length)$/;"	f	class:OpenBabel::OBBond
SetLimits	grid.cpp	/^  void OBFloatGrid::SetLimits(const double origin[3], const double v1[3], const double v2[3],$/;"	f	class:OpenBabel::OBFloatGrid
SetLimits	grid.cpp	/^  void OBFloatGrid::SetLimits(const vector3& origin, const vector3& x,$/;"	f	class:OpenBabel::OBFloatGrid
SetLimits	griddata.cpp	/^  void OBGridData::SetLimits(const double origin [3], const double x[3],$/;"	f	class:OpenBabel::OBGridData
SetLimits	griddata.cpp	/^  void OBGridData::SetLimits(const vector3 &origin, const vector3 &x,$/;"	f	class:OpenBabel::OBGridData
SetLocale	locale.cpp	/^  void OBLocale::SetLocale()$/;"	f	class:OpenBabel::OBLocale
SetLogFile	forcefield.cpp	/^  bool OBForceField::SetLogFile(ostream* pos)$/;"	f	class:OpenBabel::OBForceField
SetLogLevel	forcefield.cpp	/^  bool OBForceField::SetLogLevel(int level)$/;"	f	class:OpenBabel::OBForceField
SetLowerBounds	distgeom.cpp	/^    void SetLowerBounds(int i, int j, float value)$/;"	f	class:OpenBabel::DistanceGeometryPrivate
SetLowerBounds	distgeom.cpp	/^  void OBDistanceGeometry::SetLowerBounds()$/;"	f	class:OpenBabel::OBDistanceGeometry
SetMoreFilesToCome	obconversion.cpp	/^  void OBConversion::SetMoreFilesToCome()$/;"	f	class:OpenBabel::OBConversion
SetName	residue.cpp	/^  void OBResidue::SetName(const string &name)$/;"	f	class:OpenBabel::OBResidue
SetNormalization	spectrophore.cpp	/^OBSpectrophore::SetNormalization(const OBSpectrophore::NormalizationOption n)$/;"	f	class:OpenBabel::OBSpectrophore
SetNum	residue.cpp	/^  void OBResidue::SetNum(const string resnum)$/;"	f	class:OpenBabel::OBResidue
SetNum	residue.cpp	/^  void OBResidue::SetNum(const unsigned int resnum)$/;"	f	class:OpenBabel::OBResidue
SetNumSymmetries	griddata.cpp	/^  void OBGridData::SetNumSymmetries( int s )$/;"	f	class:OpenBabel::OBGridData
SetNumberOfPoints	grid.cpp	/^  void OBFloatGrid::SetNumberOfPoints(int nx, int ny, int nz)$/;"	f	class:OpenBabel::OBFloatGrid
SetNumberOfPoints	griddata.cpp	/^  void OBGridData::SetNumberOfPoints( int nx, int ny, int nz )$/;"	f	class:OpenBabel::OBGridData
SetOffset	generic.cpp	/^  void OBUnitCell::SetOffset(const vector3 v1)$/;"	f	class:OpenBabel::OBUnitCell
SetOneObjectOnly	obconversion.cpp	/^  void OBConversion::SetOneObjectOnly(bool b)$/;"	f	class:OpenBabel::OBConversion
SetOptions	obconversion.cpp	/^  void OBConversion::SetOptions(const char* options, Option_type opttyp)$/;"	f	class:OpenBabel::OBConversion
SetOutFormat	obconversion.cpp	/^  bool OBConversion::SetOutFormat(OBFormat* pOut, bool gzip)$/;"	f	class:OpenBabel::OBConversion
SetOutFormat	obconversion.cpp	/^  bool OBConversion::SetOutFormat(const char* outID, bool gzip)$/;"	f	class:OpenBabel::OBConversion
SetOutStream	obconversion.cpp	/^  void OBConversion::SetOutStream(std::ostream* pOut, bool takeOwnership)$/;"	f	class:OpenBabel::OBConversion
SetOutputIndex	obconversion.cpp	/^  void OBConversion::SetOutputIndex(int indx)$/;"	f	class:OpenBabel::OBConversion
SetRangeOff	bitvec.cpp	/^  void OBBitVec::SetRangeOff(unsigned lo_bit_offset, unsigned hi_bit_offset)$/;"	f	class:OpenBabel::OBBitVec
SetRangeOn	bitvec.cpp	/^  void OBBitVec::SetRangeOn(unsigned lo_bit_offset, unsigned hi_bit_offset)$/;"	f	class:OpenBabel::OBBitVec
SetResName	data.cpp	/^  bool OBResidueData::SetResName(const string &s)$/;"	f	class:OpenBabel::OBResidueData
SetResidueInformation	chains.cpp	/^  void OBChainsParser::SetResidueInformation(OBMol &mol, bool nukeSingleResidue)$/;"	f	class:OpenBabel::OBChainsParser
SetResidueKeys	residue.cpp	/^  static void SetResidueKeys(const char   *residue,$/;"	f	namespace:OpenBabel
SetResolution	spectrophore.cpp	/^OBSpectrophore::SetResolution(const double r)$/;"	f	class:OpenBabel::OBSpectrophore
SetRings	rotor.cpp	/^  void OBRotor::SetRings(OBBond *bond)$/;"	f	class:OpenBabel::OBRotor
SetRotAtoms	rotor.cpp	/^  bool OBRotorList::SetRotAtoms(OBMol &mol)$/;"	f	class:OpenBabel::OBRotorList
SetRotAtoms	rotor.cpp	/^  void OBRotor::SetRotAtoms(vector<int> &vi)$/;"	f	class:OpenBabel::OBRotor
SetRotAtomsByFix	rotor.cpp	/^  void OBRotorList::SetRotAtomsByFix(OBMol &mol)$/;"	f	class:OpenBabel::OBRotorList
SetRotatoryStrengthsLength	generic.cpp	/^void OBElectronicTransitionData::SetRotatoryStrengthsLength(const std::vector<double> & vRotatoryStrengthsLength)$/;"	f	class:OpenBabel::OBElectronicTransitionData
SetRotatoryStrengthsVelocity	generic.cpp	/^void OBElectronicTransitionData::SetRotatoryStrengthsVelocity(const std::vector<double> & vRotatoryStrengthsVelocity)$/;"	f	class:OpenBabel::OBElectronicTransitionData
SetRotor	rotor.cpp	/^  void OBRotor::SetRotor(double *c,int idx,int prev)$/;"	f	class:OpenBabel::OBRotor
SetRotorToAngle	obutil.cpp	/^  void SetRotorToAngle(double *c,vector<int> &tor,double ang,vector<int> &atoms)$/;"	f	namespace:OpenBabel
SetRotorToAngle	rotamer.cpp	/^  void SetRotorToAngle(double *c, OBAtom **ref,double ang,vector<int> atoms)$/;"	f	namespace:OpenBabel
SetSerialNum	residue.cpp	/^  void OBResidue::SetSerialNum(OBAtom *atom, unsigned int sernum)$/;"	f	class:OpenBabel::OBResidue
SetStartAndEnd	obconversion.cpp	/^  bool OBConversion::SetStartAndEnd()$/;"	f	class:OpenBabel::OBConversion
SetStereo	spectrophore.cpp	/^OBSpectrophore::SetStereo(const OBSpectrophore::StereoOption stereo)$/;"	f	class:OpenBabel::OBSpectrophore
SetTitle	mol.cpp	/^  void  OBMol::SetTitle(const char *title)$/;"	f	class:OpenBabel::OBMol
SetTitle	mol.cpp	/^  void  OBMol::SetTitle(std::string &title)$/;"	f	class:OpenBabel::OBMol
SetToType	data.cpp	/^  bool OBTypeTable::SetToType(const char* to)$/;"	f	class:OpenBabel::OBTypeTable
SetTorsion	mol.cpp	/^  void OBMol::SetTorsion(OBAtom *a,OBAtom *b,OBAtom *c, OBAtom *d, double ang)$/;"	f	class:OpenBabel::OBMol
SetTotalCharge	mol.cpp	/^  void OBMol::SetTotalCharge(int charge)$/;"	f	class:OpenBabel::OBMol
SetTotalSpinMultiplicity	mol.cpp	/^  void   OBMol::SetTotalSpinMultiplicity(unsigned int spin)$/;"	f	class:OpenBabel::OBMol
SetType	atom.cpp	/^  void OBAtom::SetType(const char *type)$/;"	f	class:OpenBabel::OBAtom
SetType	atom.cpp	/^  void OBAtom::SetType(const string &type)$/;"	f	class:OpenBabel::OBAtom
SetType	ring.cpp	/^  void OBRing::SetType(char *type)$/;"	f	class:OpenBabel::OBRing
SetType	ring.cpp	/^  void OBRing::SetType(std::string &type)$/;"	f	class:OpenBabel::OBRing
SetUnit	griddata.cpp	/^  void OBGridData::SetUnit( OBGridData::Unit u )$/;"	f	class:OpenBabel::OBGridData
SetUnrestricted	griddata.cpp	/^  void OBGridData::SetUnrestricted( bool u )$/;"	f	class:OpenBabel::OBGridData
SetUpperBounds	distgeom.cpp	/^    void SetUpperBounds(int i, int j, float value)$/;"	f	class:OpenBabel::DistanceGeometryPrivate
SetUpperBounds	distgeom.cpp	/^  void OBDistanceGeometry::SetUpperBounds()$/;"	f	class:OpenBabel::OBDistanceGeometry
SetVals	grid.cpp	/^  void OBFloatGrid::SetVals(const std::vector<double> & vals)$/;"	f	class:OpenBabel::OBFloatGrid
SetValue	griddata.cpp	/^  bool OBGridData::SetValue(int i, int j, int k, double val)$/;"	f	class:OpenBabel::OBGridData
SetValues	griddata.cpp	/^  void OBGridData::SetValues( const std::vector< double >& v )$/;"	f	class:OpenBabel::OBGridData
SetVector	atom.cpp	/^  void OBAtom::SetVector()$/;"	f	class:OpenBabel::OBAtom
SetVector	atom.cpp	/^  void OBAtom::SetVector(const double v_x,const double v_y,const double v_z)$/;"	f	class:OpenBabel::OBAtom
SetVector	atom.cpp	/^  void OBAtom::SetVector(const vector3 &v)$/;"	f	class:OpenBabel::OBAtom
SetXAxis	grid.cpp	/^  void OBFloatGrid::SetXAxis(vector3 v)$/;"	f	class:OpenBabel::OBFloatGrid
SetYAxis	grid.cpp	/^  void OBFloatGrid::SetYAxis(vector3 v)$/;"	f	class:OpenBabel::OBFloatGrid
SetZAxis	grid.cpp	/^  void OBFloatGrid::SetZAxis(vector3 v)$/;"	f	class:OpenBabel::OBFloatGrid
Setup	conformersearch.cpp	/^  bool OBConformerSearch::Setup(const OBMol &mol, int numConformers, int numChildren, int mutability, int convergence)$/;"	f	class:OpenBabel::OBConformerSearch
Setup	distgeom.cpp	/^  bool OBDistanceGeometry::Setup(const OBMol &mol, bool useCurrentGeometry)$/;"	f	class:OpenBabel::OBDistanceGeometry
Setup	forcefield.cpp	/^  bool OBForceField::Setup(OBMol &mol)$/;"	f	class:OpenBabel::OBForceField
Setup	forcefield.cpp	/^  bool OBForceField::Setup(OBMol &mol, OBFFConstraints &constraints)$/;"	f	class:OpenBabel::OBForceField
Setup	forcefield.cpp	/^  void OBFFConstraints::Setup(OBMol& mol)$/;"	f	class:OpenBabel::OBFFConstraints
Setup	grid.cpp	/^  void OBProxGrid::Setup(OBMol &mol,OBMol &box,double cutoff,double res)$/;"	f	class:OpenBabel::OBProxGrid
Setup	grid.cpp	/^  void OBProxGrid::Setup(OBMol &mol,OBMol &box,double cutoff,vector<bool> &use,$/;"	f	class:OpenBabel::OBProxGrid
Setup	pointgroup.cpp	/^    bool                   Setup;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
Setup	pointgroup.cpp	/^  void OBPointGroup::Setup(OBMol *mol)$/;"	f	class:OpenBabel::OBPointGroup
Setup	rotamer.cpp	/^  void OBRotamerList::Setup(OBMol &mol,OBRotorList &rl)$/;"	f	class:OpenBabel::OBRotamerList
Setup	rotamer.cpp	/^  void OBRotamerList::Setup(OBMol &mol,unsigned char *ref,int nrotors)$/;"	f	class:OpenBabel::OBRotamerList
Setup	rotor.cpp	/^  bool OBRotorList::Setup(OBMol &mol, bool sampleRingBonds)$/;"	f	class:OpenBabel::OBRotorList
SetupAtomMatchTable	parsmart.cpp	/^  void OBSmartsMatcher::SetupAtomMatchTable(std::vector<std::vector<bool> > &ttab,$/;"	f	class:OpenBabel::OBSmartsMatcher
SetupMol	chains.cpp	/^  void OBChainsParser::SetupMol(OBMol &mol)$/;"	f	class:OpenBabel::OBChainsParser
Single	tautomer.cpp	/^      Single,$/;"	e	enum:OpenBabel::TautomerImpl::Type	file:
Size	forcefield.cpp	/^  int OBFFConstraints::Size() const$/;"	f	class:OpenBabel::OBFFConstraints
Sleep	dlhandler_win32.cpp	/^void DLHandler::Sleep(int n)$/;"	f	class:DLHandler
SmallestBondAngle	atom.cpp	/^  double	  OBAtom::SmallestBondAngle()$/;"	f	class:OpenBabel::OBAtom
SmartsImplicitRef	parsmart.cpp	/^  const int SmartsImplicitRef = -9999; \/\/ Used as a placeholder when recording atom nbrs for chiral atoms$/;"	m	namespace:OpenBabel	file:
SmartsLexReplace	parsmart.cpp	/^  void SmartsLexReplace(std::string &s,std::vector<std::pair<std::string,std::string> > &vlex)$/;"	f	namespace:OpenBabel
SolveCubic	obutil.cpp	/^  int SolveCubic(double A,double B,double C,double D)$/;"	f	namespace:OpenBabel
SolveLinear	obutil.cpp	/^  int SolveLinear(double A,double B)$/;"	f	namespace:OpenBabel
SolveQuadratic	obutil.cpp	/^  int SolveQuadratic(double A,double B,double C)$/;"	f	namespace:OpenBabel
SortAtomZ	mol.cpp	/^  bool SortAtomZ(const pair<OBAtom*,double> &a, const pair<OBAtom*,double> &b)$/;"	f	namespace:OpenBabel
SortAtomsAscending	canon.cpp	/^      SortAtomsAscending(const std::vector<unsigned int> &_ranks) : ranks(_ranks) {}$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::SortAtomsAscending
SortAtomsAscending	canon.cpp	/^    struct SortAtomsAscending$/;"	s	struct:OpenBabel::CanonicalLabelsImpl	file:
SortAtomsDescending	canon.cpp	/^      SortAtomsDescending(const std::vector<unsigned int> &_ranks) : ranks(_ranks) {}$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::SortAtomsDescending
SortAtomsDescending	canon.cpp	/^    struct SortAtomsDescending$/;"	s	struct:OpenBabel::CanonicalLabelsImpl	file:
SortByIndex	generic.cpp	/^  void OBAngle::SortByIndex()$/;"	f	class:OpenBabel::OBAngle
SortCode	canon.cpp	/^    static bool SortCode(const FullCode &code1, const FullCode &code2)$/;"	f	struct:OpenBabel::CanonicalLabelsImpl
SortCode2	canon.cpp	/^    static bool SortCode2(const std::pair<int, FullCode> &code1, const std::pair<int, FullCode> &code2)$/;"	f	struct:OpenBabel::CanonicalLabelsImpl
SortStereoCenters	canon.cpp	/^      SortStereoCenters(const std::vector<unsigned int> &_labels) : labels(_labels) {}$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::SortStereoCenters
SortStereoCenters	canon.cpp	/^    struct SortStereoCenters$/;"	s	struct:OpenBabel::CanonicalLabelsImpl	file:
SortVVInt	mol.cpp	/^  bool SortVVInt(const vector<int> &a,const vector<int> &b)$/;"	f	namespace:OpenBabel
Stack	chains.cpp	/^  static StackType Stack[STACKSIZE];$/;"	m	namespace:OpenBabel	file:
StackPtr	chains.cpp	/^  static int StackPtr;$/;"	m	namespace:OpenBabel	file:
StackType	chains.cpp	/^  } StackType;$/;"	t	namespace:OpenBabel	typeref:struct:OpenBabel::__anon7	file:
StartErrorWrap	oberror.cpp	/^  bool OBMessageHandler::StartErrorWrap()$/;"	f	class:OpenBabel::OBMessageHandler
StatAccept	pointgroup.cpp	/^    long                   StatAccept       ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
StatDups	pointgroup.cpp	/^    long                   StatDups         ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
StatEarly	pointgroup.cpp	/^    long                   StatEarly        ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
StatOpt	pointgroup.cpp	/^    long                   StatOpt          ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
StatOrder	pointgroup.cpp	/^    long                   StatOrder        ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
StatPairs	pointgroup.cpp	/^    long                   StatPairs        ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
StatTotal	pointgroup.cpp	/^    long                   StatTotal        ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
State	canon.cpp	/^      State(const std::vector<unsigned int> &_symmetry_classes,$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::State
State	canon.cpp	/^    struct State$/;"	s	struct:OpenBabel::CanonicalLabelsImpl	file:
State	isomorphism.cpp	/^        State(Functor &_functor, const OBQuery *_query, const OBMol *_queried, const OBBitVec &mask)$/;"	f	struct:OpenBabel::VF2Mapper::State
State	isomorphism.cpp	/^      struct State {$/;"	s	class:OpenBabel::VF2Mapper	file:
SteepestDescent	forcefield.cpp	/^  void OBForceField::SteepestDescent(int steps, double econv, int method)$/;"	f	class:OpenBabel::OBForceField
SteepestDescentInitialize	forcefield.cpp	/^  void OBForceField::SteepestDescentInitialize(int steps, double econv, int method)$/;"	f	class:OpenBabel::OBForceField
SteepestDescentTakeNSteps	forcefield.cpp	/^  bool OBForceField::SteepestDescentTakeNSteps(int n)$/;"	f	class:OpenBabel::OBForceField
StereoBondStore	mcdlutil.cpp	/^  class StereoBondStore {$/;"	c	namespace:OpenBabel	file:
StereoCenter	canon.cpp	/^    struct StereoCenter$/;"	s	struct:OpenBabel::CanonicalLabelsImpl	file:
StopErrorWrap	oberror.cpp	/^  bool OBMessageHandler::StopErrorWrap()$/;"	f	class:OpenBabel::OBMessageHandler
StoredMolsReady	obmolecformat.cpp	/^  bool OBMoleculeFormat::StoredMolsReady=false;$/;"	m	class:OpenBabel::OBMoleculeFormat	file:
StrategyFiltered	zipstream.h	/^    StrategyFiltered = 1,$/;"	e	enum:zlib_stream::EStrategy
StrategyHuffmanOnly	zipstream.h	/^    StrategyHuffmanOnly = 2,$/;"	e	enum:zlib_stream::EStrategy
StrictFlag	chains.cpp	/^  static bool StrictFlag = false;$/;"	m	namespace:OpenBabel	file:
StripSalts	mol.cpp	/^  bool OBMol::StripSalts(int threshold)$/;"	f	class:OpenBabel::OBMol
Sulfur	tautomer.cpp	/^      Sulfur = 16,$/;"	e	enum:OpenBabel::TautomerImpl::AtomNumber	file:
Swab	rotamer.cpp	/^  int Swab(int i)$/;"	f	namespace:OpenBabel
SwabInt	rotamer.cpp	/^  const bool SwabInt = (STPTR[0]!=0);$/;"	m	namespace:OpenBabel	file:
Swap	builder.cpp	/^  bool OBBuilder::Swap(OBMol &mol, int idxA, int idxB, int idxC, int idxD)$/;"	f	class:OpenBabel::OBBuilder
SwapWithVector	builder.cpp	/^  bool OBBuilder::SwapWithVector(OBMol &mol, int idxA, int idxB, int idxC, const vector3 &newlocation)$/;"	f	class:OpenBabel::OBBuilder
Symmetrize	pointgroup.cpp	/^  void OBPointGroup::Symmetrize(OBMol *mol)$/;"	f	class:OpenBabel::OBPointGroup
SymmetryCode	pointgroup.cpp	/^    const char *           SymmetryCode          ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
SystematicRotorSearch	forcefield.cpp	/^  void OBForceField::SystematicRotorSearch(unsigned int geomSteps, bool sampleRingBonds)$/;"	f	class:OpenBabel::OBForceField
SystematicRotorSearchInitialize	forcefield.cpp	/^  int OBForceField::SystematicRotorSearchInitialize(unsigned int geomSteps, bool sampleRingBonds)$/;"	f	class:OpenBabel::OBForceField
SystematicRotorSearchNextConformer	forcefield.cpp	/^  bool OBForceField::SystematicRotorSearchNextConformer(unsigned int geomSteps)$/;"	f	class:OpenBabel::OBForceField
TEditedMolecule	mcdlutil.cpp	/^    TEditedMolecule() : TSimpleMolecule() {$/;"	f	class:OpenBabel::TEditedMolecule
TEditedMolecule	mcdlutil.cpp	/^  class TEditedMolecule: public TSimpleMolecule {$/;"	c	namespace:OpenBabel	file:
TOLOWER	strncasecmp.c	37;"	d	file:
TSimpleMolecule	mcdlutil.cpp	/^    TSimpleMolecule() {$/;"	f	class:OpenBabel::TSimpleMolecule
TSimpleMolecule	mcdlutil.cpp	/^  class TSimpleMolecule {$/;"	c	namespace:OpenBabel	file:
TSingleAtom	mcdlutil.cpp	/^    TSingleAtom() {$/;"	f	class:OpenBabel::TSingleAtom
TSingleAtom	mcdlutil.cpp	/^  class  TSingleAtom  {$/;"	c	namespace:OpenBabel	file:
TSingleBond	mcdlutil.cpp	/^  class  TSingleBond  {$/;"	c	namespace:OpenBabel	file:
Tanimoto	bitvec.cpp	/^  double Tanimoto(const OBBitVec & bv1, const OBBitVec & bv2)$/;"	f	namespace:OpenBabel
Tanimoto	fingerprint.cpp	/^  double OBFingerprint::Tanimoto(const vector<unsigned int>& vec1, const vector<unsigned int>& vec2)$/;"	f	class:OpenBabel::OBFingerprint
TargetClassDescription	format.cpp	/^const char* OBFormat::TargetClassDescription()$/;"	f	class:OpenBabel::OBFormat
TautomerImpl	tautomer.cpp	/^  struct TautomerImpl$/;"	s	namespace:OpenBabel	file:
Tellurium	tautomer.cpp	/^      Tellurium = 52$/;"	e	enum:OpenBabel::TautomerImpl::AtomNumber	file:
Template	chains.cpp	/^  typedef struct Template$/;"	s	namespace:OpenBabel	file:
Template	chains.cpp	/^  }    Template;$/;"	t	namespace:OpenBabel	typeref:struct:OpenBabel::Template	file:
TemplateRedraw	mcdlutil.cpp	/^  TemplateRedraw::TemplateRedraw(){$/;"	f	class:OpenBabel::TemplateRedraw
TemplateRedraw	mcdlutil.cpp	/^  class  TemplateRedraw  {$/;"	c	namespace:OpenBabel	file:
ThrowError	oberror.cpp	/^  void OBMessageHandler::ThrowError(OBError err, errorQualifier qualifier)$/;"	f	class:OpenBabel::OBMessageHandler
ThrowError	oberror.cpp	/^  void OBMessageHandler::ThrowError(const std::string &method,$/;"	f	class:OpenBabel::OBMessageHandler
ThrowError	obutil.cpp	/^  void ThrowError(char *str)$/;"	f	namespace:OpenBabel
ThrowError	obutil.cpp	/^  void ThrowError(std::string &str)$/;"	f	namespace:OpenBabel
TimeSeed	rand.cpp	/^  void OBRandom::TimeSeed()$/;"	f	class:OpenBabel::OBRandom
Timeout	canon.cpp	/^      Timeout(time_t _maxTime) : maxTime(_maxTime)$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::Timeout
Timeout	canon.cpp	/^    struct Timeout$/;"	s	struct:OpenBabel::CanonicalLabelsImpl	file:
Timeout	kekulize.cpp	/^      Timeout(time_t _maxTime) : maxTime(_maxTime)$/;"	f	struct:OpenBabel::Kekulize::Timeout
Timeout	kekulize.cpp	/^    struct Timeout$/;"	s	namespace:OpenBabel::Kekulize	file:
ToInertialFrame	mol.cpp	/^  void OBMol::ToInertialFrame()$/;"	f	class:OpenBabel::OBMol
ToInertialFrame	mol.cpp	/^  void OBMol::ToInertialFrame(int conf,double *rmat)$/;"	f	class:OpenBabel::OBMol
ToLower	obutil.cpp	/^  void ToLower(char *cptr)$/;"	f	namespace:OpenBabel
ToLower	obutil.cpp	/^  void ToLower(std::string &s)$/;"	f	namespace:OpenBabel
ToUpper	obutil.cpp	/^  void ToUpper(char *cptr)$/;"	f	namespace:OpenBabel
ToUpper	obutil.cpp	/^  void ToUpper(std::string &s)$/;"	f	namespace:OpenBabel
ToVecInt	bitvec.cpp	/^  void OBBitVec::ToVecInt(std::vector<int> & bit_offsets) const$/;"	f	class:OpenBabel::OBBitVec
ToleranceFinal	pointgroup.cpp	/^    double                 ToleranceFinal        ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
TolerancePrimary	pointgroup.cpp	/^    double                 TolerancePrimary      ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
ToleranceSame	pointgroup.cpp	/^    double                 ToleranceSame         ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
Tolower	data.cpp	/^  void Tolower(string &s)$/;"	f	namespace:OpenBabel
Toupper	data.cpp	/^  void Toupper(string &s)$/;"	f	namespace:OpenBabel
TraceNucleicChain	chains.cpp	/^  void OBChainsParser::TraceNucleicChain(OBMol &mol, unsigned int i, int r)$/;"	f	class:OpenBabel::OBChainsParser
TracePeptideChain	chains.cpp	/^  void OBChainsParser::TracePeptideChain(OBMol &mol, unsigned int i, int r)$/;"	f	class:OpenBabel::OBChainsParser
Translate	data.cpp	/^  bool OBTypeTable::Translate(char *to, const char *from)$/;"	f	class:OpenBabel::OBTypeTable
Translate	data.cpp	/^  bool OBTypeTable::Translate(string &to, const string &from)$/;"	f	class:OpenBabel::OBTypeTable
Translate	data.cpp	/^  std::string OBTypeTable::Translate(const string &from)$/;"	f	class:OpenBabel::OBTypeTable
Translate	mol.cpp	/^  void OBMol::Translate(const vector3 &v)$/;"	f	class:OpenBabel::OBMol
Translate	mol.cpp	/^  void OBMol::Translate(const vector3 &v, int nconf)$/;"	f	class:OpenBabel::OBMol
TraverseCycle	typer.cpp	/^  bool OBAromaticTyper::TraverseCycle(OBAtom *root, OBAtom *atom, OBBond *prev,$/;"	f	class:OpenBabel::OBAromaticTyper
Tree	confsearch.cpp	/^      typedef tree<PosePair> Tree;$/;"	t	class:OpenBabel::OBDiversePoses	file:
Tree_it	confsearch.cpp	/^      typedef tree<PosePair>::iterator Tree_it;$/;"	t	class:OpenBabel::OBDiversePoses	file:
Tree_sit	confsearch.cpp	/^      typedef tree<PosePair>::sibling_iterator Tree_sit;$/;"	t	class:OpenBabel::OBDiversePoses	file:
TriangleSmooth	distgeom.cpp	/^  void OBDistanceGeometry::TriangleSmooth(int iterations)$/;"	f	class:OpenBabel::OBDistanceGeometry
Trim	tokenst.cpp	/^  std::string& Trim(std::string& txt)$/;"	f	namespace:OpenBabel
True	rand.cpp	45;"	d	file:
TwoThirdsPI	obutil.cpp	774;"	d	file:
Type	tautomer.cpp	/^    enum Type {$/;"	g	struct:OpenBabel::TautomerImpl	file:
UNASSIGNED	kekulize.cpp	43;"	d	file:
Unassigned	tautomer.cpp	/^      Unassigned,$/;"	e	enum:OpenBabel::TautomerImpl::Type	file:
UnitNameToConversionFactor	data.cpp	/^  static double UnitNameToConversionFactor(const char* unit) {$/;"	f	namespace:OpenBabel
UnpackCoordinate	rotamer.cpp	/^  void UnpackCoordinate(double c[3],double max[3],int tmp)$/;"	f	namespace:OpenBabel
UnsetFixAtom	forcefield.cpp	/^  void OBForceField::UnsetFixAtom()$/;"	f	class:OpenBabel::OBForceField
UnsetIgnoreAtom	forcefield.cpp	/^  void OBForceField::UnsetIgnoreAtom()$/;"	f	class:OpenBabel::OBForceField
UpdateConformersFromTree	confsearch.cpp	/^void UpdateConformersFromTree(OBMol* mol, vector<double> &energies, OBDiversePoses* divposes, bool verbose) {$/;"	f	namespace:OpenBabel
UpdateMcr	canon.cpp	/^    static void UpdateMcr(OBBitVec &mcr, Orbits &orbits, OBMol *mol, const std::vector<unsigned int> &bestLabels)$/;"	f	struct:OpenBabel::CanonicalLabelsImpl
UpdatePairsSimple	forcefield.cpp	/^  void OBForceField::UpdatePairsSimple()$/;"	f	class:OpenBabel::OBForceField
VC_EXTRALEAN	dlhandler_win32.cpp	24;"	d	file:
VF2Mapper	isomorphism.cpp	/^      VF2Mapper(OBQuery *query) : OBIsomorphismMapper(query)$/;"	f	class:OpenBabel::VF2Mapper
VF2Mapper	isomorphism.cpp	/^  class VF2Mapper : public OBIsomorphismMapper$/;"	c	namespace:OpenBabel	file:
ValenceSum	mol.cpp	/^  static int ValenceSum(OBAtom *atom)$/;"	f	namespace:OpenBabel
ValidateConjugateGradients	forcefield.cpp	/^  void OBForceField::ValidateConjugateGradients(int steps)$/;"	f	class:OpenBabel::OBForceField
ValidateGradientError	forcefield.cpp	/^  vector3 OBForceField::ValidateGradientError(vector3 &numgrad, vector3 &anagrad)$/;"	f	class:OpenBabel::OBForceField
ValidateLineSearch	forcefield.cpp	/^  vector3 OBForceField::ValidateLineSearch(OBAtom *atom, vector3 &direction)$/;"	f	class:OpenBabel::OBForceField
ValidateSteepestDescent	forcefield.cpp	/^  void OBForceField::ValidateSteepestDescent(int steps)$/;"	f	class:OpenBabel::OBForceField
VectorAngle	forcefield.cpp	/^  double OBForceField::VectorAngle(double *pos_i, double *pos_j, double *pos_k)$/;"	f	class:OpenBabel::OBForceField
VectorAngleDerivative	forcefield.cpp	/^  double OBForceField::VectorAngleDerivative(double *pos_i, double *pos_j, double *pos_k,$/;"	f	class:OpenBabel::OBForceField
VectorAngleDerivative	forcefield.cpp	/^  double OBForceField::VectorAngleDerivative(vector3 &i, vector3 &j, vector3 &k)$/;"	f	class:OpenBabel::OBForceField
VectorBondDerivative	forcefield.cpp	/^  double OBForceField::VectorBondDerivative(double *pos_i, double *pos_j,$/;"	f	class:OpenBabel::OBForceField
VectorDistanceDerivative	forcefield.cpp	/^  double OBForceField::VectorDistanceDerivative(const double* const pos_i, const double* const pos_j,$/;"	f	class:OpenBabel::OBForceField
VectorLengthDerivative	forcefield.cpp	/^  double OBForceField::VectorLengthDerivative(vector3 &a, vector3 &b)$/;"	f	class:OpenBabel::OBForceField
VectorOOP	forcefield.cpp	/^  double OBForceField::VectorOOP(double *pos_i, double *pos_j, double *pos_k, double *pos_l)$/;"	f	class:OpenBabel::OBForceField
VectorOOPDerivative	forcefield.cpp	/^  double OBForceField::VectorOOPDerivative(double *pos_i, double *pos_j, double *pos_k, double *pos_l,$/;"	f	class:OpenBabel::OBForceField
VectorOOPDerivative	forcefield.cpp	/^  double OBForceField::VectorOOPDerivative(vector3 &i, vector3 &j, vector3 &k, vector3 &l)$/;"	f	class:OpenBabel::OBForceField
VectorTorsion	forcefield.cpp	/^  double OBForceField::VectorTorsion(double *pos_i, double *pos_j, double *pos_k, double *pos_l)$/;"	f	class:OpenBabel::OBForceField
VectorTorsionDerivative	forcefield.cpp	/^  double OBForceField::VectorTorsionDerivative(double *pos_i, double *pos_j, double *pos_k, double *pos_l,$/;"	f	class:OpenBabel::OBForceField
VectorTorsionDerivative	forcefield.cpp	/^  double OBForceField::VectorTorsionDerivative(vector3 &i, vector3 &j, vector3 &k, vector3 &l)$/;"	f	class:OpenBabel::OBForceField
WeightedRotorSearch	forcefield.cpp	/^  void OBForceField::WeightedRotorSearch(unsigned int conformers, unsigned int geomSteps,$/;"	f	class:OpenBabel::OBForceField
WorksWith	alias.cpp	/^  virtual bool WorksWith(OBBase* pOb)const{ return dynamic_cast<OBMol*>(pOb)!=NULL; }$/;"	f	class:OpenBabel::OpGenAlias
WrapCartesianCoordinate	generic.cpp	/^  vector3 OBUnitCell::WrapCartesianCoordinate(vector3 cart) const$/;"	f	class:OpenBabel::OBUnitCell
WrapFractionalCoordinate	generic.cpp	/^  vector3 OBUnitCell::WrapFractionalCoordinate(vector3 frac) const$/;"	f	class:OpenBabel::OBUnitCell
Write	obconversion.cpp	/^  bool OBConversion::Write(OBBase* pOb, ostream* pos)$/;"	f	class:OpenBabel::OBConversion
WriteChemObjectImpl	obmolecformat.cpp	/^  bool OBMoleculeFormat::WriteChemObjectImpl(OBConversion* pConv, OBFormat* pFormat)$/;"	f	class:OpenBabel::OBMoleculeFormat
WriteFile	obconversion.cpp	/^  bool OBConversion::WriteFile(OBBase* pOb, string filePath)$/;"	f	class:OpenBabel::OBConversion
WriteMapList	parsmart.cpp	/^  void OBSmartsPattern::WriteMapList(ostream &ofs)$/;"	f	class:OpenBabel::OBSmartsPattern
WriteRings	ring.cpp	/^  void OBRingSearch::WriteRings()$/;"	f	class:OpenBabel::OBRingSearch
WriteString	obconversion.cpp	/^  std::string OBConversion::WriteString(OBBase* pOb, bool trimWhitespace)$/;"	f	class:OpenBabel::OBConversion
WriteTitles	mol.cpp	/^  bool WriteTitles(ostream &ofs, OBMol &mol)$/;"	f	namespace:OpenBabel
_ByteCode	chains.cpp	/^  typedef union _ByteCode$/;"	u	namespace:OpenBabel	file:
_PORTABLE_SNPRINTF_H_	snprintf.h	2;"	d
_SYMMETRY_ELEMENT_	pointgroup.cpp	/^    struct _SYMMETRY_ELEMENT_ {$/;"	s	class:OpenBabel::PointGroupPrivate	file:
_ZIPSTREAM_H_	zipstream.h	35;"	d
__wrap_memcpy	memcpy.c	/^void *__wrap_memcpy(void *dest, const void *src, size_t n)$/;"	f
_added_footer	zipstream.h	/^    bool _added_footer;$/;"	m	class:zlib_stream::basic_zip_ostream
_buffer	zipstream.h	/^    char_vector_type    _buffer;$/;"	m	class:zlib_stream::basic_unzip_streambuf
_buffer	zipstream.h	/^    char_vector_type    _buffer;$/;"	m	class:zlib_stream::basic_zip_streambuf
_calculateProperties	spectrophore.cpp	/^OBSpectrophore::_calculateProperties(OpenBabel::OBMol* mol)$/;"	f	class:OpenBabel::OBSpectrophore
_canonLabels	graphsym.cpp	/^      std::vector<unsigned int> _canonLabels;$/;"	m	class:OpenBabel::OBGraphSymPrivate	file:
_constraints	forcefield.cpp	/^  OBFFConstraints OBForceField::_constraints = OBFFConstraints(); \/\/ define static data variable$/;"	m	class:OpenBabel::OBForceField	file:
_crc	zipstream.h	/^    unsigned long       _crc;$/;"	m	class:zlib_stream::basic_unzip_streambuf
_crc	zipstream.h	/^    unsigned long       _crc;$/;"	m	class:zlib_stream::basic_zip_streambuf
_err	zipstream.h	/^    int                 _err;$/;"	m	class:zlib_stream::basic_unzip_streambuf
_err	zipstream.h	/^    int                 _err;$/;"	m	class:zlib_stream::basic_zip_streambuf
_fixAtom	forcefield.cpp	/^  unsigned int OBForceField::_fixAtom = 0; \/\/ define static data variable$/;"	m	class:OpenBabel::OBForceField	file:
_frag_atoms	graphsym.cpp	/^      OBBitVec _frag_atoms;$/;"	m	class:OpenBabel::OBGraphSymPrivate	file:
_fragments	builder.cpp	/^  std::vector<std::pair<OBSmartsPattern*, std::vector<vector3> > > OBBuilder::_fragments;$/;"	m	class:OpenBabel::OBBuilder	file:
_getBox	spectrophore.cpp	/^OBSpectrophore::_getBox(double** c)$/;"	f	class:OpenBabel::OBSpectrophore
_getEnergies	spectrophore.cpp	/^OBSpectrophore::_getEnergies(double** c, double* e)$/;"	f	class:OpenBabel::OBSpectrophore
_getMoleculeData	spectrophore.cpp	/^OBSpectrophore::_getMoleculeData(OpenBabel::OBMol* mol)$/;"	f	class:OpenBabel::OBSpectrophore
_gzip_crc	zipstream.h	/^    long _gzip_crc;$/;"	m	class:zlib_stream::basic_zip_istream
_gzip_data_size	zipstream.h	/^    long _gzip_data_size;$/;"	m	class:zlib_stream::basic_zip_istream
_ignoreAtom	forcefield.cpp	/^  unsigned int OBForceField::_ignoreAtom = 0; \/\/ define static data variable$/;"	m	class:OpenBabel::OBForceField	file:
_initiateSpectrophore	spectrophore.cpp	/^OBSpectrophore::_initiateSpectrophore(double* e, double* s)$/;"	f	class:OpenBabel::OBSpectrophore
_input_buffer	zipstream.h	/^    byte_vector_type    _input_buffer;$/;"	m	class:zlib_stream::basic_unzip_streambuf
_is_gzip	zipstream.h	/^    bool              _is_gzip;$/;"	m	class:zlib_stream::basic_unzip_streambuf
_is_gzip	zipstream.h	/^    bool _is_gzip;$/;"	m	class:zlib_stream::basic_zip_ostream
_istream	zipstream.h	/^    istream_reference   _istream;$/;"	m	class:zlib_stream::basic_unzip_streambuf
_jmol	obmolecformat.cpp	/^  OBMol* OBMoleculeFormat::_jmol;$/;"	m	class:OpenBabel::OBMoleculeFormat	file:
_lfsr	confsearch.cpp	/^    unsigned int _range, _lfsr, _poly;$/;"	m	class:OpenBabel::LFSR	file:
_luDecompose	spectrophore.cpp	/^OBSpectrophore::_luDecompose(double** A, std::vector<int>& I, unsigned int dim)$/;"	f	class:OpenBabel::OBSpectrophore
_luSolve	spectrophore.cpp	/^OBSpectrophore::_luSolve(double** A, std::vector<int>& I, double* B, unsigned int dim)$/;"	f	class:OpenBabel::OBSpectrophore
_max	griddata.cpp	/^    double           _max;$/;"	m	class:OpenBabel::GridDataPrivate	file:
_min	griddata.cpp	/^    double           _min;$/;"	m	class:OpenBabel::GridDataPrivate	file:
_mol	pointgroup.cpp	/^    OBMol  *               _mol;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
_orient	spectrophore.cpp	/^OBSpectrophore::_orient(void)$/;"	f	class:OpenBabel::OBSpectrophore
_ostream	zipstream.h	/^    ostream_reference   _ostream;$/;"	m	class:zlib_stream::basic_zip_streambuf
_output_buffer	zipstream.h	/^    byte_vector_type    _output_buffer;$/;"	m	class:zlib_stream::basic_zip_streambuf
_percise	confsearch.cpp	/^      bool _percise;$/;"	m	class:OpenBabel::OBDiversePoses	file:
_pmol	graphsym.cpp	/^      OBMol* _pmol;$/;"	m	class:OpenBabel::OBGraphSymPrivate	file:
_poly	confsearch.cpp	/^    unsigned int _range, _lfsr, _poly;$/;"	m	class:OpenBabel::LFSR	file:
_polynomials	confsearch.cpp	/^    static const unsigned int _polynomials[31];$/;"	m	class:OpenBabel::LFSR	file:
_polynomials	confsearch.cpp	/^  const unsigned int LFSR::_polynomials[31] = {0x3, 0x6, 0xc, 0x14, 0x30, 0x60, 0xb8, 0x110, 0x240, 0x500,$/;"	m	class:OpenBabel::LFSR	file:
_range	confsearch.cpp	/^    unsigned int _range, _lfsr, _poly;$/;"	m	class:OpenBabel::LFSR	file:
_rotateX	spectrophore.cpp	/^OBSpectrophore::_rotateX(double** oc, double** nc, const double c, const double s)$/;"	f	class:OpenBabel::OBSpectrophore
_rotateY	spectrophore.cpp	/^OBSpectrophore::_rotateY(double** oc, double** nc, const double c, const double s)$/;"	f	class:OpenBabel::OBSpectrophore
_rotateZ	spectrophore.cpp	/^OBSpectrophore::_rotateZ(double** oc, double** nc, const double c, const double s)$/;"	f	class:OpenBabel::OBSpectrophore
_setBox	spectrophore.cpp	/^OBSpectrophore::_setBox(void)$/;"	f	class:OpenBabel::OBSpectrophore
_solveMatrix	spectrophore.cpp	/^OBSpectrophore::_solveMatrix(double** A, double* B, unsigned int dim)$/;"	f	class:OpenBabel::OBSpectrophore
_stereoUnits	graphsym.cpp	/^      OBStereoUnitSet _stereoUnits;$/;"	m	class:OpenBabel::OBGraphSymPrivate	file:
_swapRows	spectrophore.cpp	/^OBSpectrophore::_swapRows(double* _pMatrix, unsigned int i, unsigned int j)$/;"	f	class:OpenBabel::OBSpectrophore
_swapRows	spectrophore.cpp	/^OBSpectrophore::_swapRows(double** _pMatrix, unsigned int i, unsigned int j, unsigned int nCols)$/;"	f	class:OpenBabel::OBSpectrophore
_symmetries	griddata.cpp	/^    int              _symmetries;$/;"	m	class:OpenBabel::GridDataPrivate	file:
_unit	griddata.cpp	/^    OBGridData::Unit _unit;$/;"	m	class:OpenBabel::GridDataPrivate	file:
_unrestricted	griddata.cpp	/^    bool             _unrestricted;$/;"	m	class:OpenBabel::GridDataPrivate	file:
_unzipped_component_bytes	zipstream.h	/^    unsigned long       _unzipped_component_bytes; \/\/keep track of bytes that were in separately zipped sections for seeking purposes$/;"	m	class:zlib_stream::basic_unzip_streambuf
_updateSpectrophore	spectrophore.cpp	/^OBSpectrophore::_updateSpectrophore(double* ENERGY, double* SPHORE)$/;"	f	class:OpenBabel::OBSpectrophore
_zip_stream	zipstream.h	/^    z_stream            _zip_stream;$/;"	m	class:zlib_stream::basic_unzip_streambuf
_zip_stream	zipstream.h	/^    z_stream            _zip_stream;$/;"	m	class:zlib_stream::basic_zip_streambuf
aSTested	mcdlutil.cpp	/^    std::vector<int> aSTested;$/;"	m	class:OpenBabel::TEditedMolecule	file:
aSymb	mcdlutil.cpp	/^  const string aSymb[NELEMMCDL] = {"0",$/;"	m	namespace:OpenBabel	file:
abort	isomorphism.cpp	/^        bool abort;$/;"	m	struct:OpenBabel::VF2Mapper::State	file:
ac	mcdlutil.cpp	/^    short int ac[CONNMAX];$/;"	m	class:OpenBabel::TSingleAtom	file:
add	canon.cpp	/^      inline void add(OBAtom *atom) { atoms.push_back(atom); }$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::PartialCode
add	canon.cpp	/^      inline void add(OBAtom *fromAtom, OBAtom *atom)$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::PartialCode
add	canon.cpp	/^      inline void add(OBBond *bond) { bonds.push_back(bond); }$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::PartialCode
addAsTemplate	mcdlutil.cpp	/^  void TEditedMolecule::addAsTemplate(TEditedMolecule& fragmentMol, int thisAN, int smAN, int thisBN, int smBN, bool isAddition) {$/;"	f	class:OpenBabel::TEditedMolecule
addAtom	mcdlutil.cpp	/^  void TSimpleMolecule::addAtom(TSingleAtom * sa){$/;"	f	class:OpenBabel::TSimpleMolecule
addAtom	mcdlutil.cpp	/^  void TSimpleMolecule::addAtom(int na, int charge, double rx, double ry) {$/;"	f	class:OpenBabel::TSimpleMolecule
addBond	mcdlutil.cpp	/^  void TSimpleMolecule::addBond(TSingleBond * sb){$/;"	f	class:OpenBabel::TSimpleMolecule
addBond	mcdlutil.cpp	/^  void TSimpleMolecule::addBond(int tb, int at1, int at2){$/;"	f	class:OpenBabel::TSimpleMolecule
addFragment	mcdlutil.cpp	/^  int TEditedMolecule::addFragment(TEditedMolecule & eMolecule, int naDEF, int cha, int chb,$/;"	f	class:OpenBabel::TEditedMolecule
addFragment	mcdlutil.cpp	/^  void addFragment(OBMol * molecule, OBMol * fragment, int molAN, int fragAN, int molBN, int fragBN, bool isAddition) {$/;"	f	namespace:OpenBabel
addNbrs	canon.cpp	/^  void addNbrs(OBBitVec &fragment, OBAtom *atom, const OBBitVec &mask, const std::vector<OBBond*> &metalloceneBonds)$/;"	f	namespace:OpenBabel
addZeroeth	mcdlutil.cpp	/^  std::string addZeroeth(std::string instring, std::string stringAdd) {$/;"	f	namespace:OpenBabel
add_footer	zipstreamimpl.h	/^basic_zip_ostream<charT,traits>& basic_zip_ostream<charT, traits>::add_footer(void)$/;"	f	class:basic_zip_ostream
add_header	zipstreamimpl.h	/^basic_zip_ostream<charT,traits>& basic_zip_ostream<charT, traits>::add_header(void)$/;"	f	class:basic_zip_ostream
adjusted	mcdlutil.cpp	/^    int adjusted[CONNMAX];$/;"	m	struct:OpenBabel::adjustedlist	file:
adjustedlist	mcdlutil.cpp	/^  typedef struct adjustedlist{$/;"	s	namespace:OpenBabel	file:
adjustedlist	mcdlutil.cpp	/^  } adjustedlist;$/;"	t	namespace:OpenBabel	typeref:struct:OpenBabel::adjustedlist	file:
alkaly	mcdlutil.cpp	/^  const int alkaly[NALKALYATOMS] ={3,11,19,37,55};$/;"	m	namespace:OpenBabel	file:
alkalyEarth	mcdlutil.cpp	/^  const int alkalyEarth[NALKALYEARTHATOMS] ={4,12,20,38,56};$/;"	m	namespace:OpenBabel	file:
allAboutCycles	mcdlutil.cpp	/^  void TSimpleMolecule::allAboutCycles() {$/;"	f	class:OpenBabel::TSimpleMolecule
allAtAtom	mcdlutil.cpp	/^  int TSingleAtom::allAtAtom() {$/;"	f	class:OpenBabel::TSingleAtom
allQueryPresent	mcdlutil.cpp	/^  bool TEditedMolecule::allQueryPresent(const std::vector<int> qA, const std::vector<int> qB,$/;"	f	class:OpenBabel::TEditedMolecule
alloc_symmetry_element	pointgroup.cpp	/^    alloc_symmetry_element( void )$/;"	f	class:OpenBabel::PointGroupPrivate
alternate	mcdlutil.cpp	/^  int alternate(OBMol * pmol, const std::vector<int> nH, std::vector<int>& bondOrders) {$/;"	f	namespace:OpenBabel
alternate	mcdlutil.cpp	/^  int alternate(const std::vector<int> aPosition,const std::vector<int> aCharge,$/;"	f	namespace:OpenBabel
analizeParity	mcdlutil.cpp	/^  int analizeParity(string data) {$/;"	f	namespace:OpenBabel
analizeParityBond	mcdlutil.cpp	/^  int analizeParityBond(string data) {$/;"	f	namespace:OpenBabel
analyzeOK	mcdlutil.cpp	/^  static bool analyzeOK(const std::vector<int> iA1,const std::vector<int> iA2, const std::vector<int> nH,$/;"	f	namespace:OpenBabel
anum	mcdlutil.cpp	/^    string anum;$/;"	m	class:OpenBabel::TSingleAtom	file:
areDuplicateAtoms	generic.cpp	/^  bool areDuplicateAtoms (vector3 v1, vector3 v2)$/;"	f	namespace:OpenBabel
aromatic	mcdlutil.cpp	/^  bool TSimpleMolecule::aromatic(int cycleSize, const std::vector<int> bondList,$/;"	f	class:OpenBabel::TSimpleMolecule
aromtyper	typer.cpp	/^  OBAromaticTyper  aromtyper;$/;"	m	namespace:OpenBabel	file:
arrangeFragments	mcdlutil.cpp	/^  void TemplateRedraw::arrangeFragments(std::vector<PartFragmentDefinition *>& list, int fragNo, double aspOptimal) {$/;"	f	class:OpenBabel::TemplateRedraw
arrangeMolecules	mcdlutil.cpp	/^  void TemplateRedraw::arrangeMolecules(std::vector<PartFragmentDefinition *>& extendedList, double aspOptimal) {$/;"	f	class:OpenBabel::TemplateRedraw
asnprintf	snprintf.c	/^int asnprintf (char **ptr, size_t str_m, const char *fmt, \/*args*\/ ...)$/;"	f
asprintf	snprintf.c	/^int asprintf(char **ptr, const char *fmt, \/*args*\/ ...)$/;"	f
assign	chains.cpp	/^    AssignStruct assign;  \/\/!< Assign - assign residue name, atom name and bond type to output$/;"	m	union:OpenBabel::_ByteCode	file:
assign	mcdlutil.cpp	/^    void assign(const PartFragmentDefinition source) {$/;"	f	class:OpenBabel::PartFragmentDefinition
assign_rules	patty.cpp	/^  void patty::assign_rules(std::vector<std::string> &rules)$/;"	f	class:OpenBabel::patty
assign_types	patty.cpp	/^  void patty::assign_types(OBMol &mol, std::vector<std::string> &atm_typ)$/;"	f	class:OpenBabel::patty
assign_types	patty.cpp	/^  void patty::assign_types(OBMol &mol,vector<int> &atm_typ)$/;"	f	class:OpenBabel::patty
assigned	tautomer.cpp	/^      OBAtom *assigned;$/;"	m	struct:OpenBabel::TautomerImpl::Level	file:
astereo	mcdlutil.cpp	/^    short int astereo;   \/*=0 - no stereo, =1 - R, = 2 -S,  = 3 - unknown*\/$/;"	m	class:OpenBabel::TSingleAtom	file:
at	mcdlutil.cpp	/^    short int at[2];     \/*Bond definition-atoms number in array ATOM*\/$/;"	m	class:OpenBabel::TSingleBond	file:
atom	chains.cpp	/^    int atom,bond;$/;"	m	struct:OpenBabel::__anon7	file:
atomBondChange	mcdlutil.cpp	/^  void TEditedMolecule::atomBondChange() {$/;"	f	class:OpenBabel::TEditedMolecule
atomCopy	mcdlutil.cpp	/^  void TSingleAtom::atomCopy(TSingleAtom * source) {$/;"	f	class:OpenBabel::TSingleAtom
atomDistanceMetric	mcdlutil.cpp	/^  double TSimpleMolecule::atomDistanceMetric(int an) {$/;"	f	class:OpenBabel::TSimpleMolecule
atomEquivalent	mcdlutil.cpp	/^  bool TSingleAtom::atomEquivalent(TSingleAtom * structure, TSingleAtom * query,$/;"	f	class:OpenBabel::TSingleAtom
atomRingToBondRing	ring.cpp	/^  std::vector<unsigned int> atomRingToBondRing(OBMol *mol, const std::vector<int> &atoms)$/;"	f	namespace:OpenBabel
atomid	chains.cpp	/^    int *atomid;$/;"	m	struct:OpenBabel::__anon6	file:
atomid	chains.cpp	/^    int atomid,elem;$/;"	m	struct:OpenBabel::__anon2	file:
atoms	canon.cpp	/^      std::vector<OBAtom*> atoms;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::PartialCode	file:
atomtyper	typer.cpp	/^  OBAtomTyper      atomtyper;$/;"	m	namespace:OpenBabel	file:
averageBondLength	mcdlutil.cpp	/^  double TSimpleMolecule::averageBondLength() {$/;"	f	class:OpenBabel::TSimpleMolecule
bSTested	mcdlutil.cpp	/^    std::vector<int> bSTested;$/;"	m	class:OpenBabel::TEditedMolecule	file:
bSTestedStore	mcdlutil.cpp	/^    std::vector<int> bSTestedStore;$/;"	m	class:OpenBabel::TEditedMolecule	file:
backtrackDepth	canon.cpp	/^      unsigned int backtrackDepth;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::State	file:
basic_unzip_streambuf	zipstream.h	/^class basic_unzip_streambuf :$/;"	c	namespace:zlib_stream
basic_unzip_streambuf	zipstreamimpl.h	/^basic_unzip_streambuf<charT, traits>::basic_unzip_streambuf(istream_reference istream,$/;"	f	class:basic_unzip_streambuf
basic_zip_istream	zipstream.h	/^class basic_zip_istream :$/;"	c	namespace:zlib_stream
basic_zip_istream	zipstreamimpl.h	/^basic_zip_istream<charT, traits>::basic_zip_istream(istream_reference istream,$/;"	f	class:basic_zip_istream
basic_zip_ostream	zipstream.h	/^class basic_zip_ostream :$/;"	c	namespace:zlib_stream
basic_zip_ostream	zipstreamimpl.h	/^basic_zip_ostream<charT, traits>::basic_zip_ostream(ostream_reference ostream,$/;"	f	class:basic_zip_ostream
basic_zip_streambuf	zipstream.h	/^class basic_zip_streambuf : public std::basic_streambuf<charT, traits>$/;"	c	namespace:zlib_stream
basic_zip_streambuf	zipstreamimpl.h	/^basic_zip_streambuf<charT, traits>::basic_zip_streambuf(ostream_reference ostream,$/;"	f	class:basic_zip_streambuf
bcount	chains.cpp	/^    int bcount;$/;"	m	struct:OpenBabel::__anon2	file:
bflags	chains.cpp	/^    int *bflags;$/;"	m	struct:OpenBabel::__anon6	file:
bitsoff	bitvec.cpp	/^  static unsigned int bitsoff[SETWORD] =$/;"	m	namespace:OpenBabel	file:
bitsperint	fingerprint.cpp	/^  const unsigned int OBFingerprint::bitsperint = 8 * sizeof(unsigned int);$/;"	m	class:OpenBabel::OBFingerprint	file:
blDenominator	mcdlutil.cpp	53;"	d	file:
blue	isomorphism.cpp	/^  static const char *blue   = "\\033[1;34m";$/;"	m	namespace:OpenBabel	file:
bn	mcdlutil.cpp	/^    int bn,w;$/;"	m	class:OpenBabel::StereoBondStore	file:
bond	chains.cpp	/^    int atom,bond;$/;"	m	struct:OpenBabel::__anon7	file:
bondConversion	mcdlutil.cpp	/^  int TSingleBond::bondConversion() {$/;"	f	class:OpenBabel::TSingleBond
bondCopy	mcdlutil.cpp	/^  void TSingleBond::bondCopy(TSingleBond * source) {$/;"	f	class:OpenBabel::TSingleBond
bondEnlarge	mcdlutil.cpp	/^  void TSimpleMolecule::bondEnlarge(int bN) {$/;"	f	class:OpenBabel::TSimpleMolecule
bondEquivalent	mcdlutil.cpp	/^  bool TSingleBond::bondEquivalent(TSingleBond * sBond, TSingleBond * qBond){$/;"	f	class:OpenBabel::TSingleBond
bondEquivalent	mcdlutil.cpp	/^  bool bondEquivalent(int bn1, int bn2, const std::vector<int> eqList, TSimpleMolecule & sm) {$/;"	f	namespace:OpenBabel
bondLength	mcdlutil.cpp	/^  double TSimpleMolecule::bondLength(int index) {$/;"	f	class:OpenBabel::TSimpleMolecule
bondUnitVector	mcdlutil.cpp	/^  void TSimpleMolecule::bondUnitVector(int bn, double& xv, double& yv) {$/;"	f	class:OpenBabel::TSimpleMolecule
bondValence	mcdlutil.cpp	/^  const int bondValence[NBONDTYPES] = {1,2,3,1,1,0,0,0,1,1,1};$/;"	m	namespace:OpenBabel	file:
bonds	canon.cpp	/^      std::vector<OBBond*> bonds;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::PartialCode	file:
bondsOverlapped	mcdlutil.cpp	/^  bool TSimpleMolecule::bondsOverlapped(int bN1, int bN2, double delta) {$/;"	f	class:OpenBabel::TSimpleMolecule
bondtyper	bondtyper.cpp	/^  OBBondTyper  bondtyper;$/;"	m	namespace:OpenBabel	file:
bottom	mcdlutil.cpp	/^    double left,top,right,bottom;$/;"	m	class:OpenBabel::Rect	file:
bounds	distgeom.cpp	/^    Eigen::MatrixXf bounds, preMet;$/;"	m	class:OpenBabel::DistanceGeometryPrivate	file:
breakeven_point	snprintf.c	344;"	d	file:
breakeven_point	snprintf.c	347;"	d	file:
breakeven_point	snprintf.c	350;"	d	file:
breakeven_point	snprintf.c	353;"	d	file:
breakeven_point	snprintf.c	361;"	d	file:
bstereo	mcdlutil.cpp	/^    short int bstereo;   \/* =0 - no, =1 - E , = 2 - Z, =3 E\/Z*\/$/;"	m	class:OpenBabel::TSingleBond	file:
bstereo_refs	mcdlutil.cpp	/^    vector<unsigned long> bstereo_refs;$/;"	m	class:OpenBabel::TSingleBond	file:
byte_buffer_type	zipstream.h	/^    typedef byte_type* byte_buffer_type;$/;"	t	class:zlib_stream::basic_unzip_streambuf
byte_buffer_type	zipstream.h	/^    typedef byte_type* byte_buffer_type;$/;"	t	class:zlib_stream::basic_zip_streambuf
byte_type	zipstream.h	/^    typedef unsigned char byte_type;$/;"	t	class:zlib_stream::basic_unzip_streambuf
byte_type	zipstream.h	/^    typedef unsigned char byte_type;$/;"	t	class:zlib_stream::basic_zip_streambuf
byte_vector_type	zipstream.h	/^    typedef std::vector<byte_type> byte_vector_type;$/;"	t	class:zlib_stream::basic_unzip_streambuf
byte_vector_type	zipstream.h	/^    typedef std::vector<byte_type> byte_vector_type;$/;"	t	class:zlib_stream::basic_zip_streambuf
calc_rms	obutil.cpp	/^  double calc_rms(double *r,double *f, unsigned int N)$/;"	f	namespace:OpenBabel
canonizeCycle	mcdlutil.cpp	/^  void TSimpleMolecule::canonizeCycle(int ringSize, std::vector<int> & bondList) {$/;"	f	class:OpenBabel::TSimpleMolecule
canonizeMCDL	mcdlutil.cpp	/^  int canonizeMCDL(const std::string atomBlock, std::vector<std::string> & structureList) {$/;"	f	namespace:OpenBabel
center_coords	obutil.cpp	/^  vector3 center_coords(double *c, unsigned int size)$/;"	f	namespace:OpenBabel
chainsparser	chains.cpp	/^  OBChainsParser chainsparser;$/;"	m	namespace:OpenBabel	file:
changeParity	mcdlutil.cpp	/^  std::string changeParity(std::string data) {$/;"	f	namespace:OpenBabel
changeParityBond	mcdlutil.cpp	/^  std::string changeParityBond(std::string data) {$/;"	f	namespace:OpenBabel
char_type	zipstream.h	/^    typedef char          char_type;$/;"	t	class:zlib_stream::basic_unzip_streambuf
char_type	zipstream.h	/^    typedef char          char_type;$/;"	t	class:zlib_stream::basic_zip_streambuf
char_type	zipstream.h	/^    typedef char char_type;$/;"	t	class:zlib_stream::basic_zip_ostream
char_vector_type	zipstream.h	/^    typedef std::vector<char_type> char_vector_type;$/;"	t	class:zlib_stream::basic_unzip_streambuf
char_vector_type	zipstream.h	/^    typedef std::vector<char_type> char_vector_type;$/;"	t	class:zlib_stream::basic_zip_streambuf
chargeConversion	mcdlutil.cpp	/^  int TSingleAtom::chargeConversion() {$/;"	f	class:OpenBabel::TSingleAtom
chargeDeltaValency	mcdlutil.cpp	/^  int TSingleAtom::chargeDeltaValency(int atomNo) {$/;"	f	class:OpenBabel::TSingleAtom
chargeVal	mcdlutil.cpp	/^  const int chargeVal[NELEMMCDL] = {  \/\/0 - dummy$/;"	m	namespace:OpenBabel	file:
check	pointgroup.cpp	/^    int     (*check)( void ) ;        \/* Additional verification routine, not used  *\/$/;"	m	struct:OpenBabel::__anon8	file:
checkBonds	isomorphism.cpp	/^      bool checkBonds(State &state, OBQueryAtom *queryAtom)$/;"	f	class:OpenBabel::VF2Mapper
checkForMap	isomorphism.cpp	/^      bool checkForMap(State &state)$/;"	f	class:OpenBabel::VF2Mapper
checkOverlapped	mcdlutil.cpp	/^  bool TSimpleMolecule::checkOverlapped() {$/;"	f	class:OpenBabel::TSimpleMolecule
check_crc	zipstreamimpl.h	/^basic_zip_istream<charT, traits>::check_crc(void)$/;"	f	class:basic_zip_istream
check_data_size	zipstreamimpl.h	/^basic_zip_istream<charT, traits>::check_data_size(void) const$/;"	f	class:basic_zip_istream
check_header	zipstreamimpl.h	/^basic_unzip_streambuf<charT, traits>::check_header(void)$/;"	f	class:basic_unzip_streambuf
check_transform_order	pointgroup.cpp	/^    check_transform_order( SYMMETRY_ELEMENT *elem )$/;"	f	class:OpenBabel::PointGroupPrivate
check_transform_quality	pointgroup.cpp	/^    check_transform_quality( SYMMETRY_ELEMENT *elem )$/;"	f	class:OpenBabel::PointGroupPrivate
clean_paired_atoms	pointgroup.cpp	/^    void clean_paired_atoms(SYMMETRY_ELEMENT *elem)$/;"	f	class:OpenBabel::PointGroupPrivate
clear	mcdlutil.cpp	/^  void TSimpleMolecule::clear() {$/;"	f	class:OpenBabel::TSimpleMolecule
clear	mcdlutil.cpp	/^  void TemplateRedraw::clear() {$/;"	f	class:OpenBabel::TemplateRedraw
clone	mcdlutil.cpp	/^  TSingleAtom * TSingleAtom::clone() {$/;"	f	class:OpenBabel::TSingleAtom
clone	mcdlutil.cpp	/^  TSingleBond * TSingleBond::clone() {$/;"	f	class:OpenBabel::TSingleBond
code	canon.cpp	/^      PartialCode code;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::State	file:
code	canon.cpp	/^      std::vector<unsigned short> code;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::FullCode	file:
compareAtoms	mcdlutil.cpp	/^  bool compareAtoms(int a1, int a2, const std::vector<std::vector<int> *> aeqList) {$/;"	f	namespace:OpenBabel
compareStringsNumbers	mcdlutil.cpp	/^  int compareStringsNumbers(string s1, string s2) {$/;"	f	namespace:OpenBabel
compare_axes	pointgroup.cpp	/^    compare_axes( const void *a, const void *b )$/;"	f	class:OpenBabel::PointGroupPrivate
construct_c_matrix	chiral.cpp	/^  void construct_c_matrix(OBMol &mol,std::vector<std::vector<double > > &m)$/;"	f	namespace:OpenBabel
construct_g_matrix	chiral.cpp	/^  void construct_g_matrix(OBMol &mol, std::vector<std::vector<double> > &m)$/;"	f	namespace:OpenBabel
convert_matrix_f	matrix.cpp	/^bool convert_matrix_f(double *src, std::vector<std::vector<double> > &dst,$/;"	f	namespace:OpenBabel
convert_matrix_f	matrix.cpp	/^bool convert_matrix_f(std::vector<std::vector<double> > &src, double *dst)$/;"	f	namespace:OpenBabel
convert_matrix_f_ff	matrix.cpp	/^bool convert_matrix_f_ff(double *src, double **dst, int rows, int cols)$/;"	f	namespace:OpenBabel
convert_matrix_ff	matrix.cpp	/^bool convert_matrix_ff(double **src, std::vector<std::vector<double> > &dst,$/;"	f	namespace:OpenBabel
convert_matrix_ff	matrix.cpp	/^bool convert_matrix_ff(std::vector<std::vector<double> > &src, double **dst)$/;"	f	namespace:OpenBabel
convert_matrix_ff_f	matrix.cpp	/^bool convert_matrix_ff_f(double **src, double *dst, int rows, int cols)$/;"	f	namespace:OpenBabel
coordinatesPrepare	mcdlutil.cpp	/^  int TemplateRedraw::coordinatesPrepare(TEditedMolecule& sm, int kk, int anTemplateNo) {$/;"	f	class:OpenBabel::TemplateRedraw
copper	mcdlutil.cpp	/^  const int copper[NCOPPERATOMS] ={29,47,79};$/;"	m	namespace:OpenBabel	file:
correctDblBondStereo	mcdlutil.cpp	/^  bool TSimpleMolecule::correctDblBondStereo() {$/;"	f	class:OpenBabel::TSimpleMolecule
correctOverlapped	mcdlutil.cpp	/^  int TSimpleMolecule::correctOverlapped() {$/;"	f	class:OpenBabel::TSimpleMolecule
count	chains.cpp	/^    BinOpStruct count;    \/\/!< Count - test the number of eval bonds$/;"	m	union:OpenBabel::_ByteCode	file:
count	chains.cpp	/^    short count;     \/\/!< expected valence for this atom type$/;"	m	struct:OpenBabel::Template	file:
count_assigned_bonds	kekulize.cpp	/^  int count_assigned_bonds(std::vector<OBBond *> &bondsThisRing,$/;"	f	namespace:OpenBabel
counter	locale.cpp	/^    unsigned int counter; \/\/ Reference counter -- ensures balance in SetLocale\/RestoreLocale calls$/;"	m	class:OpenBabel::OBLocalePrivate	file:
createStereoLists	mcdlutil.cpp	/^  void createStereoLists(OBMol * pmol, std::vector<int>& bondStereoList, std::vector<int>& atomStereoList, std::vector<int>& eqList) {$/;"	f	namespace:OpenBabel
credits	snprintf.c	/^static char credits[] = "\\n\\$/;"	v	file:
cromium	mcdlutil.cpp	/^  const int cromium[NCHROMIUMATOMS] ={24,42,74};$/;"	m	namespace:OpenBabel	file:
currentpos	zipstreamimpl.h	/^  basic_unzip_streambuf<charT, traits>::currentpos()$/;"	f	class:basic_unzip_streambuf
currvalence	mcdlutil.cpp	/^    short int currvalence;$/;"	m	class:OpenBabel::TSingleAtom	file:
cutoff	confsearch.cpp	/^      const double cutoff;$/;"	m	class:OpenBabel::OBDiversePoses	file:
data	chains.cpp	/^    const char *data; \/\/!< pseudo-SMILES definition of side-chain$/;"	m	struct:OpenBabel::__anon1	file:
db	mcdlutil.cpp	/^    short int db;        \/*Ring\/Chain conditions*\/$/;"	m	class:OpenBabel::TSingleBond	file:
debug	distgeom.cpp	/^    bool debug;$/;"	m	class:OpenBabel::DistanceGeometryPrivate	file:
defA	mcdlutil.cpp	/^  void TSimpleMolecule::defA(int& currNumDef, int atomClean, int sPN, int baseCycle, std::vector<int>& atomDefine, const std::vector<int> listAtomClean,$/;"	f	class:OpenBabel::TSimpleMolecule
defC	mcdlutil.cpp	/^  void TSimpleMolecule::defC(int& currNumDef, int baseCycle, int atomClean, std::vector<int>& cycleDefine,$/;"	f	class:OpenBabel::TSimpleMolecule
defineAtomConn	mcdlutil.cpp	/^  void TSimpleMolecule::defineAtomConn() {$/;"	f	class:OpenBabel::TSimpleMolecule
defineBondConn	mcdlutil.cpp	/^  void TSimpleMolecule::defineBondConn(neighbourlist *bondConnection) {$/;"	f	class:OpenBabel::TSimpleMolecule
deleteAtom	mcdlutil.cpp	/^  void TSimpleMolecule::deleteAtom(int index) {$/;"	f	class:OpenBabel::TSimpleMolecule
deleteBond	mcdlutil.cpp	/^  void TSimpleMolecule::deleteBond(int index) {$/;"	f	class:OpenBabel::TSimpleMolecule
deleteIntElement	mcdlutil.cpp	/^  void deleteIntElement(std::vector<int> * source, int index) {$/;"	f	namespace:OpenBabel
destroy_symmetry_element	pointgroup.cpp	/^    destroy_symmetry_element( SYMMETRY_ELEMENT *elem )$/;"	f	class:OpenBabel::PointGroupPrivate
detail	zipstream.h	/^namespace detail$/;"	n	namespace:zlib_stream
determineBondsOrder	mcdlutil.cpp	/^  static int determineBondsOrder(const std::vector<int> iA1, const std::vector<int> iA2,$/;"	f	namespace:OpenBabel
directBondAss	mcdlutil.cpp	/^  void TEditedMolecule::directBondAss(int& bnq, bool& test, bool& test1, bool const* const* beq,$/;"	f	class:OpenBabel::TEditedMolecule
direction	pointgroup.cpp	/^      double  direction[ DIMENSION ] ;$/;"	m	struct:OpenBabel::PointGroupPrivate::_SYMMETRY_ELEMENT_	file:
distance	pointgroup.cpp	/^      double  distance ;$/;"	m	struct:OpenBabel::PointGroupPrivate::_SYMMETRY_ELEMENT_	file:
dst	chains.cpp	/^    int src,dst;$/;"	m	struct:OpenBabel::__anon3	file:
elem	chains.cpp	/^    BinOpStruct elem;     \/\/!< Element - test the element of current atom$/;"	m	union:OpenBabel::_ByteCode	file:
elem	chains.cpp	/^    int atomid,elem;$/;"	m	struct:OpenBabel::__anon2	file:
elem	chains.cpp	/^    short elem;      \/\/!< atomic number of this element$/;"	m	struct:OpenBabel::Template	file:
encoder	mcdlutil.cpp	/^  int TSingleAtom::encoder() {$/;"	f	class:OpenBabel::TSingleAtom
enumerator	mcdlutil.cpp	/^    int enumerator;$/;"	m	class:OpenBabel::TSingleAtom	file:
enumerator	mcdlutil.cpp	/^    int enumerator;$/;"	m	class:OpenBabel::TSingleBond	file:
equivalenceList	mcdlutil.cpp	/^  void equivalenceList(OBMol * pmol,  std::vector<int>& eqList) {$/;"	f	namespace:OpenBabel
equivalenceList	mcdlutil.cpp	/^  void equivalenceList(const std::vector<int> aPosition,const std::vector<int> aCharge,$/;"	f	namespace:OpenBabel
equivalentAtoms	pointgroup.cpp	/^    bool equivalentAtoms(OBAtom &a1, OBAtom &a2)$/;"	f	class:OpenBabel::PointGroupPrivate
establish_pairs	pointgroup.cpp	/^    establish_pairs( SYMMETRY_ELEMENT *elem )$/;"	f	class:OpenBabel::PointGroupPrivate
etab	data.cpp	/^  OBElementTable   etab;$/;"	m	namespace:OpenBabel	file:
eval	chains.cpp	/^    MonOpStruct eval;     \/\/!< Eval - push current neighbors onto the stack$/;"	m	union:OpenBabel::_ByteCode	file:
eval_optimization_target_function	pointgroup.cpp	/^    eval_optimization_target_function( SYMMETRY_ELEMENT *elem, int *finish )$/;"	f	class:OpenBabel::PointGroupPrivate
exactAtom	mcdlutil.cpp	/^  const int exactAtom[NEXACTATOMS]={6,14,5,50,82,8,16,34,52,7,15,33,51,9,17,35,53,32,13,26,80};$/;"	m	namespace:OpenBabel	file:
expandKekulize	kekulize.cpp	/^  bool expandKekulize(OBMol *mol, int bond_idx,$/;"	f	namespace:OpenBabel
expand_cycle	kekulize.cpp	/^  int expand_cycle (OBMol *mol, OBAtom *atom, OBBitVec &avisit, OBBitVec &cvisit,$/;"	f	namespace:OpenBabel
expand_kekulize	kekulize.cpp	/^  bool OBMol::expand_kekulize(int bond_idx,$/;"	f	class:OpenBabel::OBMol
expand_kekulize_lssr	kekulize.cpp	/^  bool expand_kekulize_lssr(OBMol *mol,$/;"	f	namespace:OpenBabel
expandcycle	kekulize.cpp	/^  bool OBMol::expandcycle (OBAtom *atom, OBBitVec &avisit, const OBBitVec &potAromBonds)$/;"	f	class:OpenBabel::OBMol
extractFragment	mcdlutil.cpp	/^  TEditedMolecule * TEditedMolecule::extractFragment(int atomN, std::vector<int> * enumerator) {$/;"	f	class:OpenBabel::TEditedMolecule
extract_thermochemistry	data_utilities.cpp	/^bool extract_thermochemistry(OpenBabel::OBMol  &mol,$/;"	f	namespace:OpenBabel
fAtom	mcdlutil.cpp	/^    std::vector<TSingleAtom*> fAtom;$/;"	m	class:OpenBabel::TSimpleMolecule	file:
fBond	mcdlutil.cpp	/^    std::vector<TSingleBond*> fBond;$/;"	m	class:OpenBabel::TSimpleMolecule	file:
fIOPT10	mcdlutil.cpp	/^    bool fIOPT10;   \/\/charge sensitivite$/;"	m	class:OpenBabel::TEditedMolecule	file:
fIOPT11	mcdlutil.cpp	/^    bool fIOPT11;   \/\/isotopes difference$/;"	m	class:OpenBabel::TEditedMolecule	file:
fIOPT12	mcdlutil.cpp	/^    int  fIOPT12;   \/\/stereo bond change$/;"	m	class:OpenBabel::TEditedMolecule	file:
fIOPT13	mcdlutil.cpp	/^    bool fIOPT13;   \/\/semipolar bond as double$/;"	m	class:OpenBabel::TEditedMolecule	file:
fIncludedList	mcdlutil.cpp	/^    std::vector<int>* fIncludedList;$/;"	m	class:OpenBabel::TEditedMolecule	file:
fIsQueryPrepare	mcdlutil.cpp	/^    bool queryStereoQ,fIsQueryPrepare;$/;"	m	class:OpenBabel::TEditedMolecule	file:
fast_memcpy	snprintf.c	364;"	d	file:
fast_memset	snprintf.c	371;"	d	file:
fcond	chains.cpp	/^    union _ByteCode *fcond;$/;"	m	struct:OpenBabel::__anon5	typeref:union:OpenBabel::__anon5::_ByteCode	file:
fill_input_buffer	zipstreamimpl.h	/^basic_unzip_streambuf<charT, traits>::fill_input_buffer(void)$/;"	f	class:basic_unzip_streambuf
findAlternateSinglets	mcdlutil.cpp	/^  static int findAlternateSinglets(const std::vector<int>iA1, const std::vector<int>iA2, const std::vector<int> nH,$/;"	f	namespace:OpenBabel
findCenterAndNormal	ring.cpp	/^  bool OBRing::findCenterAndNormal(vector3 & center, vector3 &norm1, vector3 &norm2)$/;"	f	class:OpenBabel::OBRing
findFiles	dlhandler_unix.cpp	/^int DLHandler::findFiles (std::vector <std::string>& file_list,$/;"	f	class:DLHandler
findFiles	dlhandler_unix.cpp	/^int DLHandler::findFiles (std::vector<std::string>& file_list,$/;"	f	class:DLHandler
findFiles	dlhandler_win32.cpp	/^int DLHandler :: findFiles (std::vector<std::string>& file_list,const std::string &filename)$/;"	f	class:DLHandler
findFiles	dlhandler_win32.cpp	/^int DLHandler :: findFiles (std::vector<std::string>& file_list,const std::string &pattern,const std::string &path)$/;"	f	class:DLHandler
findMetalloceneBonds	canon.cpp	/^  void findMetalloceneBonds(std::vector<OBBond*> &bonds, OBMol *mol, const std::vector<unsigned int> &symmetry_classes)$/;"	f	namespace:OpenBabel
findStartAtoms	canon.cpp	/^    static std::vector<OBAtom*> findStartAtoms(OBMol *mol, const OBBitVec &fragment, const std::vector<unsigned int> &symmetry_classes)$/;"	f	struct:OpenBabel::CanonicalLabelsImpl
find_c2_axes	pointgroup.cpp	/^    find_c2_axes(void)$/;"	f	class:OpenBabel::PointGroupPrivate
find_center_of_something	pointgroup.cpp	/^    find_center_of_something( void )$/;"	f	class:OpenBabel::PointGroupPrivate
find_higher_axes	pointgroup.cpp	/^    find_higher_axes(void)$/;"	f	class:OpenBabel::PointGroupPrivate
find_improper_axes	pointgroup.cpp	/^    find_improper_axes(void)$/;"	f	class:OpenBabel::PointGroupPrivate
find_infinity_axis	pointgroup.cpp	/^    find_infinity_axis(void)$/;"	f	class:OpenBabel::PointGroupPrivate
find_inversion_centers	pointgroup.cpp	/^    find_inversion_centers(void)$/;"	f	class:OpenBabel::PointGroupPrivate
find_planes	pointgroup.cpp	/^    find_planes(void)$/;"	f	class:OpenBabel::PointGroupPrivate
find_symmetry_elements	pointgroup.cpp	/^    find_symmetry_elements( void )$/;"	f	class:OpenBabel::PointGroupPrivate
finished	zipstreamimpl.h	/^void basic_zip_ostream<charT, traits>::finished(void)$/;"	f	class:basic_zip_ostream
flag	chains.cpp	/^    int flag;        \/\/!< binary flag representing this atom type$/;"	m	struct:OpenBabel::Template	file:
flag	chains.cpp	/^    int flag;$/;"	m	struct:OpenBabel::__anon3	file:
flipSmall	mcdlutil.cpp	/^  void TSimpleMolecule::flipSmall(int cHB) {$/;"	f	class:OpenBabel::TSimpleMolecule
floatGrid	griddata.cpp	/^    OBFloatGrid  floatGrid;$/;"	m	class:OpenBabel::GridDataPrivate	file:
flush	zipstreamimpl.h	/^std::streamsize basic_zip_streambuf<charT, traits>::flush(void)$/;"	f	class:basic_zip_streambuf
fragFirstAtomNo	mcdlutil.cpp	/^    int fragID1,fragID2,fragID3,fragFirstAtomNo;$/;"	m	class:OpenBabel::PartFragmentDefinition	file:
fragHeight	mcdlutil.cpp	/^    double fragWidth,fragHeight,fragTop,fragLeft;$/;"	m	class:OpenBabel::PartFragmentDefinition	file:
fragID1	mcdlutil.cpp	/^    int fragID1,fragID2,fragID3,fragFirstAtomNo;$/;"	m	class:OpenBabel::PartFragmentDefinition	file:
fragID2	mcdlutil.cpp	/^    int fragID1,fragID2,fragID3,fragFirstAtomNo;$/;"	m	class:OpenBabel::PartFragmentDefinition	file:
fragID3	mcdlutil.cpp	/^    int fragID1,fragID2,fragID3,fragFirstAtomNo;$/;"	m	class:OpenBabel::PartFragmentDefinition	file:
fragIndex	mcdlutil.cpp	/^    int fragIndex;$/;"	m	class:OpenBabel::TSingleAtom	file:
fragLeft	mcdlutil.cpp	/^    double fragWidth,fragHeight,fragTop,fragLeft;$/;"	m	class:OpenBabel::PartFragmentDefinition	file:
fragTop	mcdlutil.cpp	/^    double fragWidth,fragHeight,fragTop,fragLeft;$/;"	m	class:OpenBabel::PartFragmentDefinition	file:
fragWidth	mcdlutil.cpp	/^    double fragWidth,fragHeight,fragTop,fragLeft;$/;"	m	class:OpenBabel::PartFragmentDefinition	file:
fragment	canon.cpp	/^      const OBBitVec &fragment;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::State	file:
fragmentCount	mcdlutil.cpp	/^    int fragmentCount;$/;"	m	class:OpenBabel::PartFragmentDefinition	file:
fragmentSearch	mcdlutil.cpp	/^  bool TEditedMolecule::fragmentSearch(TEditedMolecule * molecule1, std::vector<int>* bondLabel) {$/;"	f	class:OpenBabel::TEditedMolecule
fragmentSearch	mcdlutil.cpp	/^  bool fragmentSearch(OBMol * query, OBMol * structure) {$/;"	f	namespace:OpenBabel
fragmentSearch	mcdlutil.cpp	/^  bool fragmentSearch(const std::vector<int> aPositionQuery, const std::vector<int> iA1Query,$/;"	f	namespace:OpenBabel
fragmentSecond	mcdlutil.cpp	/^  int TSimpleMolecule::fragmentSecond(int sphere, int att, int secAt, const std::vector<int> a,$/;"	f	class:OpenBabel::TSimpleMolecule
from	canon.cpp	/^      std::vector<unsigned short> from;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::PartialCode	file:
fsastart	mcdlutil.cpp	/^  const string fsastart="{SA:";$/;"	m	namespace:OpenBabel	file:
fsbstart	mcdlutil.cpp	/^  const string fsbstart="{SB:";$/;"	m	namespace:OpenBabel	file:
functor	isomorphism.cpp	/^        Functor &functor;$/;"	m	struct:OpenBabel::VF2Mapper::State	file:
generateDiagram	mcdlutil.cpp	/^  void generateDiagram(OBMol * pmol) {$/;"	f	namespace:OpenBabel
generateDiagram	mcdlutil.cpp	/^  void generateDiagram(OBMol * pmol, std::ostream & ofs) {$/;"	f	namespace:OpenBabel
generateDiagram	mcdlutil.cpp	/^  void generateDiagram(const std::vector<int> iA1, const std::vector<int> iA2,$/;"	f	namespace:OpenBabel
getAtom	mcdlutil.cpp	/^  TSingleAtom * TSimpleMolecule::getAtom(int index) {$/;"	f	class:OpenBabel::TSimpleMolecule
getAtomMCDL	mcdlutil.cpp	/^  std::string getAtomMCDL(OBMol * pmol, int ntatoms, const std::vector<int> ix, const std::vector<int> aNumber, const std::vector<int> atomStereoList, const std::vector<int> eqList) {$/;"	f	namespace:OpenBabel
getAtomSymbol	mcdlutil.cpp	/^  std::string getAtomSymbol(TSimpleMolecule & sm, int atAtom) {$/;"	f	namespace:OpenBabel
getAtomSymbol	mcdlutil.cpp	/^  std::string getAtomSymbol(TSimpleMolecule & sm, int atAtom, int atEx, int priority, string ndData) {$/;"	f	namespace:OpenBabel
getBond	mcdlutil.cpp	/^  TSingleBond * TSimpleMolecule::getBond(int index) {$/;"	f	class:OpenBabel::TSimpleMolecule
getBondMCDL	mcdlutil.cpp	/^  std::string getBondMCDL(OBMol * pmol, int nbStore, int ntatoms, const std::vector<int> ix, const std::vector<int> aNumber, int bonds[MAXBONDS][4], const std::vector<int> bondStereoList, const std::vector<int> eqList) {$/;"	f	namespace:OpenBabel
getConvDirectory	dlhandler_unix.cpp	/^bool DLHandler::getConvDirectory(string& convPath)$/;"	f	class:DLHandler
getConvDirectory	dlhandler_win32.cpp	/^bool DLHandler::getConvDirectory(string& convPath)$/;"	f	class:DLHandler
getDescriptor	canon.cpp	/^      int getDescriptor(const std::vector<unsigned int> &symmetry_classes, const std::vector<unsigned int> &labels) const$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::StereoCenter
getFormatFilePattern	dlhandler_unix.cpp	/^const char* DLHandler::getFormatFilePattern()$/;"	f	class:DLHandler
getFormatFilePattern	dlhandler_win32.cpp	/^const char* DLHandler::getFormatFilePattern()$/;"	f	class:DLHandler
getFragment	canon.cpp	/^  OBBitVec getFragment(OBAtom *atom, OBAtom *skip, const OBBitVec &mask)$/;"	f	namespace:OpenBabel
getFragment	canon.cpp	/^  OBBitVec getFragment(OBAtom *atom, const OBBitVec &mask, const std::vector<OBBond*> &metalloceneBonds = std::vector<OBBond*>())$/;"	f	namespace:OpenBabel
getLabel	canon.cpp	/^      inline unsigned int getLabel(const StereoCenter &c) const$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::SortStereoCenters
getMolfile	mcdlutil.cpp	/^  void TSimpleMolecule::getMolfile(std::ostream & data) {$/;"	f	class:OpenBabel::TSimpleMolecule
getNH	mcdlutil.cpp	/^  int TSimpleMolecule::getNH(int atomNo) {$/;"	f	class:OpenBabel::TSimpleMolecule
getSeparator	dlhandler_unix.cpp	/^char DLHandler::getSeparator()$/;"	f	class:DLHandler
getSeparator	dlhandler_win32.cpp	/^char DLHandler::getSeparator()$/;"	f	class:DLHandler
getValence	mcdlutil.cpp	/^  int TSingleBond::getValence() {$/;"	f	class:OpenBabel::TSingleBond
get_bonds_of_ring	kekulize.cpp	/^  void get_bonds_of_ring(OBMol *mol, OBRing *ring, std::vector<OBBond *> &ring_bonds) {$/;"	f	namespace:OpenBabel
get_crc	zipstreamimpl.h	/^basic_unzip_streambuf<charT, traits>::get_crc(void) const$/;"	f	class:basic_unzip_streambuf
get_crc	zipstreamimpl.h	/^basic_zip_streambuf<charT, traits>:: get_crc(void) const$/;"	f	class:basic_zip_streambuf
get_gzip_crc	zipstreamimpl.h	/^basic_zip_istream<charT, traits>::get_gzip_crc(void) const$/;"	f	class:basic_zip_istream
get_gzip_data_size	zipstreamimpl.h	/^basic_zip_istream<charT, traits>::get_gzip_data_size(void) const$/;"	f	class:basic_zip_istream
get_in_size	zipstreamimpl.h	/^basic_unzip_streambuf<charT, traits>::get_in_size(void) const$/;"	f	class:basic_unzip_streambuf
get_in_size	zipstreamimpl.h	/^basic_zip_streambuf<charT, traits>::get_in_size(void) const$/;"	f	class:basic_zip_streambuf
get_istream	zipstreamimpl.h	/^basic_unzip_streambuf<charT, traits>::get_istream(void)$/;"	f	class:basic_unzip_streambuf
get_ostream	zipstreamimpl.h	/^basic_zip_streambuf<charT, traits>::get_ostream(void) const$/;"	f	class:basic_zip_streambuf
get_out_size	zipstreamimpl.h	/^basic_unzip_streambuf<charT, traits>::get_out_size(void) const$/;"	f	class:basic_unzip_streambuf
get_out_size	zipstreamimpl.h	/^basic_zip_streambuf<charT, traits>::get_out_size(void) const$/;"	f	class:basic_zip_streambuf
get_params	pointgroup.cpp	/^    get_params( SYMMETRY_ELEMENT *elem, double values[] )$/;"	f	class:OpenBabel::PointGroupPrivate
get_rmat	obutil.cpp	/^  void get_rmat(double *rvec,double *r,double *f,int size)$/;"	f	namespace:OpenBabel
get_roots_3_3	obutil.cpp	/^  static int get_roots_3_3(double mat[3][3], double roots[3])$/;"	f	namespace:OpenBabel
get_zerr	zipstreamimpl.h	/^basic_unzip_streambuf<charT, traits>::get_zerr(void) const$/;"	f	class:basic_unzip_streambuf
get_zerr	zipstreamimpl.h	/^int basic_zip_streambuf<charT, traits>::get_zerr(void) const$/;"	f	class:basic_zip_streambuf
get_zip_stream	zipstreamimpl.h	/^basic_unzip_streambuf<charT, traits>::get_zip_stream(void)$/;"	f	class:basic_unzip_streambuf
getorden	kekulize.cpp	/^  int OBMol::getorden( OBAtom *atom)$/;"	f	class:OpenBabel::OBMol
green	isomorphism.cpp	/^  static const char *green  = "\\033[1;32m";$/;"	m	namespace:OpenBabel	file:
groupRedraw	mcdlutil.cpp	/^  int OBMCDL groupRedraw(OBMol * pmol, int bondN, int atomN, bool atomNInGroup) {$/;"	f	namespace:OpenBabel
group_name	pointgroup.cpp	/^    const char *  group_name ;        \/* Canonical group name                        *\/$/;"	m	struct:OpenBabel::__anon8	file:
gtd	mcdlutil.cpp	/^    int gtd;        \/*Depth of atom in molecule according to GTD*\/$/;"	m	class:OpenBabel::TSingleAtom	file:
gz_ascii_flag	zipstream.h	/^    const int gz_ascii_flag =  0x01; \/* bit 0 set: file probably ascii text *\/$/;"	m	namespace:zlib_stream::detail
gz_comment	zipstream.h	/^    const int gz_comment    =  0x10; \/* bit 4 set: file comment present *\/$/;"	m	namespace:zlib_stream::detail
gz_extra_field	zipstream.h	/^    const int gz_extra_field = 0x04; \/* bit 2 set: extra field present *\/$/;"	m	namespace:zlib_stream::detail
gz_head_crc	zipstream.h	/^    const int gz_head_crc    = 0x02; \/* bit 1 set: header CRC present *\/$/;"	m	namespace:zlib_stream::detail
gz_magic	zipstream.h	/^    const int gz_magic[2] = {0x1f, 0x8b}; \/* gzip magic header *\/$/;"	m	namespace:zlib_stream::detail
gz_orig_name	zipstream.h	/^    const int gz_orig_name  =  0x08; \/* bit 3 set: original file name present *\/$/;"	m	namespace:zlib_stream::detail
gz_reserved	zipstream.h	/^    const int gz_reserved   =  0xE0; \/* bits 5..7: reserved *\/$/;"	m	namespace:zlib_stream::detail
hVal	mcdlutil.cpp	/^	const int hVal[NELEMMCDL] = {$/;"	m	namespace:OpenBabel	file:
halogens	mcdlutil.cpp	/^  const int halogens[NHALOGENS] = {9,17,35,53,85};$/;"	m	namespace:OpenBabel	file:
hasOverlapped	mcdlutil.cpp	/^  int TSimpleMolecule::hasOverlapped(double delta, bool findFirst) {$/;"	f	class:OpenBabel::TSimpleMolecule
has_leftover_electrons	kekulize.cpp	/^  bool has_leftover_electrons(OBMol *mol, std::vector<int> &atomState)$/;"	f	namespace:OpenBabel
has_leftover_electrons	kekulize.cpp	/^  bool has_leftover_electrons(OBMol *mol, std::vector<int> &atomState,$/;"	f	namespace:OpenBabel
has_no_leftover_electrons	kekulize.cpp	/^  bool OBMol::has_no_leftover_electrons(std::vector<int> &atomState)$/;"	f	class:OpenBabel::OBMol
heavyMetals	mcdlutil.cpp	/^  const int heavyMetals[NHEAVY_METALS] = {$/;"	m	namespace:OpenBabel	file:
hetero	mcdlutil.cpp	/^  const int hetero[NHETERO] = {7,8,14,15,16,33,34,51,52,84};$/;"	m	namespace:OpenBabel	file:
hydrogenValency	mcdlutil.cpp	/^  int hydrogenValency(int na) {   \/\/Hydrogen valency$/;"	f	namespace:OpenBabel
hydrogens	confsearch.cpp	/^      OBBitVec hydrogens;$/;"	m	class:OpenBabel::OBDiversePoses	file:
ident	chains.cpp	/^    BinOpStruct ident;    \/\/!< Ident - test the atom for backbone identity$/;"	m	union:OpenBabel::_ByteCode	file:
identify_point_group	pointgroup.cpp	/^    const char *identify_point_group( void )$/;"	f	class:OpenBabel::PointGroupPrivate
identityCodes	canon.cpp	/^      std::vector<FullCode> identityCodes;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::State	file:
idx1	kekulize.cpp	/^      size_t idx1;$/;"	m	struct:OpenBabel::Kekulize::stateDiff_t	file:
idx2	kekulize.cpp	/^      size_t idx2;$/;"	m	struct:OpenBabel::Kekulize::stateDiff_t	file:
idxb	kekulize.cpp	/^      size_t idxb;$/;"	m	struct:OpenBabel::Kekulize::stateDiff_t	file:
ignore	tokenst.cpp	/^  std::istream& ignore(std::istream& ifs, const std::string& txt)$/;"	f	namespace:OpenBabel
implementAtomStereo	mcdlutil.cpp	/^  void implementAtomStereo(std::vector<int>& iA1, std::vector<int>& iA2, std::vector<int>& stereoBonds, const std::vector<double>rx, const std::vector<double> ry, int acount, int bcount, std::string astereo) {$/;"	f	namespace:OpenBabel
implementBondStereo	mcdlutil.cpp	/^  void implementBondStereo(const std::vector<int> iA1, const std::vector<int> iA2, std::vector<double>& rx, std::vector<double>& ry, int acount, int bcount, std::string bstereo) {$/;"	f	namespace:OpenBabel
incrementAssignment	mcdlutil.cpp	/^  static bool incrementAssignment(std::vector<int>& bondAssignment, int nAss) {$/;"	f	namespace:OpenBabel
incrementValues	mcdlutil.cpp	/^  bool incrementValues(std::vector<int>& currentValues, const std::vector<int> maxValues) {$/;"	f	namespace:OpenBabel
index	chains.cpp	/^    int index;$/;"	m	struct:OpenBabel::__anon2	file:
index	chains.cpp	/^    int index;$/;"	m	struct:OpenBabel::__anon3	file:
indexOf	mcdlutil.cpp	/^  int indexOf(const string instring, const string substring, int fromPos=0) {$/;"	f	namespace:OpenBabel
indexes	canon.cpp	/^      std::vector<unsigned int> indexes;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::StereoCenter	file:
init_axis_parameters	pointgroup.cpp	/^    init_axis_parameters( double a[3], double b[3], double c[3] )$/;"	f	class:OpenBabel::PointGroupPrivate
init_c2_axis	pointgroup.cpp	/^    init_c2_axis( int i, int j, const double support[ DIMENSION ] )$/;"	f	class:OpenBabel::PointGroupPrivate
init_higher_axis	pointgroup.cpp	/^    init_higher_axis( int ia, int ib, int ic )$/;"	f	class:OpenBabel::PointGroupPrivate
init_improper_axis	pointgroup.cpp	/^    init_improper_axis( int ia, int ib, int ic )$/;"	f	class:OpenBabel::PointGroupPrivate
init_inversion_center	pointgroup.cpp	/^    init_inversion_center( void )$/;"	f	class:OpenBabel::PointGroupPrivate
init_mirror_plane	pointgroup.cpp	/^    init_mirror_plane( int i, int j )$/;"	f	class:OpenBabel::PointGroupPrivate
init_ultimate_axis	pointgroup.cpp	/^    init_ultimate_axis(void)$/;"	f	class:OpenBabel::PointGroupPrivate
init_ultimate_plane	pointgroup.cpp	/^    init_ultimate_plane( void )$/;"	f	class:OpenBabel::PointGroupPrivate
initialize	zipstreamimpl.h	/^  basic_unzip_streambuf<charT, traits>::initialize(int window_size)$/;"	f	class:basic_unzip_streambuf
intToStr	mcdlutil.cpp	/^  string intToStr(int k) {$/;"	f	namespace:OpenBabel
int_type	zipstream.h	/^    typedef int int_type;$/;"	t	class:zlib_stream::basic_unzip_streambuf
int_type	zipstream.h	/^    typedef int int_type;$/;"	t	class:zlib_stream::basic_zip_streambuf
internalBondsPresent	mcdlutil.cpp	/^  bool TemplateRedraw::internalBondsPresent(TEditedMolecule * mQuery, TSimpleMolecule * mStructure) {$/;"	f	class:OpenBabel::TemplateRedraw
invert_atom	pointgroup.cpp	/^    invert_atom( SYMMETRY_ELEMENT *center, OBAtom *from, OBAtom *to )$/;"	f	class:OpenBabel::PointGroupPrivate
invert_matrix	matrix.cpp	/^bool invert_matrix(std::vector<std::vector<double> > &mat, double &det)$/;"	f	namespace:OpenBabel
invert_matrix_f	matrix.cpp	/^bool invert_matrix_f(double *mat, double &det, int rows, int cols)$/;"	f	namespace:OpenBabel
invert_matrix_ff	matrix.cpp	/^bool invert_matrix_ff(double **mat, double &det, int rows, int cols)$/;"	f	namespace:OpenBabel
isFerroceneBond	canon.cpp	/^  bool isFerroceneBond(OBBond *bond)$/;"	f	namespace:OpenBabel
isGZip	zipstream.h	/^inline bool isGZip(std::istream &is)$/;"	f	namespace:zlib_stream
isInTerminalSet	isomorphism.cpp	/^      bool isInTerminalSet(const std::vector<unsigned int> &depths,$/;"	f	class:OpenBabel::VF2Mapper
isOverlapped	mcdlutil.cpp	/^  bool TemplateRedraw::isOverlapped(const std::vector<PartFragmentDefinition *> list, int fragNo, double xSuggested, double ySuggested) {$/;"	f	class:OpenBabel::TemplateRedraw
isPotentialAromaticAtom	kekulize.cpp	/^  bool isPotentialAromaticAtom(OBAtom *atom)$/;"	f	namespace:OpenBabel
is_gzip	zipstreamimpl.h	/^basic_zip_istream<charT, traits>::is_gzip(void) const$/;"	f	class:basic_zip_istream
is_gzip	zipstreamimpl.h	/^bool basic_zip_ostream<charT, traits>::is_gzip(void) const$/;"	f	class:basic_zip_ostream
isdigit	snprintf.c	329;"	d	file:
isdigit	snprintf.c	331;"	d	file:
isotab	data.cpp	/^  OBIsotopeTable   isotab;$/;"	m	namespace:OpenBabel	file:
isqrt	rand.cpp	/^  static unsigned int isqrt( unsigned int val )$/;"	f	namespace:OpenBabel
istream_reference	zipstream.h	/^    typedef std::basic_istream<charT, traits>& istream_reference;$/;"	t	class:zlib_stream::basic_zip_istream
istream_reference	zipstream.h	/^    typedef std::basic_istream<charT,traits>& istream_reference;$/;"	t	class:zlib_stream::basic_unzip_streambuf
istream_type	zipstream.h	/^    typedef std::basic_istream<charT, traits> istream_type;$/;"	t	class:zlib_stream::basic_zip_istream
iz	mcdlutil.cpp	/^    short int iz;   \/*Isotope difference between round(AtomMass)*\/$/;"	m	class:OpenBabel::TSingleAtom	file:
key_distance	conformersearch.cpp	/^  OBConformerSearch::key_distance (const RotorKey &key1, const RotorKey &key2)$/;"	f	class:OpenBabel::OBConformerSearch
labels	canon.cpp	/^      const std::vector<unsigned int> &labels;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::SortStereoCenters	file:
labels	canon.cpp	/^      std::vector<unsigned int> labels;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::FullCode	file:
labels	canon.cpp	/^      std::vector<unsigned int> labels;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::PartialCode	file:
left	mcdlutil.cpp	/^    double left,top,right,bottom;$/;"	m	class:OpenBabel::Rect	file:
levels	confsearch.cpp	/^      std::vector<double> levels;$/;"	m	class:OpenBabel::OBDiversePoses	file:
lightMetals	mcdlutil.cpp	/^  const int lightMetals[NLIGHT_METALS] = {$/;"	m	namespace:OpenBabel	file:
likeFe	mcdlutil.cpp	/^  const int likeFe[NLIKEFEATOMS] ={27,28};$/;"	m	namespace:OpenBabel	file:
listarSize	mcdlutil.cpp	/^  int TSimpleMolecule::listarSize() { \/\/ Probably should be removed and replaced with either nAtoms() or nBonds() as appropriate$/;"	f	class:OpenBabel::TSimpleMolecule
loadTemplates	mcdlutil.cpp	/^  bool TemplateRedraw::loadTemplates() {$/;"	f	class:OpenBabel::TemplateRedraw
local	chains.cpp	/^    BinOpStruct local;    \/\/!< Local - test whether the atom has been visited$/;"	m	union:OpenBabel::_ByteCode	file:
local_opt	conformersearch.cpp	/^  OBConformerSearch::local_opt ()$/;"	f	class:OpenBabel::OBConformerSearch
m_canonical	tautomer.cpp	/^    bool m_canonical, m_foundLeafNode;$/;"	m	struct:OpenBabel::TautomerImpl	file:
m_foundLeafNode	tautomer.cpp	/^    bool m_canonical, m_foundLeafNode;$/;"	m	struct:OpenBabel::TautomerImpl	file:
m_maps	isomorphism.cpp	/^      OBIsomorphismMapper::Mappings &m_maps;$/;"	m	class:OpenBabel::MapAllFunctor	file:
m_maxMemory	isomorphism.cpp	/^      std::size_t m_memory, m_maxMemory;$/;"	m	class:OpenBabel::MapAllFunctor	file:
m_memory	isomorphism.cpp	/^      std::size_t m_memory, m_maxMemory;$/;"	m	class:OpenBabel::MapAllFunctor	file:
m_startTime	isomorphism.cpp	/^    time_t m_startTime;$/;"	m	class:OpenBabel::VF2Mapper	file:
makeAssignment	mcdlutil.cpp	/^  static void makeAssignment(const std::vector<int> iA1, const std::vector<int> iA2, const std::vector<int> nH,$/;"	f	namespace:OpenBabel
makeEquivalentList	mcdlutil.cpp	/^  void TSimpleMolecule::makeEquivalentList(std::vector<int>& equivalenceList, bool isTopologyOnly) {$/;"	f	class:OpenBabel::TSimpleMolecule
makeFragment	mcdlutil.cpp	/^  bool TSimpleMolecule::makeFragment(std::vector<int>& list, int aT, int aTEx) {$/;"	f	class:OpenBabel::TSimpleMolecule
make_gzip	zipstream.h	/^    void                              make_gzip()$/;"	f	class:zlib_stream::basic_zip_ostream
manganeze	mcdlutil.cpp	/^  const int manganeze[NMANGANESEATOMS] ={25,43,75};$/;"	m	namespace:OpenBabel	file:
mapping	isomorphism.cpp	/^        std::vector<OBAtom*> mapping;$/;"	m	struct:OpenBabel::VF2Mapper::State	file:
match	parsmart.cpp	/^  bool OBSmartsMatcher::match(OBMol &mol, const Pattern *pat,$/;"	f	class:OpenBabel::OBSmartsMatcher
matchCandidate	isomorphism.cpp	/^      bool matchCandidate(State &state, OBQueryAtom *queryAtom, OBAtom *queriedAtom)$/;"	f	class:OpenBabel::VF2Mapper
matchFiles	dlhandler_unix.cpp	/^int matchFiles (SCANDIR_CONST struct dirent *entry_p)$/;"	f
maxBoxSize	distgeom.cpp	/^    double maxBoxSize;$/;"	m	class:OpenBabel::DistanceGeometryPrivate	file:
maxTime	canon.cpp	/^      time_t startTime, maxTime;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::Timeout	file:
maxTime	kekulize.cpp	/^      time_t startTime, maxTime;$/;"	m	struct:OpenBabel::Kekulize::Timeout	file:
maxVal	mcdlutil.cpp	/^	const int maxVal[NELEMMCDL] = {$/;"	m	namespace:OpenBabel	file:
maxValency	mcdlutil.cpp	/^  int maxValency(int na) {        \/\/Maximal valency of a specified element$/;"	f	namespace:OpenBabel
maxdev	pointgroup.cpp	/^      double  maxdev ;        \/*   Largest error associated with the element            *\/$/;"	m	struct:OpenBabel::PointGroupPrivate::_SYMMETRY_ELEMENT_	file:
mcr	canon.cpp	/^      OBBitVec &mcr;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::State	file:
message	oberror.cpp	/^  string OBError::message() const$/;"	f	class:OpenBabel::OBError
metals	mcdlutil.cpp	/^  const int metals[NMETALS] = {$/;"	m	namespace:OpenBabel	file:
mirror_atom	pointgroup.cpp	/^    static void mirror_atom( SYMMETRY_ELEMENT *plane, OBAtom *from, OBAtom *to )$/;"	f	class:OpenBabel::PointGroupPrivate
moleculeCopy	mcdlutil.cpp	/^  void TSimpleMolecule::moleculeCopy(TSimpleMolecule & source) {$/;"	f	class:OpenBabel::TSimpleMolecule
mult_matrix	matrix.cpp	/^bool mult_matrix(std::vector<std::vector<double> > &c,$/;"	f	namespace:OpenBabel
mult_matrix_f	matrix.cpp	/^bool mult_matrix_f(double *c, double *a, double *b, int rows, int cols)$/;"	f	namespace:OpenBabel
mult_matrix_ff	matrix.cpp	/^bool mult_matrix_ff(double **c, double **a, double **b, int rows, int cols)$/;"	f	namespace:OpenBabel
n1	chains.cpp	/^    int n1;          \/\/!< mask 1 used by ConstrainBackbone() and MatchConstraint()$/;"	m	struct:OpenBabel::Template	file:
n2	chains.cpp	/^    int n2;          \/\/!< mask 2 used by ConstrainBackbone() and MatchConstraint()$/;"	m	struct:OpenBabel::Template	file:
n3	chains.cpp	/^    int n3;          \/\/!< mask 3 used by ConstrainBackbone() and MatchConstraint()$/;"	m	struct:OpenBabel::Template	file:
n4	chains.cpp	/^    int n4;          \/\/!< mask 4 used by ConstrainBackbone() and MatchConstraint()$/;"	m	struct:OpenBabel::Template	file:
nAtoms	mcdlutil.cpp	/^  int TSimpleMolecule::nAtoms() {$/;"	f	class:OpenBabel::TSimpleMolecule
nBonds	mcdlutil.cpp	/^  int TSimpleMolecule::nBonds() {$/;"	f	class:OpenBabel::TSimpleMolecule
nRotBondsMax	mcdlutil.cpp	54;"	d	file:
n_rmsd	confsearch.cpp	/^      int n_rmsd;$/;"	m	class:OpenBabel::OBDiversePoses	file:
na	mcdlutil.cpp	/^    short int na;   \/*Atom position in the Periodic Table (nucley charge)*\/$/;"	m	class:OpenBabel::TSingleAtom	file:
name	chains.cpp	/^    const char *name; \/\/!< Residue name, standardized by PDB$/;"	m	struct:OpenBabel::__anon1	file:
natoms	confsearch.cpp	/^      int natoms;$/;"	m	class:OpenBabel::OBDiversePoses	file:
nb	mcdlutil.cpp	/^    int nb;$/;"	m	struct:OpenBabel::adjustedlist	file:
nb	mcdlutil.cpp	/^    short int nb;   \/*Number of neightboring atoms*\/$/;"	m	class:OpenBabel::TSingleAtom	file:
nbrIndexes1	canon.cpp	/^      std::vector<unsigned int> nbrIndexes1, nbrIndexes2;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::StereoCenter	file:
nbrIndexes2	canon.cpp	/^      std::vector<unsigned int> nbrIndexes1, nbrIndexes2;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::StereoCenter	file:
nc	mcdlutil.cpp	/^    short int nc;   \/*-9..+9 atom's charge*\/$/;"	m	class:OpenBabel::TSingleAtom	file:
neighbourlist	mcdlutil.cpp	/^  typedef adjustedlist neighbourlist;$/;"	t	namespace:OpenBabel	file:
newB	mcdlutil.cpp	/^  void TSimpleMolecule::newB(neighbourlist * bk, int bnum, int anum, int & total, int * e, int * e1) {$/;"	f	class:OpenBabel::TSimpleMolecule
new_c_num_locale	locale.cpp	/^    locale_t new_c_num_locale;$/;"	m	class:OpenBabel::OBLocalePrivate	file:
next	chains.cpp	/^    union _ByteCode *next;$/;"	m	struct:OpenBabel::__anon4	typeref:union:OpenBabel::__anon4::_ByteCode	file:
nibble_bit_count	bitvec.cpp	/^  const unsigned nibble_bit_count[0x10] =$/;"	m	namespace:OpenBabel	file:
normal	isomorphism.cpp	/^  static const char *normal = "\\033[0m";$/;"	m	namespace:OpenBabel	file:
normal	pointgroup.cpp	/^      double  normal[ DIMENSION ] ;$/;"	m	struct:OpenBabel::PointGroupPrivate::_SYMMETRY_ELEMENT_	file:
normalizeCoordinates	mcdlutil.cpp	/^  void TSimpleMolecule::normalizeCoordinates(double aveBL) {$/;"	f	class:OpenBabel::TSimpleMolecule
nparam	pointgroup.cpp	/^      int     nparam ;        \/*   4 for inversion and planes, 7 for axes              *\/$/;"	m	struct:OpenBabel::PointGroupPrivate::_SYMMETRY_ELEMENT_	file:
nv	mcdlutil.cpp	/^    short int nv;   \/*Current atom's valence*\/$/;"	m	class:OpenBabel::TSingleAtom	file:
obErrorLog	oberror.cpp	/^  OBMessageHandler obErrorLog;$/;"	m	namespace:OpenBabel	file:
obLocale	locale.cpp	/^  OBLocale   obLocale;$/;"	m	namespace:OpenBabel	file:
ob_make_rmat	obutil.cpp	/^  void ob_make_rmat(double a[3][3],double rmat[9])$/;"	f	namespace:OpenBabel
old_locale	locale.cpp	/^    locale_t old_locale;$/;"	m	class:OpenBabel::OBLocalePrivate	file:
old_locale_string	locale.cpp	/^    char *old_locale_string;$/;"	m	class:OpenBabel::OBLocalePrivate	file:
onlyOne	canon.cpp	/^      const bool onlyOne;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::State	file:
openLib	dlhandler_unix.cpp	/^bool DLHandler :: openLib(const string& lib_name)$/;"	f	class:DLHandler
openLib	dlhandler_unix.cpp	/^bool DLHandler::openLib(const string& lib_name)$/;"	f	class:DLHandler
openLib	dlhandler_win32.cpp	/^bool DLHandler :: openLib(const string& lib_name)$/;"	f	class:DLHandler
operator &	bitvec.cpp	/^  OBBitVec operator& (const OBBitVec & bv1, const OBBitVec & bv2)$/;"	f	namespace:OpenBabel
operator &=	bitvec.cpp	/^  OBBitVec & OBBitVec::operator&= (const OBBitVec & bv)$/;"	f	class:OpenBabel::OBBitVec
operator ()	canon.cpp	/^      inline bool operator()(const OBAtom *a1, const OBAtom *a2) const$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::SortAtomsAscending
operator ()	canon.cpp	/^      inline bool operator()(const OBAtom *a1, const OBAtom *a2) const$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::SortAtomsDescending
operator ()	canon.cpp	/^      inline bool operator()(const StereoCenter &c1, const StereoCenter &c2) const$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::SortStereoCenters
operator ()	conformersearch.cpp	/^    bool operator()(const ConformerScore &cs1, const ConformerScore &cs2) { return cs1.score < cs2.score; }$/;"	f	struct:OpenBabel::CompareConformerLowScore
operator ()	conformersearch.cpp	/^    bool operator()(const ConformerScore &cs1, const ConformerScore &cs2) { return cs1.score > cs2.score; }$/;"	f	struct:OpenBabel::CompareConformerHighScore
operator ()	isomorphism.cpp	/^      bool operator()(OBIsomorphismMapper::Mapping &map)$/;"	f	class:OpenBabel::MapAllFunctor
operator ++	obiter.cpp	/^  OBAtomAtomIter OBAtomAtomIter::operator++(int)$/;"	f	class:OpenBabel::OBAtomAtomIter
operator ++	obiter.cpp	/^  OBAtomAtomIter& OBAtomAtomIter::operator++()$/;"	f	class:OpenBabel::OBAtomAtomIter
operator ++	obiter.cpp	/^  OBAtomBondIter OBAtomBondIter::operator++(int)$/;"	f	class:OpenBabel::OBAtomBondIter
operator ++	obiter.cpp	/^  OBAtomBondIter& OBAtomBondIter::operator++()$/;"	f	class:OpenBabel::OBAtomBondIter
operator ++	obiter.cpp	/^  OBMolAngleIter& OBMolAngleIter::operator++()$/;"	f	class:OpenBabel::OBMolAngleIter
operator ++	obiter.cpp	/^  OBMolAtomBFSIter OBMolAtomBFSIter::operator++(int)$/;"	f	class:OpenBabel::OBMolAtomBFSIter
operator ++	obiter.cpp	/^  OBMolAtomBFSIter& OBMolAtomBFSIter::operator++()$/;"	f	class:OpenBabel::OBMolAtomBFSIter
operator ++	obiter.cpp	/^  OBMolAtomDFSIter OBMolAtomDFSIter::operator++(int)$/;"	f	class:OpenBabel::OBMolAtomDFSIter
operator ++	obiter.cpp	/^  OBMolAtomDFSIter& OBMolAtomDFSIter::operator++()$/;"	f	class:OpenBabel::OBMolAtomDFSIter
operator ++	obiter.cpp	/^  OBMolAtomIter OBMolAtomIter::operator++(int)$/;"	f	class:OpenBabel::OBMolAtomIter
operator ++	obiter.cpp	/^  OBMolAtomIter& OBMolAtomIter::operator++()$/;"	f	class:OpenBabel::OBMolAtomIter
operator ++	obiter.cpp	/^  OBMolBondBFSIter OBMolBondBFSIter::operator++(int)$/;"	f	class:OpenBabel::OBMolBondBFSIter
operator ++	obiter.cpp	/^  OBMolBondBFSIter& OBMolBondBFSIter::operator++()$/;"	f	class:OpenBabel::OBMolBondBFSIter
operator ++	obiter.cpp	/^  OBMolBondIter OBMolBondIter::operator++(int)$/;"	f	class:OpenBabel::OBMolBondIter
operator ++	obiter.cpp	/^  OBMolBondIter& OBMolBondIter::operator++()$/;"	f	class:OpenBabel::OBMolBondIter
operator ++	obiter.cpp	/^  OBMolPairIter& OBMolPairIter::operator++()$/;"	f	class:OpenBabel::OBMolPairIter
operator ++	obiter.cpp	/^  OBMolRingIter OBMolRingIter::operator++(int)$/;"	f	class:OpenBabel::OBMolRingIter
operator ++	obiter.cpp	/^  OBMolRingIter& OBMolRingIter::operator++()$/;"	f	class:OpenBabel::OBMolRingIter
operator ++	obiter.cpp	/^  OBMolTorsionIter& OBMolTorsionIter::operator++()$/;"	f	class:OpenBabel::OBMolTorsionIter
operator ++	obiter.cpp	/^  OBResidueAtomIter OBResidueAtomIter::operator++ (int)$/;"	f	class:OpenBabel::OBResidueAtomIter
operator ++	obiter.cpp	/^  OBResidueAtomIter& OBResidueAtomIter::operator++ ()$/;"	f	class:OpenBabel::OBResidueAtomIter
operator ++	obiter.cpp	/^  OBResidueIter OBResidueIter::operator++(int)$/;"	f	class:OpenBabel::OBResidueIter
operator ++	obiter.cpp	/^  OBResidueIter& OBResidueIter::operator++()$/;"	f	class:OpenBabel::OBResidueIter
operator +=	bitvec.cpp	/^  OBBitVec & OBBitVec::operator+= (const OBBitVec & bv)$/;"	f	class:OpenBabel::OBBitVec
operator +=	mol.cpp	/^  OBMol &OBMol::operator+=(const OBMol &source)$/;"	f	class:OpenBabel::OBMol
operator -	bitvec.cpp	/^  OBBitVec operator- (const OBBitVec & bv1, const OBBitVec & bv2)$/;"	f	namespace:OpenBabel
operator -=	bitvec.cpp	/^  OBBitVec & OBBitVec::operator-= (const OBBitVec & bv)$/;"	f	class:OpenBabel::OBBitVec
operator <	bitvec.cpp	/^  bool operator< (const OBBitVec & bv1, const OBBitVec & bv2)$/;"	f	namespace:OpenBabel
operator <	canon.cpp	/^      inline bool operator<(const FullCode &other) const$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::PartialCode
operator <<	bitvec.cpp	/^  std::ostream & operator<< ( std::ostream & os, const OBBitVec & bv)$/;"	f	namespace:OpenBabel
operator <<	grid.cpp	/^  ostream& operator<< ( ostream &os, const  OBFloatGrid& fg)$/;"	f	namespace:OpenBabel
operator =	atom.cpp	/^  OBAtom &OBAtom::operator=(OBAtom &src)$/;"	f	class:OpenBabel::OBAtom
operator =	bitvec.cpp	/^  OBBitVec & OBBitVec::operator= (const OBBitVec & bv)$/;"	f	class:OpenBabel::OBBitVec
operator =	generic.cpp	/^  OBAngle& OBAngle::operator = (const OBAngle &src)$/;"	f	class:OpenBabel::OBAngle
operator =	generic.cpp	/^  OBAngleData& OBAngleData::operator =(const OBAngleData &src)$/;"	f	class:OpenBabel::OBAngleData
operator =	generic.cpp	/^  OBChiralData & OBChiralData::operator=(const OBChiralData &src)$/;"	f	class:OpenBabel::OBChiralData
operator =	generic.cpp	/^  OBConformerData & OBConformerData::operator=(const OBConformerData &src)$/;"	f	class:OpenBabel::OBConformerData
operator =	generic.cpp	/^  OBRingData& OBRingData::operator =(const OBRingData &src)$/;"	f	class:OpenBabel::OBRingData
operator =	generic.cpp	/^  OBSymmetryData & OBSymmetryData::operator=(const OBSymmetryData &src)$/;"	f	class:OpenBabel::OBSymmetryData
operator =	generic.cpp	/^  OBTorsion& OBTorsion::operator =(const OBTorsion &src)$/;"	f	class:OpenBabel::OBTorsion
operator =	generic.cpp	/^  OBTorsionData& OBTorsionData::operator =(const OBTorsionData &src)$/;"	f	class:OpenBabel::OBTorsionData
operator =	generic.cpp	/^  OBUnitCell & OBUnitCell::operator=(const OBUnitCell &src)$/;"	f	class:OpenBabel::OBUnitCell
operator =	mol.cpp	/^  OBMol &OBMol::operator=(const OBMol &source)$/;"	f	class:OpenBabel::OBMol
operator =	obconversion.cpp	/^  OBConversion& OBConversion::operator=(const OBConversion& o)$/;"	f	class:OpenBabel::OBConversion
operator =	obiter.cpp	/^  OBAtomAtomIter& OBAtomAtomIter::operator=(const OBAtomAtomIter &ai)$/;"	f	class:OpenBabel::OBAtomAtomIter
operator =	obiter.cpp	/^  OBAtomBondIter& OBAtomBondIter::operator=(const OBAtomBondIter &bi)$/;"	f	class:OpenBabel::OBAtomBondIter
operator =	obiter.cpp	/^  OBMolAngleIter& OBMolAngleIter::operator=(const OBMolAngleIter &ai)$/;"	f	class:OpenBabel::OBMolAngleIter
operator =	obiter.cpp	/^  OBMolAtomBFSIter& OBMolAtomBFSIter::operator=(const OBMolAtomBFSIter &ai)$/;"	f	class:OpenBabel::OBMolAtomBFSIter
operator =	obiter.cpp	/^  OBMolAtomDFSIter& OBMolAtomDFSIter::operator=(const OBMolAtomDFSIter &ai)$/;"	f	class:OpenBabel::OBMolAtomDFSIter
operator =	obiter.cpp	/^  OBMolAtomIter& OBMolAtomIter::operator=(const OBMolAtomIter &ai)$/;"	f	class:OpenBabel::OBMolAtomIter
operator =	obiter.cpp	/^  OBMolBondBFSIter& OBMolBondBFSIter::operator=(const OBMolBondBFSIter &ai)$/;"	f	class:OpenBabel::OBMolBondBFSIter
operator =	obiter.cpp	/^  OBMolBondIter& OBMolBondIter::operator=(const OBMolBondIter &bi)$/;"	f	class:OpenBabel::OBMolBondIter
operator =	obiter.cpp	/^  OBMolPairIter& OBMolPairIter::operator=(const OBMolPairIter &ai)$/;"	f	class:OpenBabel::OBMolPairIter
operator =	obiter.cpp	/^  OBMolRingIter& OBMolRingIter::operator=(const OBMolRingIter &ri)$/;"	f	class:OpenBabel::OBMolRingIter
operator =	obiter.cpp	/^  OBMolTorsionIter& OBMolTorsionIter::operator=(const OBMolTorsionIter &ai)$/;"	f	class:OpenBabel::OBMolTorsionIter
operator =	obiter.cpp	/^  OBResidueAtomIter & OBResidueAtomIter::operator = (const OBResidueAtomIter &ri)$/;"	f	class:OpenBabel::OBResidueAtomIter
operator =	obiter.cpp	/^  OBResidueIter& OBResidueIter::operator=(const OBResidueIter &ri)$/;"	f	class:OpenBabel::OBResidueIter
operator =	residue.cpp	/^  OBResidue &OBResidue::operator = (const OBResidue &src)$/;"	f	class:OpenBabel::OBResidue
operator =	ring.cpp	/^  OBRing& OBRing::operator =(const OBRing &src)$/;"	f	class:OpenBabel::OBRing
operator =	spectrophore.cpp	/^OBSpectrophore::operator=(const OBSpectrophore& s)$/;"	f	class:OpenBabel::OBSpectrophore
operator ==	bitvec.cpp	/^  bool operator== (const OBBitVec & bv1, const OBBitVec & bv2)$/;"	f	namespace:OpenBabel
operator ==	generic.cpp	/^  bool OBAngle::operator ==(const OBAngle &other)$/;"	f	class:OpenBabel::OBAngle
operator ==	isomorphism.cpp	/^        bool operator==(const Candidate &other)$/;"	f	struct:OpenBabel::VF2Mapper::Candidate
operator ==	oberror.cpp	/^  bool OBError::operator== (const OBError& other)const {return GetError()==other.GetError();}$/;"	f	class:OpenBabel::OBError
operator >	canon.cpp	/^      inline bool operator>(const FullCode &other) const$/;"	f	struct:OpenBabel::CanonicalLabelsImpl::FullCode
operator >>	bitvec.cpp	/^  std::istream & operator>> ( std::istream & is, OBBitVec & bv )$/;"	f	namespace:OpenBabel
operator >>	grid.cpp	/^  istream& operator>> ( istream &is,OBFloatGrid& fg)$/;"	f	namespace:OpenBabel
operator ^	bitvec.cpp	/^  OBBitVec operator^ (const OBBitVec & bv1, const OBBitVec & bv2)$/;"	f	namespace:OpenBabel
operator ^=	bitvec.cpp	/^  OBBitVec & OBBitVec::operator^= (const OBBitVec & bv)$/;"	f	class:OpenBabel::OBBitVec
operator |	bitvec.cpp	/^  OBBitVec operator| (const OBBitVec & bv1, const OBBitVec & bv2)$/;"	f	namespace:OpenBabel
operator |=	bitvec.cpp	/^  OBBitVec & OBBitVec::operator|= (const OBBitVec & bv)$/;"	f	class:OpenBabel::OBBitVec
optimize_transformation_params	pointgroup.cpp	/^    optimize_transformation_params( SYMMETRY_ELEMENT *elem )$/;"	f	class:OpenBabel::PointGroupPrivate
orbits	canon.cpp	/^      Orbits orbits;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::State	file:
order	pointgroup.cpp	/^      int     order ;         \/*   Applying transformation this many times is identity *\/$/;"	m	struct:OpenBabel::PointGroupPrivate::_SYMMETRY_ELEMENT_	file:
ostream_reference	zipstream.h	/^    typedef std::basic_ostream<charT, traits>& ostream_reference;$/;"	t	class:zlib_stream::basic_zip_ostream
ostream_reference	zipstream.h	/^    typedef std::basic_ostream<charT, traits>& ostream_reference;$/;"	t	class:zlib_stream::basic_zip_streambuf
ostream_type	zipstream.h	/^    typedef std::basic_ostream<charT, traits> ostream_type;$/;"	t	class:zlib_stream::basic_zip_ostream
overflow	zipstreamimpl.h	/^basic_zip_streambuf<charT, traits>::overflow(int_type c)$/;"	f	class:basic_zip_streambuf
overlapped	mcdlutil.cpp	/^  bool overlapped(double x1A, double y1A, double x2A, double y2A,$/;"	f	namespace:OpenBabel
palign	confsearch.cpp	/^      OBAlign* palign;$/;"	m	class:OpenBabel::OBDiversePoses	file:
parseFormula	mcdlutil.cpp	/^  bool parseFormula(const std::string formulaString, std::vector <int>& enumber, int & valency) {$/;"	f	namespace:OpenBabel
phmodel	phmodel.cpp	/^  OBPhModel phmodel;$/;"	m	namespace:OpenBabel	file:
platinum	mcdlutil.cpp	/^  const int platinum[NPLATINUMATOMS] ={44,45,46,76,77,78};$/;"	m	namespace:OpenBabel	file:
popInput	obconversion.cpp	/^  void OBConversion::StreamState::popInput(OBConversion& conv)$/;"	f	class:OpenBabel::OBConversion::StreamState
popOutput	obconversion.cpp	/^  void OBConversion::StreamState::popOutput(OBConversion& conv)$/;"	f	class:OpenBabel::OBConversion::StreamState
portable_snprintf	snprintf.c	/^int portable_snprintf(char *str, size_t str_m, const char *fmt, \/*args*\/ ...)$/;"	f
portable_snprintf	snprintf.c	398;"	d	file:
portable_vsnprintf	snprintf.c	400;"	d	file:
poses	confsearch.cpp	/^      Tree poses;$/;"	m	class:OpenBabel::OBDiversePoses	file:
possibleAromatic	mcdlutil.cpp	/^  const int possibleAromatic [NAROMMAX] = {7,8,15,16,33,34,51,52,HETERO_ATOM};$/;"	m	namespace:OpenBabel	file:
potentialAromaticBonds	kekulize.cpp	/^  void potentialAromaticBonds(OBMol *mol, OBBitVec &bonds)$/;"	f	namespace:OpenBabel
preMet	distgeom.cpp	/^    Eigen::MatrixXf bounds, preMet;$/;"	m	class:OpenBabel::DistanceGeometryPrivate	file:
prepareQuery	mcdlutil.cpp	/^  int TEditedMolecule::prepareQuery(TSimpleMolecule & sMol) {$/;"	f	class:OpenBabel::TEditedMolecule
prepareTest	mcdlutil.cpp	/^  void prepareTest(OBMol * pmol, std::ostream & ofs) {$/;"	f	namespace:OpenBabel
prev	chains.cpp	/^    int prev;$/;"	m	struct:OpenBabel::__anon7	file:
primes	rand.cpp	/^  static int primes[MAXPRIMES] = {$/;"	m	namespace:OpenBabel	file:
print_assigned	tautomer.cpp	/^    void print_assigned(const std::vector<Level> &levels, const std::vector<Type> &atomTypes)$/;"	f	struct:OpenBabel::TautomerImpl
print_atom_types	tautomer.cpp	/^    void print_atom_types(const std::vector<Type> &types)$/;"	f	struct:OpenBabel::TautomerImpl
print_bond_types	tautomer.cpp	/^    void print_bond_types(const std::vector<Type> &types)$/;"	f	struct:OpenBabel::TautomerImpl
print_matrix	matrix.cpp	/^void print_matrix(std::vector<std::vector<double> > &m)$/;"	f	namespace:OpenBabel
print_matrix_f	matrix.cpp	/^void print_matrix_f(double *m, int rows, int cols)$/;"	f	namespace:OpenBabel
print_matrix_ff	matrix.cpp	/^void print_matrix_ff(double **m, int rows, int cols)$/;"	f	namespace:OpenBabel
print_orbits	canon.cpp	/^    static void print_orbits(const Orbits &orbits)$/;"	f	struct:OpenBabel::CanonicalLabelsImpl
print_orbits	canon.cpp	/^    static void print_orbits(const std::string &label, const Orbits &orbits)$/;"	f	struct:OpenBabel::CanonicalLabelsImpl
print_sym_classes	graphsym.cpp	/^void print_sym_classes(const std::string &label, const std::vector<std::pair<OpenBabel::OBAtom*, unsigned int> > &atom_sym_classes)$/;"	f
print_vector	canon.cpp	/^void print_vector(const std::string &label, const std::vector<T> &v)$/;"	f
print_vector	graphsym.cpp	/^void print_vector(const std::string &label, const std::vector<T> &v)$/;"	f
print_vector	isomorphism.cpp	/^    void print_vector(const std::string &label, const std::vector<T> &v)$/;"	f	namespace:OpenBabel
propagatedAtoms	tautomer.cpp	/^      std::vector<OBAtom*> propagatedAtoms;$/;"	m	struct:OpenBabel::TautomerImpl::Level	file:
propagatedBonds	tautomer.cpp	/^      std::vector<OBBond*> propagatedBonds;$/;"	m	struct:OpenBabel::TautomerImpl::Level	file:
ps1	kekulize.cpp	/^      int ps1;$/;"	m	struct:OpenBabel::Kekulize::stateDiff_t	file:
ps2	kekulize.cpp	/^      int ps2;$/;"	m	struct:OpenBabel::Kekulize::stateDiff_t	file:
psb	kekulize.cpp	/^      int psb;$/;"	m	struct:OpenBabel::Kekulize::stateDiff_t	file:
ptInRect	mcdlutil.cpp	/^  bool ptInRect(const Rect r, const Point p) {$/;"	f	namespace:OpenBabel
pushInput	obconversion.cpp	/^  void OBConversion::StreamState::pushInput(OBConversion& conv)$/;"	f	class:OpenBabel::OBConversion::StreamState
pushOutput	obconversion.cpp	/^  void OBConversion::StreamState::pushOutput(OBConversion& conv)$/;"	f	class:OpenBabel::OBConversion::StreamState
put_back_from_zip_stream	zipstreamimpl.h	/^basic_unzip_streambuf<charT, traits>::put_back_from_zip_stream(void)$/;"	f	class:basic_unzip_streambuf
qtrfit	obutil.cpp	/^  void qtrfit (double *r,double *f,int size, double u[3][3])$/;"	f	namespace:OpenBabel
queried	isomorphism.cpp	/^        const OBMol *queried; \/\/ the queried molecule$/;"	m	struct:OpenBabel::VF2Mapper::State	file:
queriedAtom	isomorphism.cpp	/^        OBAtom *queriedAtom;$/;"	m	struct:OpenBabel::VF2Mapper::Candidate	file:
queriedDepths	isomorphism.cpp	/^        std::vector<unsigned int> queryDepths, queriedDepths; \/\/ the terminal sets$/;"	m	struct:OpenBabel::VF2Mapper::State	file:
queriedMask	isomorphism.cpp	/^        OBBitVec queriedMask; \/\/ the queriedMask$/;"	m	struct:OpenBabel::VF2Mapper::State	file:
queriedPath	isomorphism.cpp	/^        std::vector<unsigned int> queriedPath; \/\/ the path in the queried molecule$/;"	m	struct:OpenBabel::VF2Mapper::State	file:
queriedPathBits	isomorphism.cpp	/^        OBBitVec queryPathBits, queriedPathBits; \/\/ the terminal sets$/;"	m	struct:OpenBabel::VF2Mapper::State	file:
query	isomorphism.cpp	/^        const OBQuery *query; \/\/ the query$/;"	m	struct:OpenBabel::VF2Mapper::State	file:
queryAGer	mcdlutil.cpp	/^    std::vector<int> queryAGer;$/;"	m	class:OpenBabel::TEditedMolecule	file:
queryAQTested	mcdlutil.cpp	/^    std::vector<int> queryAQTested;$/;"	m	class:OpenBabel::TEditedMolecule	file:
queryAtom	isomorphism.cpp	/^        OBQueryAtom *queryAtom;$/;"	m	struct:OpenBabel::VF2Mapper::Candidate	file:
queryBQCounter	mcdlutil.cpp	/^    std::vector<int> queryBQCounter;$/;"	m	class:OpenBabel::TEditedMolecule	file:
queryBQTested	mcdlutil.cpp	/^    std::vector<int> queryBQTested;$/;"	m	class:OpenBabel::TEditedMolecule	file:
queryCurrentAssignment	mcdlutil.cpp	/^    std::vector<int> queryCurrentAssignment;$/;"	m	class:OpenBabel::TEditedMolecule	file:
queryData	mcdlutil.cpp	/^    static std::vector<TEditedMolecule *> queryData;$/;"	m	class:OpenBabel::TemplateRedraw	file:
queryData	mcdlutil.cpp	/^  std::vector<TEditedMolecule *> TemplateRedraw::queryData;$/;"	m	class:OpenBabel::TemplateRedraw	file:
queryDepths	isomorphism.cpp	/^        std::vector<unsigned int> queryDepths, queriedDepths; \/\/ the terminal sets$/;"	m	struct:OpenBabel::VF2Mapper::State	file:
queryEnum	mcdlutil.cpp	/^    std::vector<int> queryEnum;$/;"	m	class:OpenBabel::TEditedMolecule	file:
queryInverse	mcdlutil.cpp	/^    std::vector<int> queryInverse;$/;"	m	class:OpenBabel::TEditedMolecule	file:
queryPath	isomorphism.cpp	/^        std::vector<unsigned int> queryPath; \/\/ the path in the query$/;"	m	struct:OpenBabel::VF2Mapper::State	file:
queryPathBits	isomorphism.cpp	/^        OBBitVec queryPathBits, queriedPathBits; \/\/ the terminal sets$/;"	m	struct:OpenBabel::VF2Mapper::State	file:
queryQHydr	mcdlutil.cpp	/^    std::vector<int> queryQHydr;$/;"	m	class:OpenBabel::TEditedMolecule	file:
queryStereoQ	mcdlutil.cpp	/^    bool queryStereoQ,fIsQueryPrepare;$/;"	m	class:OpenBabel::TEditedMolecule	file:
ranks	canon.cpp	/^      const std::vector<unsigned int> &ranks;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::SortAtomsAscending	file:
ranks	canon.cpp	/^      const std::vector<unsigned int> &ranks;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::SortAtomsDescending	file:
readConnectionMatrix	mcdlutil.cpp	/^  void TSimpleMolecule::readConnectionMatrix(const std::vector<int>iA1, const std::vector<int>iA2, const std::vector<double>rx, const std::vector<double>ry, int nAtoms, int nBonds) {$/;"	f	class:OpenBabel::TSimpleMolecule
readConnectionMatrix	mcdlutil.cpp	/^  void TSimpleMolecule::readConnectionMatrix(const std::vector<int>iA1, const std::vector<int>iA2, int nAtoms, int nBonds) {$/;"	f	class:OpenBabel::TSimpleMolecule
readOBMol	mcdlutil.cpp	/^  void TSimpleMolecule::readOBMol(OBMol * pmol) {$/;"	f	class:OpenBabel::TSimpleMolecule
read_footer	zipstreamimpl.h	/^basic_zip_istream<charT, traits>::read_footer(void)$/;"	f	class:basic_zip_istream
read_rules	patty.cpp	/^  void patty::read_rules(const string &infile)$/;"	f	class:OpenBabel::patty
red	isomorphism.cpp	/^  static const char *red    = "\\033[1;31m";$/;"	m	namespace:OpenBabel	file:
redraw	mcdlutil.cpp	/^  void TSimpleMolecule::redraw(const std::vector<int>listAtomClean, const std::vector<int>listBondClean,$/;"	f	class:OpenBabel::TSimpleMolecule
redrawFine	mcdlutil.cpp	/^  void TemplateRedraw::redrawFine(TSimpleMolecule& smIn) {$/;"	f	class:OpenBabel::TemplateRedraw
redrawMolecule	mcdlutil.cpp	/^  void TSimpleMolecule::redrawMolecule() {$/;"	f	class:OpenBabel::TSimpleMolecule
refine_symmetry_element	pointgroup.cpp	/^    refine_symmetry_element( SYMMETRY_ELEMENT *elem, int build_table )$/;"	f	class:OpenBabel::PointGroupPrivate
refofs	mcdlutil.cpp	/^    std::ostream * refofs;$/;"	m	class:OpenBabel::TSimpleMolecule	file:
removeHydrogen	mcdlutil.cpp	/^  void TEditedMolecule::removeHydrogen(std::vector<int> * qHydr, std::vector<int> * qEnumerator) {$/;"	f	class:OpenBabel::TEditedMolecule
removeZeroeth	mcdlutil.cpp	/^  std::string removeZeroeth(std::string instring) {$/;"	f	namespace:OpenBabel
report_and_reset_counters	pointgroup.cpp	/^    report_and_reset_counters( void )$/;"	f	class:OpenBabel::PointGroupPrivate
report_axes	pointgroup.cpp	/^    report_axes( void )$/;"	f	class:OpenBabel::PointGroupPrivate
report_improper_axes	pointgroup.cpp	/^    report_improper_axes( void )$/;"	f	class:OpenBabel::PointGroupPrivate
report_inversion_centers	pointgroup.cpp	/^    report_inversion_centers( void )$/;"	f	class:OpenBabel::PointGroupPrivate
report_planes	pointgroup.cpp	/^    report_planes( void )$/;"	f	class:OpenBabel::PointGroupPrivate
report_symmetry_elements_brief	pointgroup.cpp	/^    report_symmetry_elements_brief( void )$/;"	f	class:OpenBabel::PointGroupPrivate
report_symmetry_elements_verbose	pointgroup.cpp	/^    report_symmetry_elements_verbose( void )$/;"	f	class:OpenBabel::PointGroupPrivate
reproduce	conformersearch.cpp	/^  OBConformerSearch::reproduce (RotorKey &key1, RotorKey &key2)$/;"	f	class:OpenBabel::OBConformerSearch
rescaleSingleFragment	mcdlutil.cpp	/^  void TemplateRedraw::rescaleSingleFragment(TSimpleMolecule * sm, std::vector<int>* atomList, PartFragmentDefinition& pf, double offset) {$/;"	f	class:OpenBabel::TemplateRedraw
resdat	data.cpp	/^  OBResidueData    resdat;$/;"	m	namespace:OpenBabel	file:
resid	chains.cpp	/^    int resid;$/;"	m	struct:OpenBabel::__anon6	file:
right	mcdlutil.cpp	/^    double left,top,right,bottom;$/;"	m	class:OpenBabel::Rect	file:
ringtyper	ring.cpp	/^  OBRingTyper      ringtyper;$/;"	m	namespace:OpenBabel	file:
rint	rotamer.cpp	/^  inline double rint(double x)$/;"	f	namespace:OpenBabel
rl	mcdlutil.cpp	/^    short int rl;   \/*radical label*\/$/;"	m	class:OpenBabel::TSingleAtom	file:
rotateBondVertically	mcdlutil.cpp	/^  void TemplateRedraw::rotateBondVertically(TSimpleMolecule * sm, const std::vector<int>bondList, int bondNo, double xuValue, double yuValue, double& c1, double& s1, double& xSize, double& ySize, double& xCenter, double& yCenter, int& nVert) {$/;"	f	class:OpenBabel::TemplateRedraw
rotate_atom	pointgroup.cpp	/^    rotate_atom( SYMMETRY_ELEMENT *axis, OBAtom *from, OBAtom *to )$/;"	f	class:OpenBabel::PointGroupPrivate
rotate_coords	obutil.cpp	/^  void rotate_coords(double *c,double m[3][3],unsigned int size)$/;"	f	namespace:OpenBabel
rotate_reflect_atom	pointgroup.cpp	/^    rotate_reflect_atom( SYMMETRY_ELEMENT *axis, OBAtom *from, OBAtom *to )$/;"	f	class:OpenBabel::PointGroupPrivate
rotorKey	conformersearch.cpp	/^    RotorKey rotorKey;$/;"	m	struct:OpenBabel::ConformerScore	file:
rx	mcdlutil.cpp	/^    double    rx;   \/*Internal X-coordinate representation*\/$/;"	m	class:OpenBabel::TSingleAtom	file:
ry	mcdlutil.cpp	/^    double    ry;   \/*Internal Y-coordinate representation*\/$/;"	m	class:OpenBabel::TSingleAtom	file:
same_transform	pointgroup.cpp	/^    same_transform( SYMMETRY_ELEMENT *a, SYMMETRY_ELEMENT *b )$/;"	f	class:OpenBabel::PointGroupPrivate
score	conformersearch.cpp	/^    double score;$/;"	m	struct:OpenBabel::ConformerScore	file:
score_population	conformersearch.cpp	/^  OBConformerSearch::score_population ()$/;"	f	class:OpenBabel::OBConformerSearch
seekoff	zipstreamimpl.h	/^  basic_unzip_streambuf<charT, traits>::seekoff(std::streamoff off, std::ios_base::seekdir way, std::ios_base::openmode)$/;"	f	class:basic_unzip_streambuf
seekpos	zipstreamimpl.h	/^  basic_unzip_streambuf<charT, traits>::seekpos(std::streampos sp, std::ios_base::openmode)$/;"	f	class:basic_unzip_streambuf
selectFragmentConfiguration	mcdlutil.cpp	/^  void TemplateRedraw::selectFragmentConfiguration(TSimpleMolecule * sm, std::vector<int>* atomList) {$/;"	f	class:OpenBabel::TemplateRedraw
setCoordinatesString	mcdlutil.cpp	/^  void TSimpleMolecule::setCoordinatesString(string value){$/;"	f	class:OpenBabel::TSimpleMolecule
setUpDownBonds	mcdlutil.cpp	/^  void setUpDownBonds(int atomNo, int parity, TSimpleMolecule & sm, std::vector<int>& iA1, std::vector<int>& iA2, std::vector<int>& stereoBonds) {$/;"	f	namespace:OpenBabel
set_params	pointgroup.cpp	/^    set_params( SYMMETRY_ELEMENT *elem, double values[] )$/;"	f	class:OpenBabel::PointGroupPrivate
setupRotorSearch	mcdlutil.cpp	/^  int TSimpleMolecule::setupRotorSearch(const vector<int> &rotBondList, vector<int>& inner_bonds, vector<int>& remainder)$/;"	f	class:OpenBabel::TSimpleMolecule
share_fitness	conformersearch.cpp	/^  OBConformerSearch::share_fitness ()$/;"	f	class:OpenBabel::OBConformerSearch
sharing_generation	conformersearch.cpp	/^  OBConformerSearch::sharing_generation ()$/;"	f	class:OpenBabel::OBConformerSearch
signed_volume	chiral.cpp	/^  double signed_volume(const vector3 &a, const vector3 &b, const vector3 &c, const vector3 &d)$/;"	f	namespace:OpenBabel
singleAtomicDescriptor	mcdlutil.cpp	/^  int TSimpleMolecule::singleAtomicDescriptor(int aNumber,int bNumber, bool useEnumerator) {$/;"	f	class:OpenBabel::TSimpleMolecule
singleVawe	mcdlutil.cpp	/^  void TSimpleMolecule::singleVawe(neighbourlist * bk, std::vector<int> & alreadyDefined,$/;"	f	class:OpenBabel::TSimpleMolecule
snprintf	snprintf.h	17;"	d
sort_symmetry_elements	pointgroup.cpp	/^    sort_symmetry_elements( void )$/;"	f	class:OpenBabel::PointGroupPrivate
sortpred_b	confsearch.cpp	/^  bool sortpred_b(const OBDiversePoses::PosePair& a, const OBDiversePoses::PosePair& b) {$/;"	f	namespace:OpenBabel
special	mcdlutil.cpp	/^    short int special;$/;"	m	class:OpenBabel::TSingleAtom	file:
special	mcdlutil.cpp	/^    short int special;$/;"	m	class:OpenBabel::TSingleBond	file:
sproduct	mcdlutil.cpp	/^  int sproduct(TSimpleMolecule & sm, int br, int i1, int i2) {$/;"	f	namespace:OpenBabel
src	chains.cpp	/^    int src,dst;$/;"	m	struct:OpenBabel::__anon3	file:
startTime	canon.cpp	/^      time_t startTime, maxTime;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::Timeout	file:
startTime	kekulize.cpp	/^      time_t startTime, maxTime;$/;"	m	struct:OpenBabel::Kekulize::Timeout	file:
start_kekulize	kekulize.cpp	/^  void OBMol::start_kekulize( std::vector <OBAtom*> &cycle, std::vector<int> &electron) {$/;"	f	class:OpenBabel::OBMol
stateDiff_t	kekulize.cpp	/^    struct stateDiff_t {$/;"	s	namespace:OpenBabel::Kekulize	file:
stereoBondChange	mcdlutil.cpp	/^  bool TEditedMolecule::stereoBondChange() {$/;"	f	class:OpenBabel::TEditedMolecule
stereoCenters	canon.cpp	/^      std::vector<StereoCenter> &stereoCenters;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::State	file:
strData	mcdlutil.cpp	/^  const string strData[NDATABASE_MOLECULES]= {$/;"	m	namespace:OpenBabel	file:
summarize_symmetry_elements	pointgroup.cpp	/^    summarize_symmetry_elements( void )$/;"	f	class:OpenBabel::PointGroupPrivate
superimpose	obutil.cpp	/^  double superimpose(double *r,double *f,int size)$/;"	f	namespace:OpenBabel
symClass	isomorphism.cpp	/^      unsigned int symClass;$/;"	m	class:OpenBabel::OBAutomorphismQueryAtom	file:
symClasses	isomorphism.cpp	/^      std::vector<unsigned int> symClasses;$/;"	m	class:OpenBabel::OBAutomorphismQueryAtom	file:
symmetry_classes	canon.cpp	/^      const std::vector<unsigned int> &symmetry_classes;$/;"	m	struct:OpenBabel::CanonicalLabelsImpl::State	file:
symmetry_code	pointgroup.cpp	/^    const char *  symmetry_code ;     \/* Group symmetry code                         *\/$/;"	m	struct:OpenBabel::__anon8	file:
sync	zipstreamimpl.h	/^int basic_zip_streambuf<charT, traits>::sync(void)$/;"	f	class:basic_zip_streambuf
tb	mcdlutil.cpp	/^    short int tb;$/;"	m	class:OpenBabel::TSingleBond	file:
tcond	chains.cpp	/^    union _ByteCode *tcond;$/;"	m	struct:OpenBabel::__anon5	typeref:union:OpenBabel::__anon5::_ByteCode	file:
threeBondResolve	mcdlutil.cpp	/^  bool TSimpleMolecule::threeBondResolve(int an, int bondExcluded, double& xv, double& yv, neighbourlist* bkExt) {$/;"	f	class:OpenBabel::TSimpleMolecule
titan	mcdlutil.cpp	/^  const int titan[NTITANATOMS] ={22,40,72};$/;"	m	namespace:OpenBabel	file:
tokenize	tokenst.cpp	/^  bool tokenize(std::vector<std::string> &vcr, const char *buf,$/;"	f	namespace:OpenBabel
tokenize	tokenst.cpp	/^  bool tokenize(std::vector<std::string> &vcr, std::string &s,$/;"	f	namespace:OpenBabel
top	mcdlutil.cpp	/^    double left,top,right,bottom;$/;"	m	class:OpenBabel::Rect	file:
transform	pointgroup.cpp	/^      int *   transform ;     \/*   Correspondence table for the transformation         *\/$/;"	m	struct:OpenBabel::PointGroupPrivate::_SYMMETRY_ELEMENT_	file:
transform_atom	pointgroup.cpp	/^      void    (*transform_atom)( struct _SYMMETRY_ELEMENT_ *el, OBAtom *from, OBAtom *to ) ;$/;"	m	struct:OpenBabel::PointGroupPrivate::_SYMMETRY_ELEMENT_	file:
trim_spaces	tokenst.cpp	/^  char *trim_spaces(char *string)$/;"	f	namespace:OpenBabel
trivalent	mcdlutil.cpp	/^  const int trivalent[NTRIVALENTATOMS] ={21,31,39,49,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,81,89,90,91,92,93,94,95,96,97,98,99};$/;"	m	namespace:OpenBabel	file:
ttab	data.cpp	/^  OBTypeTable      ttab;$/;"	m	namespace:OpenBabel	file:
twoAtomUnitVector	mcdlutil.cpp	/^  void TSimpleMolecule::twoAtomUnitVector(int na1, int na2, double & xv, double & yv, const std::vector<int>atomDefine) {$/;"	f	class:OpenBabel::TSimpleMolecule
type	chains.cpp	/^    int type;$/;"	m	struct:OpenBabel::__anon4	file:
type	chains.cpp	/^    int type;$/;"	m	struct:OpenBabel::__anon5	file:
type	chains.cpp	/^    int type;$/;"	m	struct:OpenBabel::__anon6	file:
type	chains.cpp	/^    int type;$/;"	m	union:OpenBabel::_ByteCode	file:
type_to_int	patty.cpp	/^  int patty::type_to_int(const string &type, bool failOnUndefined)$/;"	f	class:OpenBabel::patty
underflow	zipstreamimpl.h	/^basic_unzip_streambuf<charT, traits>::underflow(void)$/;"	f	class:basic_unzip_streambuf
unitVector	mcdlutil.cpp	/^  void TSimpleMolecule::unitVector(int aN, double& xV, double& yV) {$/;"	f	class:OpenBabel::TSimpleMolecule
unitVectorCoincident	mcdlutil.cpp	/^  bool TSimpleMolecule::unitVectorCoincident(int aN, double xV, double yV) {$/;"	f	class:OpenBabel::TSimpleMolecule
unzip_from_stream	zipstreamimpl.h	/^basic_unzip_streambuf<charT, traits>::unzip_from_stream(char_type* buffer,$/;"	f	class:basic_unzip_streambuf
valencyConversion	mcdlutil.cpp	/^  int TSingleAtom::valencyConversion() {$/;"	f	class:OpenBabel::TSingleAtom
value	chains.cpp	/^    int value;$/;"	m	struct:OpenBabel::__anon5	file:
vanadium	mcdlutil.cpp	/^  const int vanadium[NVANADIUMATOMS] ={23,41,73};$/;"	m	namespace:OpenBabel	file:
vasnprintf	snprintf.c	/^int vasnprintf (char **ptr, size_t str_m, const char *fmt, va_list ap)$/;"	f
vasprintf	snprintf.c	/^int vasprintf(char **ptr, const char *fmt, va_list ap)$/;"	f
vaweBond	mcdlutil.cpp	/^  void TSimpleMolecule::vaweBond(int bondN, neighbourlist *bk,$/;"	f	class:OpenBabel::TSimpleMolecule
verbose	pointgroup.cpp	/^    int                    verbose               ;$/;"	m	class:OpenBabel::PointGroupPrivate	file:
visitRing	ring.cpp	/^  void visitRing(OBMol *mol, OBRing *ring, std::vector<OBRing*> &rlist, std::vector<OBRing*> &rignored)$/;"	f	namespace:OpenBabel
vsnprintf	snprintf.h	18;"	d
w	mcdlutil.cpp	/^    int bn,w;$/;"	m	class:OpenBabel::StereoBondStore	file:
x	mcdlutil.cpp	/^    double x,y;$/;"	m	class:OpenBabel::Point	file:
xDistPoint	mcdlutil.cpp	/^  double xDistPoint(double x1, double y1, double x2, double y2, double x0, double y0) {$/;"	f	namespace:OpenBabel
y	mcdlutil.cpp	/^    double x,y;$/;"	m	class:OpenBabel::Point	file:
yellow	isomorphism.cpp	/^  static const char *yellow = "\\033[1;33m";$/;"	m	namespace:OpenBabel	file:
zflush	zipstreamimpl.h	/^basic_zip_ostream<charT, traits>& basic_zip_ostream<charT, traits>::zflush(void)$/;"	f	class:basic_zip_ostream
zink	mcdlutil.cpp	/^  const int zink[NZINKATOMS] ={30,48};$/;"	m	namespace:OpenBabel	file:
zip_istream	zipstream.h	/^typedef basic_zip_istream<char> zip_istream;$/;"	t	namespace:zlib_stream
zip_ostream	zipstream.h	/^typedef basic_zip_ostream<char> zip_ostream;$/;"	t	namespace:zlib_stream
zip_to_stream	zipstreamimpl.h	/^bool basic_zip_streambuf<charT, traits>::zip_to_stream($/;"	f	class:basic_zip_streambuf
zlib_stream	zipstream.h	/^namespace zlib_stream {$/;"	n
zstream_default_buffer_size	zipstream.h	/^const size_t zstream_default_buffer_size = 4096;$/;"	m	namespace:zlib_stream
~DistanceGeometryPrivate	distgeom.cpp	/^    ~DistanceGeometryPrivate()$/;"	f	class:OpenBabel::DistanceGeometryPrivate
~FastSearchIndexer	fingerprint.cpp	/^  FastSearchIndexer::~FastSearchIndexer()$/;"	f	class:OpenBabel::FastSearchIndexer
~OBAromaticTyper	typer.cpp	/^  OBAromaticTyper::~OBAromaticTyper()$/;"	f	class:OpenBabel::OBAromaticTyper
~OBAtom	atom.cpp	/^  OBAtom::~OBAtom()$/;"	f	class:OpenBabel::OBAtom
~OBAtomTyper	typer.cpp	/^  OBAtomTyper::~OBAtomTyper()$/;"	f	class:OpenBabel::OBAtomTyper
~OBBond	bond.cpp	/^  OBBond::~OBBond()$/;"	f	class:OpenBabel::OBBond
~OBBondTyper	bondtyper.cpp	/^  OBBondTyper::~OBBondTyper()$/;"	f	class:OpenBabel::OBBondTyper
~OBChainsParser	chains.cpp	/^  OBChainsParser::~OBChainsParser(void)$/;"	f	class:OpenBabel::OBChainsParser
~OBConformerFilter	conformersearch.cpp	/^  OBConformerFilter::~OBConformerFilter() {}$/;"	f	class:OpenBabel::OBConformerFilter
~OBConformerScore	conformersearch.cpp	/^  OBConformerScore::~OBConformerScore() {}$/;"	f	class:OpenBabel::OBConformerScore
~OBConformerSearch	conformersearch.cpp	/^  OBConformerSearch::~OBConformerSearch()$/;"	f	class:OpenBabel::OBConformerSearch
~OBConversion	obconversion.cpp	/^  OBConversion::~OBConversion()$/;"	f	class:OpenBabel::OBConversion
~OBDistanceGeometry	distgeom.cpp	/^  OBDistanceGeometry::~OBDistanceGeometry()$/;"	f	class:OpenBabel::OBDistanceGeometry
~OBDiversePoses	confsearch.cpp	/^      ~OBDiversePoses() {$/;"	f	class:OpenBabel::OBDiversePoses
~OBElementTable	data.cpp	/^  OBElementTable::~OBElementTable()$/;"	f	class:OpenBabel::OBElementTable
~OBGastChrg	molchrg.cpp	/^  OBGastChrg::~OBGastChrg()$/;"	f	class:OpenBabel::OBGastChrg
~OBGraphSym	graphsym.cpp	/^  OBGraphSym::~OBGraphSym()$/;"	f	class:OpenBabel::OBGraphSym
~OBGridData	griddata.cpp	/^  OBGridData::~OBGridData()$/;"	f	class:OpenBabel::OBGridData
~OBIsomorphismMapper	isomorphism.cpp	/^  OBIsomorphismMapper::~OBIsomorphismMapper()$/;"	f	class:OpenBabel::OBIsomorphismMapper
~OBLocale	locale.cpp	/^  OBLocale::~OBLocale()$/;"	f	class:OpenBabel::OBLocale
~OBLocalePrivate	locale.cpp	/^    ~OBLocalePrivate()$/;"	f	class:OpenBabel::OBLocalePrivate
~OBMessageHandler	oberror.cpp	/^  OBMessageHandler::~OBMessageHandler()$/;"	f	class:OpenBabel::OBMessageHandler
~OBMol	mol.cpp	/^  OBMol::~OBMol()$/;"	f	class:OpenBabel::OBMol
~OBPhModel	phmodel.cpp	/^  OBPhModel::~OBPhModel()$/;"	f	class:OpenBabel::OBPhModel
~OBPointGroup	pointgroup.cpp	/^  OBPointGroup::~OBPointGroup()$/;"	f	class:OpenBabel::OBPointGroup
~OBResidue	residue.cpp	/^  OBResidue::~OBResidue()$/;"	f	class:OpenBabel::OBResidue
~OBRingData	generic.cpp	/^  OBRingData::~OBRingData()$/;"	f	class:OpenBabel::OBRingData
~OBRingSearch	ring.cpp	/^  OBRingSearch::~OBRingSearch()$/;"	f	class:OpenBabel::OBRingSearch
~OBRingTyper	typer.cpp	/^  OBRingTyper::~OBRingTyper()$/;"	f	class:OpenBabel::OBRingTyper
~OBRotamerList	rotamer.cpp	/^  OBRotamerList::~OBRotamerList()$/;"	f	class:OpenBabel::OBRotamerList
~OBRotorList	rotor.cpp	/^  OBRotorList::~OBRotorList()$/;"	f	class:OpenBabel::OBRotorList
~OBRotorRules	rotor.cpp	/^  OBRotorRules::~OBRotorRules()$/;"	f	class:OpenBabel::OBRotorRules
~OBSSMatch	parsmart.cpp	/^  OBSSMatch::~OBSSMatch()$/;"	f	class:OpenBabel::OBSSMatch
~OBSmartsPattern	parsmart.cpp	/^  OBSmartsPattern::~OBSmartsPattern()$/;"	f	class:OpenBabel::OBSmartsPattern
~OBSpectrophore	spectrophore.cpp	/^OBSpectrophore::~OBSpectrophore(void)$/;"	f	class:OpenBabel::OBSpectrophore
~TSimpleMolecule	mcdlutil.cpp	/^    virtual ~TSimpleMolecule() {$/;"	f	class:OpenBabel::TSimpleMolecule
~basic_unzip_streambuf	zipstreamimpl.h	/^basic_unzip_streambuf<charT, traits>::~basic_unzip_streambuf(void)$/;"	f	class:basic_unzip_streambuf
~basic_zip_ostream	zipstreamimpl.h	/^basic_zip_ostream<charT, traits>::~basic_zip_ostream(void)$/;"	f	class:basic_zip_ostream
~basic_zip_streambuf	zipstreamimpl.h	/^basic_zip_streambuf<charT, traits>::~basic_zip_streambuf(void)$/;"	f	class:basic_zip_streambuf
